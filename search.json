[
  {
    "objectID": "models.rnnplus.html",
    "href": "models.rnnplus.html",
    "title": "RNNPlus",
    "section": "",
    "text": "These are RNN, LSTM and GRU PyTorch implementations created by Ignacio Oguiza - oguiza@timeseriesAI.co\nThe idea of including a feature extractor to the RNN network comes from the solution developed by the UPSTAGE team (https://www.kaggle.com/songwonho, https://www.kaggle.com/limerobot and https://www.kaggle.com/jungikhyo). They finished in 3rd position in Kaggle’s Google Brain - Ventilator Pressure Prediction competition. They used a Conv1d + Stacked LSTM architecture.\nsource",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNPlus"
    ]
  },
  {
    "objectID": "models.rnnplus.html#converting-a-model-to-torchscript",
    "href": "models.rnnplus.html#converting-a-model-to-torchscript",
    "title": "RNNPlus",
    "section": "Converting a model to TorchScript",
    "text": "Converting a model to TorchScript\n\nmodel = GRUPlus(c_in, c_out, hidden_size=100, n_layers=2, bidirectional=True, rnn_dropout=.5, fc_dropout=.5)\nmodel.eval()\ninp = torch.rand(1, c_in, 50)\noutput = model(inp)\nprint(output)\n\ntensor([[-0.0677, -0.0857]], grad_fn=&lt;AddmmBackward0&gt;)\n\n\n\nTracing\n\n# save to gpu, cpu or both\ntraced_cpu = torch.jit.trace(model.cpu(), inp)\nprint(traced_cpu)\ntorch.jit.save(traced_cpu, \"cpu.pt\")\n\n# load cpu or gpu model\ntraced_cpu = torch.jit.load(\"cpu.pt\")\ntest_eq(traced_cpu(inp), output)\n\n!rm \"cpu.pt\"\n\nGRUPlus(\n  original_name=GRUPlus\n  (backbone): _RNN_Backbone(\n    original_name=_RNN_Backbone\n    (to_cat_embed): Identity(original_name=Identity)\n    (feature_extractor): Identity(original_name=Identity)\n    (rnn): Sequential(\n      original_name=Sequential\n      (0): GRU(original_name=GRU)\n      (1): LSTMOutput(original_name=LSTMOutput)\n    )\n    (transpose): Transpose(original_name=Transpose)\n  )\n  (head): Sequential(\n    original_name=Sequential\n    (0): LastStep(original_name=LastStep)\n    (1): Dropout(original_name=Dropout)\n    (2): Linear(original_name=Linear)\n  )\n)",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNPlus"
    ]
  },
  {
    "objectID": "models.rnnplus.html#converting-a-model-to-onnx",
    "href": "models.rnnplus.html#converting-a-model-to-onnx",
    "title": "RNNPlus",
    "section": "Converting a model to ONNX",
    "text": "Converting a model to ONNX\nimport onnx\n\ntorch.onnx.export(model.cpu(),               # model being run\n                  inp,                       # model input (or a tuple for multiple inputs)\n                  \"cpu.onnx\",                # where to save the model (can be a file or file-like object)\n                  export_params=True,        # store the trained parameter weights inside the model file\n                  verbose=False,\n                  opset_version=13,          # the ONNX version to export the model to\n                  do_constant_folding=True,  # whether to execute constant folding for optimization\n                  input_names = ['input'],   # the model's input names\n                  output_names = ['output'], # the model's output names\n                  dynamic_axes={\n                      'input'  : {0 : 'batch_size'}, \n                      'output' : {0 : 'batch_size'}} # variable length axes\n                 )\n\n\nonnx_model = onnx.load(\"cpu.onnx\")           # Load the model and check it's ok\nonnx.checker.check_model(onnx_model)\nimport onnxruntime as ort\n\nort_sess = ort.InferenceSession('cpu.onnx')\nout = ort_sess.run(None, {'input': inp.numpy()})\n\ninput_name = ort_sess.get_inputs()[0].name\noutput_name = ort_sess.get_outputs()[0].name\ninput_dims = ort_sess.get_inputs()[0].shape\n\ntest_close(out, output.detach().numpy())\n!rm \"cpu.onnx\"",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNPlus"
    ]
  },
  {
    "objectID": "models.inceptiontimeplus.html",
    "href": "models.inceptiontimeplus.html",
    "title": "InceptionTimePlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation of InceptionTime (Fawaz, 2019) created by Ignacio Oguiza.\n\nReferences: * Fawaz, H. I., Lucas, B., Forestier, G., Pelletier, C., Schmidt, D. F., Weber, J., … & Petitjean, F. (2020). Inceptiontime: Finding alexnet for time series classification. Data Mining and Knowledge Discovery, 34(6), 1936-1962. * Official InceptionTime tensorflow implementation: https://github.com/hfawaz/InceptionTime\n\nsource\n\nInceptionBlockPlus\n\n InceptionBlockPlus (ni, nf, residual=True, depth=6, coord=False,\n                     norm='Batch', zero_norm=False, act=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={},\n                     sa=False, se=None, stoch_depth=1.0, ks=40,\n                     bottleneck=True, padding='same', separable=False,\n                     dilation=1, stride=1, conv_dropout=0.0, bn_1st=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nInceptionModulePlus\n\n InceptionModulePlus (ni, nf, ks=40, bottleneck=True, padding='same',\n                      coord=False, separable=False, dilation=1, stride=1,\n                      conv_dropout=0.0, sa=False, se=None, norm='Batch',\n                      zero_norm=False, bn_1st=True, act=&lt;class\n                      'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nInceptionTimePlus\n\n InceptionTimePlus (c_in, c_out, seq_len=None, nf=32, nb_filters=None,\n                    flatten=False, concat_pool=False, fc_dropout=0.0,\n                    bn=False, y_range=None, custom_head=None, ks=40,\n                    bottleneck=True, padding='same', coord=False,\n                    separable=False, dilation=1, stride=1,\n                    conv_dropout=0.0, sa=False, se=None, norm='Batch',\n                    zero_norm=False, bn_1st=True, act=&lt;class\n                    'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nXCoordTime\n\n XCoordTime (c_in, c_out, seq_len=None, nf=32, nb_filters=None,\n             flatten=False, concat_pool=False, fc_dropout=0.0, bn=False,\n             y_range=None, custom_head=None, ks=40, bottleneck=True,\n             padding='same', coord=False, separable=False, dilation=1,\n             stride=1, conv_dropout=0.0, sa=False, se=None, norm='Batch',\n             zero_norm=False, bn_1st=True, act=&lt;class\n             'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nInCoordTime\n\n InCoordTime (c_in, c_out, seq_len=None, nf=32, nb_filters=None,\n              flatten=False, concat_pool=False, fc_dropout=0.0, bn=False,\n              y_range=None, custom_head=None, ks=40, bottleneck=True,\n              padding='same', coord=False, separable=False, dilation=1,\n              stride=1, conv_dropout=0.0, sa=False, se=None, norm='Batch',\n              zero_norm=False, bn_1st=True, act=&lt;class\n              'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom tsai.data.core import TSCategorize\nfrom tsai.models.utils import count_parameters\n\n\nbs = 16\nn_vars = 3\nseq_len = 51\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\n\ntest_eq(InceptionTimePlus(n_vars,c_out)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out,concat_pool=True)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out, bottleneck=False)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out, residual=False)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out, conv_dropout=.5)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out, stoch_depth=.5)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars, c_out, seq_len=seq_len, zero_norm=True, flatten=True)(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out, coord=True, separable=True, \n                          norm='Instance', zero_norm=True, bn_1st=False, fc_dropout=.5, sa=True, se=True, act=nn.PReLU, act_kwargs={})(xb).shape, [bs, c_out])\ntest_eq(InceptionTimePlus(n_vars,c_out, coord=True, separable=True,\n                          norm='Instance', zero_norm=True, bn_1st=False, act=nn.PReLU, act_kwargs={})(xb).shape, [bs, c_out])\ntest_eq(count_parameters(InceptionTimePlus(3, 2)), 455490)\ntest_eq(count_parameters(InceptionTimePlus(6, 2, **{'coord': True, 'separable': True, 'zero_norm': True})), 77204)\ntest_eq(count_parameters(InceptionTimePlus(3, 2, ks=40)), count_parameters(InceptionTimePlus(3, 2, ks=[9, 19, 39])))\n\n\nbs = 16\nn_vars = 3\nseq_len = 51\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\n\nmodel = InceptionTimePlus(n_vars, c_out)\nmodel(xb).shape\ntest_eq(model[0](xb), model.backbone(xb))\ntest_eq(model[1](model[0](xb)), model.head(model[0](xb)))\ntest_eq(model[1].state_dict().keys(), model.head.state_dict().keys())\ntest_eq(len(ts_splitter(model)), 2)\n\n\ntest_eq(check_bias(InceptionTimePlus(2,3, zero_norm=True), is_conv)[0].sum(), 0)\ntest_eq(check_weight(InceptionTimePlus(2,3, zero_norm=True), is_bn)[0].sum(), 6)\ntest_eq(check_weight(InceptionTimePlus(2,3), is_bn)[0], np.array([1., 1., 1., 1., 1., 1., 1., 1.]))\n\n\nfor i in range(10): InceptionTimePlus(n_vars,c_out,stoch_depth=0.8,depth=9,zero_norm=True)(xb)\n\n\nnet = InceptionTimePlus(2,3,**{'coord': True, 'separable': True, 'zero_norm': True})\ntest_eq(check_weight(net, is_bn)[0], np.array([1., 1., 0., 1., 1., 0., 1., 1.]))\nnet\n\nInceptionTimePlus(\n  (backbone): Sequential(\n    (0): InceptionBlockPlus(\n      (inception): ModuleList(\n        (0): InceptionModulePlus(\n          (bottleneck): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(3, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (convs): ModuleList(\n            (0): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (2): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n          )\n          (mp_conv): Sequential(\n            (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): Conv1d(3, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (concat): Concat(dim=1)\n          (norm): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n          (act): ReLU()\n        )\n        (1): InceptionModulePlus(\n          (bottleneck): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (convs): ModuleList(\n            (0): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (2): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n          )\n          (mp_conv): Sequential(\n            (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (concat): Concat(dim=1)\n          (norm): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n          (act): ReLU()\n        )\n        (2): InceptionModulePlus(\n          (bottleneck): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (convs): ModuleList(\n            (0): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (2): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n          )\n          (mp_conv): Sequential(\n            (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (concat): Concat(dim=1)\n          (norm): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (3): InceptionModulePlus(\n          (bottleneck): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (convs): ModuleList(\n            (0): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (2): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n          )\n          (mp_conv): Sequential(\n            (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (concat): Concat(dim=1)\n          (norm): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n          (act): ReLU()\n        )\n        (4): InceptionModulePlus(\n          (bottleneck): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (convs): ModuleList(\n            (0): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (2): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n          )\n          (mp_conv): Sequential(\n            (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (concat): Concat(dim=1)\n          (norm): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n          (act): ReLU()\n        )\n        (5): InceptionModulePlus(\n          (bottleneck): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (convs): ModuleList(\n            (0): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n            (2): ConvBlock(\n              (0): AddCoords1d()\n              (1): SeparableConv1d(\n                (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n                (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n              )\n            )\n          )\n          (mp_conv): Sequential(\n            (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n            (1): ConvBlock(\n              (0): AddCoords1d()\n              (1): Conv1d(129, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (concat): Concat(dim=1)\n          (norm): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n      (shortcut): ModuleList(\n        (0): ConvBlock(\n          (0): AddCoords1d()\n          (1): Conv1d(3, 128, kernel_size=(1,), stride=(1,), bias=False)\n          (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (act): ModuleList(\n        (0): ReLU()\n        (1): ReLU()\n      )\n      (add): Add\n    )\n  )\n  (head): Sequential(\n    (0): Sequential(\n      (0): GAP1d(\n        (gap): AdaptiveAvgPool1d(output_size=1)\n        (flatten): Reshape(bs)\n      )\n      (1): LinBnDrop(\n        (0): Linear(in_features=128, out_features=3, bias=True)\n      )\n    )\n  )\n)\n\n\n\nsource\n\n\nMultiInceptionTimePlus\n\n MultiInceptionTimePlus (feat_list, c_out, seq_len=None, nf=32,\n                         nb_filters=None, depth=6, stoch_depth=1.0,\n                         flatten=False, concat_pool=False, fc_dropout=0.0,\n                         bn=False, y_range=None, custom_head=None)\n\nClass that allows you to create a model with multiple branches of InceptionTimePlus.\n\nbs = 16\nn_vars = 3\nseq_len = 51\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\n\ntest_eq(count_parameters(MultiInceptionTimePlus([1,1,1], c_out)) &gt; count_parameters(MultiInceptionTimePlus(3, c_out)), True)\ntest_eq(MultiInceptionTimePlus([1,1,1], c_out).to(xb.device)(xb).shape, MultiInceptionTimePlus(3, c_out).to(xb.device)(xb).shape)\n\n[W NNPACK.cpp:53] Could not initialize NNPACK! Reason: Unsupported hardware.\n\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 10\nxb = torch.rand(bs, n_vars, seq_len)\nnew_head = partial(conv_lin_nd_head, d=(5,2))\nnet = MultiInceptionTimePlus(n_vars, c_out, seq_len, custom_head=new_head)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([16, 5, 2, 10])\n\n\nSequential(\n  (0): create_conv_lin_nd_head(\n    (0): Conv1d(128, 10, kernel_size=(1,), stride=(1,))\n    (1): Linear(in_features=12, out_features=10, bias=True)\n    (2): Transpose(-1, -2)\n    (3): Reshape(bs, 5, 2, 10)\n  )\n)\n\n\n\nbs = 16\nn_vars = 6\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\nnet = MultiInceptionTimePlus([1,2,3], c_out, seq_len)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([16, 2])\n\n\nSequential(\n  (0): Sequential(\n    (0): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Reshape(bs)\n    )\n    (1): LinBnDrop(\n      (0): Linear(in_features=384, out_features=2, bias=True)\n    )\n  )\n)\n\n\n\nbs = 8\nc_in = 7  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 10\nxb2 = torch.randn(bs, c_in, seq_len)\nmodel1 = MultiInceptionTimePlus([2, 5], c_out, seq_len)\nmodel2 = MultiInceptionTimePlus([[0,2,5], [0,1,3,4,6]], c_out, seq_len)\ntest_eq(model1.to(xb2.device)(xb2).shape, (bs, c_out))\ntest_eq(model1.to(xb2.device)(xb2).shape, model2.to(xb2.device)(xb2).shape)\n\n\nfrom tsai.data.external import *\nfrom tsai.data.core import *\nfrom tsai.data.preprocessing import *\n\n\nX, y, splits = get_UCR_data('NATOPS', split_data=False)\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nmodel = InceptionTimePlus(dls.vars, dls.c, dls.len)\nxb,yb=first(dls.train)\ntest_eq(model.to(xb.device)(xb).shape, (dls.bs, dls.c))\ntest_eq(count_parameters(model), 460038)\n\n\nX, y, splits = get_UCR_data('NATOPS', split_data=False)\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nmodel = MultiInceptionTimePlus([4, 15, 5], dls.c, dls.len)\nxb,yb=first(dls.train)\ntest_eq(model.to(xb.device)(xb).shape, (dls.bs, dls.c))\ntest_eq(count_parameters(model), 1370886)",
    "crumbs": [
      "Models",
      "CNNs",
      "InceptionTimePlus"
    ]
  },
  {
    "objectID": "data.transforms.html",
    "href": "data.transforms.html",
    "title": "Time Series Data Augmentation",
    "section": "",
    "text": "Functions used to transform TSTensors (Data Augmentation)\n\n\nfrom tsai.data.core import TSCategorize\nfrom tsai.data.external import get_UCR_data\nfrom tsai.data.preprocessing import TSStandardize\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\ntfms = [None, TSCategorize()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits, batch_tfms=batch_tfms, bs=128)\nxb, yb = next(iter(dls.train))\n\n\nsource\n\nTSIdentity\n\n TSIdentity (magnitude=None, **kwargs)\n\nApplies the identity tfm to a TSTensor batch\n\ntest_eq(TSIdentity()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSShuffle_HLs\n\n TSShuffle_HLs (magnitude=1.0, ex=None, **kwargs)\n\nRandomly shuffles HIs/LOs of an OHLC TSTensor batch\n\ntest_eq(TSShuffle_HLs()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSShuffleSteps\n\n TSShuffleSteps (magnitude=1.0, ex=None, **kwargs)\n\nRandomly shuffles consecutive sequence datapoints in batch\n\nt = TSTensor(torch.arange(11).float())\ntt_ = []\nfor _ in range(1000):\n    tt = TSShuffleSteps()(t, split_idx=0)\n    test_eq(len(set(tt.tolist())), len(t))\n    test_ne(tt, t)\n    tt_.extend([t for i,t in enumerate(tt) if t!=i])\nx, y = np.unique(tt_, return_counts=True) # This is to visualize distribution which should be equal for all and half for first and last items\nplt.bar(x, y);\n\n\n\n\n\n\n\n\n\nsource\n\n\nTSGaussianNoise\n\n TSGaussianNoise (magnitude=0.5, additive=True, ex=None, **kwargs)\n\nApplies additive or multiplicative gaussian noise\n\ntest_eq(TSGaussianNoise(.1, additive=True)(xb, split_idx=0).shape, xb.shape)\ntest_eq(TSGaussianNoise(.1, additive=False)(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSMagMulNoise\n\n TSMagMulNoise (magnitude=1, ex=None, **kwargs)\n\nApplies multiplicative noise on the y-axis for each step of a TSTensor batch\n\nsource\n\n\nTSMagAddNoise\n\n TSMagAddNoise (magnitude=1, ex=None, **kwargs)\n\nApplies additive noise on the y-axis for each step of a TSTensor batch\n\ntest_eq(TSMagAddNoise()(xb, split_idx=0).shape, xb.shape)\ntest_eq(TSMagMulNoise()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSMagAddNoise()(xb, split_idx=0), xb)\ntest_ne(TSMagMulNoise()(xb, split_idx=0), xb)\n\n\nsource\n\n\nrandom_cum_linear_generator\n\n random_cum_linear_generator (o, magnitude=0.1)\n\n\nsource\n\n\nrandom_cum_noise_generator\n\n random_cum_noise_generator (o, magnitude=0.1, noise=None)\n\n\nsource\n\n\nrandom_cum_curve_generator\n\n random_cum_curve_generator (o, magnitude=0.1, order=4, noise=None)\n\n\nsource\n\n\nrandom_curve_generator\n\n random_curve_generator (o, magnitude=0.1, order=4, noise=None)\n\n\nsource\n\n\nTSTimeNoise\n\n TSTimeNoise (magnitude=0.1, ex=None, **kwargs)\n\nApplies noise to each step in the x-axis of a TSTensor batch based on smooth random curve\n\ntest_eq(TSTimeNoise()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSTimeNoise()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSMagWarp\n\n TSMagWarp (magnitude=0.02, ord=4, ex=None, **kwargs)\n\nApplies warping to the y-axis of a TSTensor batch based on a smooth random curve\n\ntest_eq(TSMagWarp()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSMagWarp()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSTimeWarp\n\n TSTimeWarp (magnitude=0.1, ord=6, ex=None, **kwargs)\n\nApplies time warping to the x-axis of a TSTensor batch based on a smooth random curve\n\ntest_eq(TSTimeWarp()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSTimeWarp()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSWindowWarp\n\n TSWindowWarp (magnitude=0.1, ex=None, **kwargs)\n\nApplies window slicing to the x-axis of a TSTensor batch based on a random linear curve based on https://halshs.archives-ouvertes.fr/halshs-01357973/document\n\ntest_eq(TSWindowWarp()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSMagScalePerVar\n\n TSMagScalePerVar (magnitude=0.5, ex=None, **kwargs)\n\nApplies per_var scaling to the y-axis of a TSTensor batch based on a scalar\n\nsource\n\n\nTSMagScale\n\n TSMagScale (magnitude=0.5, ex=None, **kwargs)\n\nApplies scaling to the y-axis of a TSTensor batch based on a scalar\n\ntest_eq(TSMagScale()(xb, split_idx=0).shape, xb.shape)\ntest_eq(TSMagScalePerVar()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSMagScale()(xb, split_idx=0), xb)\ntest_ne(TSMagScalePerVar()(xb, split_idx=0), xb)\n\n\nsource\n\n\ntest_interpolate\n\n test_interpolate (mode='linear')\n\n\n# Run the test\ntest_interpolate('linear')\n\nTrue\n\n\n\ntest_interpolate('nearest')\n\nTrue\n\n\n\nsource\n\n\nTSRandomResizedCrop\n\n TSRandomResizedCrop (magnitude=0.1, size=None, scale=None, ex=None,\n                      mode='nearest', **kwargs)\n\nRandomly amplifies a sequence focusing on a random section of the steps\n\nif test_interpolate('nearest'):\n    test_eq(TSRandomResizedCrop(.5)(xb, split_idx=0).shape, xb.shape)\n    test_ne(TSRandomResizedCrop(size=.8, scale=(.5, 1))(xb, split_idx=0).shape, xb.shape)\n    test_ne(TSRandomResizedCrop(size=20, scale=(.5, 1))(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSWindowSlicing\n\n TSWindowSlicing (magnitude=0.1, ex=None, mode='nearest', **kwargs)\n\nRandomly extracts an resize a ts slice based on https://halshs.archives-ouvertes.fr/halshs-01357973/document\n\nif test_interpolate('nearest'):\n    test_eq(TSWindowSlicing()(xb, split_idx=0).shape, xb.shape)\n    test_ne(TSWindowSlicing()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSRandomZoomOut\n\n TSRandomZoomOut (magnitude=0.1, ex=None, mode='nearest', **kwargs)\n\nRandomly compresses a sequence on the x-axis\n\nif test_interpolate('nearest'):\n    test_eq(TSRandomZoomOut(.5)(xb, split_idx=0).shape, xb.shape)#\n\n\nsource\n\n\nTSRandomTimeScale\n\n TSRandomTimeScale (magnitude=0.1, ex=None, mode='nearest', **kwargs)\n\nRandomly amplifies/ compresses a sequence on the x-axis keeping the same length\n\nif test_interpolate('nearest'):\n    test_eq(TSRandomTimeScale(.5)(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSRandomTimeStep\n\n TSRandomTimeStep (magnitude=0.02, ex=None, mode='nearest', **kwargs)\n\nCompresses a sequence on the x-axis by randomly selecting sequence steps and interpolating to previous size\n\nif test_interpolate('nearest'):\n    test_eq(TSRandomTimeStep()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSResampleSteps\n\n TSResampleSteps (step_pct=1.0, same_seq_len=True, magnitude=None,\n                  **kwargs)\n\nTransform that randomly selects and sorts sequence steps (with replacement) maintaining the sequence length\n\ntest_eq(TSResampleSteps(step_pct=.9, same_seq_len=False)(xb, split_idx=0).shape[-1], round(.9*xb.shape[-1]))\ntest_eq(TSResampleSteps(step_pct=.9, same_seq_len=True)(xb, split_idx=0).shape[-1], xb.shape[-1])\n\n\nsource\n\n\nTSBlur\n\n TSBlur (magnitude=1.0, ex=None, filt_len=None, **kwargs)\n\nBlurs a sequence applying a filter of type [1, 0, 1]\n\ntest_eq(TSBlur(filt_len=7)(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSBlur()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSSmooth\n\n TSSmooth (magnitude=1.0, ex=None, filt_len=None, **kwargs)\n\nSmoothens a sequence applying a filter of type [1, 5, 1]\n\ntest_eq(TSSmooth(filt_len=7)(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSSmooth()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSFreqDenoise\n\n TSFreqDenoise (magnitude=0.1, ex=None, wavelet='db4', level=2, thr=None,\n                thr_mode='hard', pad_mode='per', **kwargs)\n\nDenoises a sequence applying a wavelet decomposition method\n\nsource\n\n\nmaddest\n\n maddest (d, axis=None)\n\n\ntry: import pywt\nexcept ImportError: pass\n\n\nif 'pywt' in dir():\n    test_eq(TSFreqDenoise()(xb, split_idx=0).shape, xb.shape)\n    test_ne(TSFreqDenoise()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSRandomFreqNoise\n\n TSRandomFreqNoise (magnitude=0.1, ex=None, wavelet='db4', level=2,\n                    mode='constant', **kwargs)\n\nApplys random noise using a wavelet decomposition method\n\nif 'pywt' in dir():\n    test_eq(TSRandomFreqNoise()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSRandomResizedLookBack\n\n TSRandomResizedLookBack (magnitude=0.1, mode='nearest', **kwargs)\n\nSelects a random number of sequence steps starting from the end and return an output of the same shape\n\nif test_interpolate('nearest'):\n    for i in range(100):\n        o = TSRandomResizedLookBack()(xb, split_idx=0)\n        test_eq(o.shape[-1], xb.shape[-1])\n\n\nsource\n\n\nTSRandomLookBackOut\n\n TSRandomLookBackOut (magnitude=0.1, **kwargs)\n\nSelects a random number of sequence steps starting from the end and set them to zero\n\nfor i in range(100):\n    o = TSRandomLookBackOut()(xb, split_idx=0)\n    test_eq(o.shape[-1], xb.shape[-1])\n\n\nsource\n\n\nTSVarOut\n\n TSVarOut (magnitude=0.05, ex=None, **kwargs)\n\nSet the value of a random number of variables to zero\n\ntest_eq(TSVarOut()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSCutOut\n\n TSCutOut (magnitude=0.05, ex=None, **kwargs)\n\nSets a random section of the sequence to zero\n\ntest_eq(TSCutOut()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSTimeStepOut\n\n TSTimeStepOut (magnitude=0.05, ex=None, **kwargs)\n\nSets random sequence steps to zero\n\ntest_eq(TSTimeStepOut()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSRandomCropPad\n\n TSRandomCropPad (magnitude=0.05, ex=None, **kwargs)\n\nCrops a section of the sequence of a random length\n\ntest_eq(TSRandomCropPad()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSMaskOut\n\n TSMaskOut (magnitude=0.1, compensate:bool=False, ex=None, **kwargs)\n\nApplies a random mask\n\ntest_eq(TSMaskOut()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSMaskOut()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSInputDropout\n\n TSInputDropout (magnitude=0.0, ex=None, **kwargs)\n\nApplies input dropout with required_grad=False\n\ntest_eq(TSInputDropout(.1)(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSInputDropout(.1)(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSTranslateX\n\n TSTranslateX (magnitude=0.1, ex=None, **kwargs)\n\nMoves a selected sequence window a random number of steps\n\ntest_eq(TSTranslateX()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSRandomShift\n\n TSRandomShift (magnitude=0.02, ex=None, **kwargs)\n\nShifts and splits a sequence\n\ntest_eq(TSRandomShift()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSHorizontalFlip\n\n TSHorizontalFlip (magnitude=1.0, ex=None, **kwargs)\n\nFlips the sequence along the x-axis\n\ntest_eq(TSHorizontalFlip()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSHorizontalFlip()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSRandomTrend\n\n TSRandomTrend (magnitude=0.1, ex=None, **kwargs)\n\nRandomly rotates the sequence along the z-axis\n\ntest_eq(TSRandomTrend()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSVerticalFlip\n\n TSVerticalFlip (magnitude=1.0, ex=None, **kwargs)\n\nApplies a negative value to the time sequence\n\ntest_eq(TSVerticalFlip()(xb, split_idx=0).shape, xb.shape)\ntest_ne(TSVerticalFlip()(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSResize\n\n TSResize (magnitude=-0.5, size=None, ex=None, mode='nearest', **kwargs)\n\nResizes the sequence length of a time series\n\nif test_interpolate('nearest'):\n    for sz in np.linspace(.2, 2, 10): test_eq(TSResize(sz)(xb, split_idx=0).shape[-1], int(round(xb.shape[-1]*(1+sz))))\n    test_ne(TSResize(1)(xb, split_idx=0), xb)\n\n\nsource\n\n\nTSRandomSize\n\n TSRandomSize (magnitude=0.1, ex=None, mode='nearest', **kwargs)\n\nRandomly resizes the sequence length of a time series\n\nif test_interpolate('nearest'):\n    seq_len_ = []\n    for i in range(100):\n        o = TSRandomSize(.5)(xb, split_idx=0)\n        seq_len_.append(o.shape[-1])\n    test_lt(min(seq_len_), xb.shape[-1])\n    test_gt(max(seq_len_), xb.shape[-1])\n\n\nsource\n\n\nTSRandomLowRes\n\n TSRandomLowRes (magnitude=0.5, ex=None, mode='nearest', **kwargs)\n\nRandomly resizes the sequence length of a time series to a lower resolution\n\nsource\n\n\nTSDownUpScale\n\n TSDownUpScale (magnitude=0.5, ex=None, mode='nearest', **kwargs)\n\nDownscales a time series and upscales it again to previous sequence length\n\nif test_interpolate('nearest'):\n    test_eq(TSDownUpScale()(xb, split_idx=0).shape, xb.shape)\n\n\nsource\n\n\nTSRandomDownUpScale\n\n TSRandomDownUpScale (magnitude=0.5, ex=None, mode='nearest', **kwargs)\n\nRandomly downscales a time series and upscales it again to previous sequence length\n\nif test_interpolate('nearest'):\n    test_eq(TSRandomDownUpScale()(xb, split_idx=0).shape, xb.shape)\n    test_ne(TSDownUpScale()(xb, split_idx=0), xb)\n    test_eq(TSDownUpScale()(xb, split_idx=1), xb)\n\n\nsource\n\n\nTSRandomConv\n\n TSRandomConv (magnitude=0.05, ex=None, ks=[1, 3, 5, 7], **kwargs)\n\nApplies a convolution with a random kernel and random weights with required_grad=False\n\nfor i in range(5):\n    o = TSRandomConv(magnitude=0.05, ex=None, ks=[1, 3, 5, 7])(xb, split_idx=0)\n    test_eq(o.shape, xb.shape)\n\n\nsource\n\n\nTSRandom2Value\n\n TSRandom2Value (magnitude=0.1, sel_vars=None, sel_steps=None,\n                 static=False, value=nan, **kwargs)\n\nRandomly sets selected variables of type TSTensor to predefined value (default: np.nan)\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=0.5, sel_vars=None, sel_steps=None, static=False, value=0)(t, split_idx=0).data\n\ntensor([[[0., 1., 0., 1., 1., 1., 0., 1., 1., 1.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\n         [0., 1., 1., 0., 0., 0., 1., 0., 0., 1.]],\n\n        [[1., 1., 1., 0., 0., 1., 1., 1., 0., 1.],\n         [0., 1., 1., 0., 1., 0., 0., 0., 0., 0.],\n         [1., 1., 0., 1., 0., 0., 1., 0., 0., 1.]]])\n\n\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=0.5, sel_vars=[1], sel_steps=slice(-5, None), static=False, value=0)(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 0., 0., 0., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]],\n\n        [[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 0., 0., 0., 0., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]])\n\n\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=0.5, sel_vars=[1], sel_steps=None, static=True, value=0)(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]],\n\n        [[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]])\n\n\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=1, sel_vars=1, sel_steps=None, static=False, value=0)(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]],\n\n        [[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]])\n\n\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=1, sel_vars=[1,2], sel_steps=None, static=False, value=0)(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]],\n\n        [[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n         [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]])\n\n\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=1, sel_vars=1, sel_steps=[1,3,5], static=False, value=0)(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 0., 1., 0., 1., 0., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]],\n\n        [[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 0., 1., 0., 1., 0., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]])\n\n\n\nt = TSTensor(torch.ones(2, 3, 10))\nTSRandom2Value(magnitude=1, sel_vars=[1,2], sel_steps=[1,3,5], static=False, value=0)(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 0., 1., 0., 1., 0., 1., 1., 1., 1.],\n         [1., 0., 1., 0., 1., 0., 1., 1., 1., 1.]],\n\n        [[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n         [1., 0., 1., 0., 1., 0., 1., 1., 1., 1.],\n         [1., 0., 1., 0., 1., 0., 1., 1., 1., 1.]]])\n\n\n\nt = TSTensor(torch.ones(2,3,4))\nTSRandom2Value(magnitude=.5, sel_vars=[0,2])(t, split_idx=0).data\n\ntensor([[[1., 1., 1., 1.],\n         [1., 1., 1., 1.],\n         [1., 1., 1., nan]],\n\n        [[nan, nan, 1., 1.],\n         [1., 1., 1., 1.],\n         [1., nan, nan, 1.]]])\n\n\n\nt = TSTensor(torch.ones(2,3,4))\nTSRandom2Value(magnitude=.5, sel_steps=slice(2, None))(t, split_idx=0).data\n\ntensor([[[1., 1., nan, 1.],\n         [1., 1., nan, nan],\n         [1., 1., 1., nan]],\n\n        [[1., 1., nan, 1.],\n         [1., 1., 1., 1.],\n         [1., 1., 1., nan]]])\n\n\n\nt = TSTensor(torch.ones(2,3,100))\ntest_gt(np.isnan(TSRandom2Value(magnitude=.5)(t, split_idx=0)).sum().item(), 0)\nt = TSTensor(torch.ones(2,3,100))\ntest_gt(np.isnan(TSRandom2Value(magnitude=.5, sel_vars=[0,2])(t, split_idx=0)[:, [0,2]]).sum().item(), 0)\nt = TSTensor(torch.ones(2,3,100))\ntest_eq(np.isnan(TSRandom2Value(magnitude=.5, sel_vars=[0,2])(t, split_idx=0)[:, 1]).sum().item(), 0)\n\n/var/folders/yw/1vck7tm93_z1z0bftrw65hbw0000gn/T/ipykernel_22669/3870966226.py:2: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n  test_gt(np.isnan(TSRandom2Value(magnitude=.5)(t, split_idx=0)).sum().item(), 0)\n/var/folders/yw/1vck7tm93_z1z0bftrw65hbw0000gn/T/ipykernel_22669/3870966226.py:4: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n  test_gt(np.isnan(TSRandom2Value(magnitude=.5, sel_vars=[0,2])(t, split_idx=0)[:, [0,2]]).sum().item(), 0)\n/var/folders/yw/1vck7tm93_z1z0bftrw65hbw0000gn/T/ipykernel_22669/3870966226.py:6: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n  test_eq(np.isnan(TSRandom2Value(magnitude=.5, sel_vars=[0,2])(t, split_idx=0)[:, 1]).sum().item(), 0)\n\n\n\nsource\n\n\nTSMask2Value\n\n TSMask2Value (mask_fn, value=nan, sel_vars=None, **kwargs)\n\nRandomly sets selected variables of type TSTensor to predefined value (default: np.nan)\n\nt = TSTensor(torch.ones(2,3,100))\ndef _mask_fn(o, r=.15, value=np.nan):\n    return torch.rand_like(o) &gt; (1-r)\ntest_gt(np.isnan(TSMask2Value(_mask_fn)(t, split_idx=0)).sum().item(), 0)\n\n/var/folders/yw/1vck7tm93_z1z0bftrw65hbw0000gn/T/ipykernel_22669/2303918966.py:4: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n  test_gt(np.isnan(TSMask2Value(_mask_fn)(t, split_idx=0)).sum().item(), 0)\n\n\n\nsource\n\n\nTSSelfDropout\n\n TSSelfDropout (p:float=1.0, nm:str=None, before_call:Callable=None,\n                **kwargs)\n\nApplies dropout to a tensor with nan values by rotating axis=0 inplace\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\np\nfloat\n1.0\nProbability of applying Transform\n\n\nnm\nstr\nNone\n\n\n\nbefore_call\nCallable\nNone\nOptional batchwise preprocessing function\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nsource\n\n\nself_mask\n\n self_mask (o)\n\n\nt = TSTensor(torch.ones(2,3,100))\nmask = torch.rand_like(t) &gt; .7\nt[mask] = np.nan\nnan_perc = np.isnan(t).float().mean().item()\nt2 = TSSelfDropout()(t, split_idx=0)\ntest_gt(torch.isnan(t2).float().mean().item(), nan_perc)\nnan_perc, torch.isnan(t2).float().mean().item()\n\n/var/folders/yw/1vck7tm93_z1z0bftrw65hbw0000gn/T/ipykernel_22669/2944010346.py:4: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)\n  nan_perc = np.isnan(t).float().mean().item()\n\n\n(0.3100000023841858, 0.5166666507720947)\n\n\n\nsource\n\n\nRandAugment\n\n RandAugment (tfms:list, N:int=1, M:int=3, **kwargs)\n\nA transform that before_call its state at each __call__\n\ntest_ne(RandAugment(TSMagAddNoise, N=5, M=10)(xb, split_idx=0), xb)\n\n\nsource\n\n\nTestTfm\n\n TestTfm (tfm, magnitude=1.0, ex=None, **kwargs)\n\nUtility class to test the output of selected tfms during training\n\nsource\n\n\nget_tfm_name\n\n get_tfm_name (tfm)\n\n\ntest_eq(get_tfm_name(partial(TSMagScale()))==get_tfm_name((partial(TSMagScale()), 0.1, .05))==get_tfm_name(TSMagScale())==get_tfm_name((TSMagScale(), 0.1, .05)), True)\n\n\nall_TS_randaugs_names = [get_tfm_name(t) for t in all_TS_randaugs]",
    "crumbs": [
      "Data",
      "Time Series Data Augmentation"
    ]
  },
  {
    "objectID": "models.rocket.html",
    "href": "models.rocket.html",
    "title": "ROCKET",
    "section": "",
    "text": "ROCKET (RandOm Convolutional KErnel Transform) functions for univariate and multivariate time series.\n\n\nsource\n\nRocketClassifier\n\n RocketClassifier (num_kernels=10000, normalize_input=True,\n                   random_state=None, alphas=array([1.e-03, 1.e-02,\n                   1.e-01, 1.e+00, 1.e+01, 1.e+02, 1.e+03]),\n                   normalize_features=True, memory=None, verbose=False,\n                   scoring=None, class_weight=None, **kwargs)\n\nTime series classification using ROCKET features and a linear classifier\n\nsource\n\n\nload_rocket\n\n load_rocket (fname='Rocket', path='./models')\n\n\nsource\n\n\nRocketRegressor\n\n RocketRegressor (num_kernels=10000, normalize_input=True,\n                  random_state=None, alphas=array([1.e-03, 1.e-02, 1.e-01,\n                  1.e+00, 1.e+01, 1.e+02, 1.e+03]),\n                  normalize_features=True, memory=None, verbose=False,\n                  scoring=None, **kwargs)\n\nTime series regression using ROCKET features and a linear regressor\n\n# Univariate classification with sklearn-type API\ndsid = 'OliveOil'\nfname = 'RocketClassifier'\nX_train, y_train, X_test, y_test = get_UCR_data(dsid, Xdtype='float64')\ncls = RocketClassifier()\ncls.fit(X_train, y_train)\ncls.save(fname)\ndel cls\ncls = load_rocket(fname)\nprint(cls.score(X_test, y_test))\n\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n\n\n0.9\n\n\n\n# Multivariate classification with sklearn-type API\ndsid = 'NATOPS'\nfname = 'RocketClassifier'\nX_train, y_train, X_test, y_test = get_UCR_data(dsid, Xdtype='float64')\ncls = RocketClassifier()\ncls.fit(X_train, y_train)\ncls.save(fname)\ndel cls\ncls = load_rocket(fname)\nprint(cls.score(X_test, y_test))\n\n0.8666666666666667\n\n\n\nfrom sklearn.metrics import mean_squared_error\n\n\n# Univariate regression with sklearn-type API\ndsid = 'Covid3Month'\nfname = 'RocketRegressor'\nX_train, y_train, X_test, y_test = get_Monash_regression_data(dsid, Xdtype='float64')\nif X_train is not None: \n    rmse_scorer = make_scorer(mean_squared_error, greater_is_better=False)\n    reg = RocketRegressor(scoring=rmse_scorer)\n    reg.fit(X_train, y_train)\n    reg.save(fname)\n    del reg\n    reg = load_rocket(fname)\n    y_pred = reg.predict(X_test)\n    print(mean_squared_error(y_test, y_pred, squared=False))\n\n0.03908714523468997\n\n\n\n# Multivariate regression with sklearn-type API\ndsid = 'AppliancesEnergy'\nfname = 'RocketRegressor'\nX_train, y_train, X_test, y_test = get_Monash_regression_data(dsid, Xdtype='float64')\nif X_train is not None: \n    rmse_scorer = make_scorer(mean_squared_error, greater_is_better=False)\n    reg = RocketRegressor(scoring=rmse_scorer)\n    reg.fit(X_train, y_train)\n    reg.save(fname)\n    del reg\n    reg = load_rocket(fname)\n    y_pred = reg.predict(X_test)\n    print(mean_squared_error(y_test, y_pred, squared=False))\n\n2.287302226812576",
    "crumbs": [
      "Models",
      "ROCKETs",
      "ROCKET"
    ]
  },
  {
    "objectID": "callback.core.html",
    "href": "callback.core.html",
    "title": "Callback",
    "section": "",
    "text": "Miscellaneous callbacks for timeseriesAI.",
    "crumbs": [
      "Training",
      "Callbacks",
      "Callback"
    ]
  },
  {
    "objectID": "callback.core.html#events",
    "href": "callback.core.html#events",
    "title": "Callback",
    "section": "Events",
    "text": "Events\nA callback can implement actions on the following events: * before_fit: called before doing anything, ideal for initial setup. * before_epoch: called at the beginning of each epoch, useful for any behavior you need to reset at each epoch. * before_train: called at the beginning of the training part of an epoch. * before_batch: called at the beginning of each batch, just after drawing said batch. It can be used to do any setup necessary for the batch (like hyper-parameter scheduling) or to change the input/target before it goes in the model (change of the input with techniques like mixup for instance). * after_pred: called after computing the output of the model on the batch. It can be used to change that output before it’s fed to the loss. * after_loss: called after the loss has been computed, but before the backward pass. It can be used to add any penalty to the loss (AR or TAR in RNN training for instance). * before_backward: called after the loss has been computed, but only in training mode (i.e. when the backward pass will be used) * after_backward: called after the backward pass, but before the update of the parameters. It can be used to do any change to the gradients before said update (gradient clipping for instance). * after_step: called after the step and before the gradients are zeroed. * after_batch: called at the end of a batch, for any clean-up before the next one. * after_train: called at the end of the training phase of an epoch. * before_validate: called at the beginning of the validation phase of an epoch, useful for any setup needed specifically for validation. * after_validate: called at the end of the validation part of an epoch. * after_epoch: called at the end of an epoch, for any clean-up before the next one. * after_fit: called at the end of training, for final clean-up.",
    "crumbs": [
      "Training",
      "Callbacks",
      "Callback"
    ]
  },
  {
    "objectID": "callback.core.html#learner-attributes",
    "href": "callback.core.html#learner-attributes",
    "title": "Callback",
    "section": "Learner attributes",
    "text": "Learner attributes\nWhen writing a callback, the following attributes of Learner are available:\n\nmodel: the model used for training/validation\ndata: the underlying DataLoaders\nloss_func: the loss function used\nopt: the optimizer used to udpate the model parameters\nopt_func: the function used to create the optimizer\ncbs: the list containing all Callbacks\ndl: current DataLoader used for iteration\nx/xb: last input drawn from self.dl (potentially modified by callbacks). xb is always a tuple (potentially with one element) and x is detuplified. You can only assign to xb.\ny/yb: last target drawn from self.dl (potentially modified by callbacks). yb is always a tuple (potentially with one element) and y is detuplified. You can only assign to yb.\npred: last predictions from self.model (potentially modified by callbacks)\nloss: last computed loss (potentially modified by callbacks)\nn_epoch: the number of epochs in this training\nn_iter: the number of iterations in the current self.dl\nepoch: the current epoch index (from 0 to n_epoch-1)\niter: the current iteration index in self.dl (from 0 to n_iter-1)\n\nThe following attributes are added by TrainEvalCallback and should be available unless you went out of your way to remove that callback: * train_iter: the number of training iterations done since the beginning of this training * pct_train: from 0. to 1., the percentage of training iterations completed * training: flag to indicate if we’re in training mode or not\nThe following attribute is added by Recorder and should be available unless you went out of your way to remove that callback: * smooth_loss: an exponentially-averaged version of the training loss",
    "crumbs": [
      "Training",
      "Callbacks",
      "Callback"
    ]
  },
  {
    "objectID": "callback.core.html#transform-scheduler",
    "href": "callback.core.html#transform-scheduler",
    "title": "Callback",
    "section": "Transform scheduler",
    "text": "Transform scheduler\n\nsource\n\nTransformScheduler\n\n TransformScheduler (schedule_func:&lt;built-infunctioncallable&gt;,\n                     show_plot:bool=False)\n\nA callback to schedule batch transforms during training based on a function (sched_lin, sched_exp, sched_cos (default), etc)\n\nTransformScheduler(SchedCos(1, 0))\n\nTransformScheduler(&lt;fastai.callback.schedule._Annealer object&gt;)\n\n\n\np = torch.linspace(0.,1,100)\nf = combine_scheds([0.3, 0.4, 0.3], [SchedLin(1.,1.), SchedCos(1.,0.), SchedLin(0.,.0), ])\nplt.plot(p, [f(o) for o in p]);\n\n\n\n\n\n\n\n\n\np = torch.linspace(0.,1,100)\nf = combine_scheds([0.3, 0.7], [SchedCos(0.,1.), SchedCos(1.,0.)])\nplt.plot(p, [f(o) for o in p]);",
    "crumbs": [
      "Training",
      "Callbacks",
      "Callback"
    ]
  },
  {
    "objectID": "callback.core.html#showgraph",
    "href": "callback.core.html#showgraph",
    "title": "Callback",
    "section": "ShowGraph",
    "text": "ShowGraph\n\nsource\n\nShowGraph\n\n ShowGraph (plot_metrics:bool=True, final_losses:bool=True,\n            perc:float=0.5)\n\n(Modified) Update a graph of training and validation loss",
    "crumbs": [
      "Training",
      "Callbacks",
      "Callback"
    ]
  },
  {
    "objectID": "callback.core.html#savemodel",
    "href": "callback.core.html#savemodel",
    "title": "Callback",
    "section": "SaveModel",
    "text": "SaveModel\n\nsource\n\nSaveModel\n\n SaveModel (monitor='valid_loss', comp=None, min_delta=0.0, fname='model',\n            every_epoch=False, at_end=False, with_opt=False,\n            reset_on_fit=True, verbose=False)\n\nA TrackerCallback that saves the model’s best during training and loads it at the end with a verbose option.",
    "crumbs": [
      "Training",
      "Callbacks",
      "Callback"
    ]
  },
  {
    "objectID": "optimizer.html",
    "href": "optimizer.html",
    "title": "Optimizers",
    "section": "",
    "text": "This contains a set of optimizers.\n\n\nsource\n\nwrap_optimizer\n\n wrap_optimizer (opt, **kwargs)\n\nYou can natively use any of the optimizers included in the fastai library. You just need to pass it to the learner as the opt_func.\nIn addition, you will be able to use any of the optimizers from:\n\nPytorch\ntorch_optimizer (https://github.com/jettify/pytorch-optimizer). In this case, you will need to install torch-optimizer first)\n\nExamples of use:\nadamw = wrap_optimizer(torch.optim.AdamW)\nimport torch_optimizer as optim\nadabelief = wrap_optimizer(optim.AdaBelief)\nIf you want to use any these last 2, you can use the wrap_optimizer function. Here are a few examples:",
    "crumbs": [
      "Training",
      "Optimizers"
    ]
  },
  {
    "objectID": "callback.noisy_student.html",
    "href": "callback.noisy_student.html",
    "title": "Noisy student",
    "section": "",
    "text": "Callback to apply noisy student self-training (a semi-supervised learning approach) based on:\nXie, Q., Luong, M. T., Hovy, E., & Le, Q. V. (2020). Self-training with noisy student improves imagenet classification. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 10687-10698).\n\nsource\n\nNoisyStudent\n\n NoisyStudent (dl2:fastai.data.load.DataLoader, bs:Optional[int]=None,\n               l2pl_ratio:int=1, batch_tfms:Optional[list]=None,\n               do_setup:bool=True, pseudolabel_sample_weight:float=1.0,\n               verbose=False)\n\n*A callback to implement the Noisy Student approach. In the original paper this was used in combination with noise: - stochastic depth: .8 - RandAugment: N=2, M=27 - dropout: .5\nSteps: 1. Build the dl you will use as a teacher 2. Create dl2 with the pseudolabels (either soft or hard preds) 3. Pass any required batch_tfms to the callback*\n\nfrom tsai.data.all import *\nfrom tsai.models.all import *\nfrom tsai.tslearner import *\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\nX = X.astype(np.float32)\n\n\npseudolabeled_data = X\nsoft_preds = True\n\npseudolabels = ToNumpyCategory()(y) if soft_preds else OneHot()(y)\ndsets2 = TSDatasets(pseudolabeled_data, pseudolabels)\ndl2 = TSDataLoader(dsets2, num_workers=0)\nnoisy_student_cb = NoisyStudent(dl2, bs=256, l2pl_ratio=2, verbose=True)\ntfms = [None, TSClassification]\nlearn = TSClassifier(X, y, splits=splits, tfms=tfms, batch_tfms=[TSStandardize(), TSRandomSize(.5)], cbs=noisy_student_cb)\nlearn.fit_one_cycle(1)\n\nlabels / pseudolabels per training batch              : 171 / 85\nrelative labeled/ pseudolabel sample weight in dataset: 4.0\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.782144\n1.758471\n0.250000\n00:00\n\n\n\n\n\n\nX: torch.Size([171, 24, 51])  X2: torch.Size([85, 24, 51])  X_comb: torch.Size([256, 24, 41])\ny: torch.Size([171])  y2: torch.Size([85])  y_comb: torch.Size([256])\n\n\n\npseudolabeled_data = X\nsoft_preds = False\n\npseudolabels = ToNumpyCategory()(y) if soft_preds else OneHot()(y)\npseudolabels = pseudolabels.astype(np.float32)\ndsets2 = TSDatasets(pseudolabeled_data, pseudolabels)\ndl2 = TSDataLoader(dsets2, num_workers=0)\nnoisy_student_cb = NoisyStudent(dl2, bs=256, l2pl_ratio=2, verbose=True)\ntfms = [None, TSClassification]\nlearn = TSClassifier(X, y, splits=splits, tfms=tfms, batch_tfms=[TSStandardize(), TSRandomSize(.5)], cbs=noisy_student_cb)\nlearn.fit_one_cycle(1)\n\nlabels / pseudolabels per training batch              : 171 / 85\nrelative labeled/ pseudolabel sample weight in dataset: 4.0\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.898401\n1.841182\n0.155556\n00:00\n\n\n\n\n\n\nX: torch.Size([171, 24, 51])  X2: torch.Size([85, 24, 51])  X_comb: torch.Size([256, 24, 51])\ny: torch.Size([171, 6])  y2: torch.Size([85, 6])  y_comb: torch.Size([256, 6])",
    "crumbs": [
      "Training",
      "Callbacks",
      "Noisy student"
    ]
  },
  {
    "objectID": "models.tssequencerplus.html",
    "href": "models.tssequencerplus.html",
    "title": "TSSequencerPlus",
    "section": "",
    "text": "This is a PyTorch implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on Sequencer: Deep LSTM for Image Classification\nsource",
    "crumbs": [
      "Models",
      "RNNs",
      "TSSequencerPlus"
    ]
  },
  {
    "objectID": "models.tssequencerplus.html#feature-extractor",
    "href": "models.tssequencerplus.html#feature-extractor",
    "title": "TSSequencerPlus",
    "section": "Feature extractor",
    "text": "Feature extractor\nIt’s a known fact that transformers cannot be directly applied to long sequences. To avoid this, we have included a way to subsample the sequence to generate a more manageable input.\n\nfrom tsai.data.validation import get_splits\nfrom tsai.data.core import get_ts_dls\n\n\nX = np.zeros((10, 3, 5000))\ny = np.random.randint(0,2,X.shape[0])\nsplits = get_splits(y)\ndls = get_ts_dls(X, y, splits=splits)\nxb, yb = dls.train.one_batch()\nxb\n\n\n\n\n\n\n\n\nTSTensor(samples:8, vars:3, len:5000, device=mps:0, dtype=torch.float32)\n\n\nIf you try to use SequencerPlus, it’s likely you’ll get an ‘out-of-memory’ error.\nTo avoid this you can subsample the sequence reducing the input’s length. This can be done in multiple ways. Here are a few examples:\n\n# Separable convolution (to avoid mixing channels)\nfeature_extractor = Conv1d(xb.shape[1], xb.shape[1], ks=100, stride=50, padding=0, groups=xb.shape[1]).to(default_device())\nfeature_extractor.to(xb.device)(xb).shape\n\ntorch.Size([8, 3, 99])\n\n\n\n# Convolution (if you want to mix channels or change number of channels)\nfeature_extractor=MultiConv1d(xb.shape[1], 64, kss=[1,3,5,7,9], keep_original=True).to(default_device())\ntest_eq(feature_extractor.to(xb.device)(xb).shape, (xb.shape[0], 64, xb.shape[-1]))\n\n\n# MaxPool\nfeature_extractor = nn.Sequential(Pad1d((0, 50), 0), nn.MaxPool1d(kernel_size=100, stride=50)).to(default_device())\nfeature_extractor.to(xb.device)(xb).shape\n\ntorch.Size([8, 3, 100])\n\n\n\n# AvgPool\nfeature_extractor = nn.Sequential(Pad1d((0, 50), 0), nn.AvgPool1d(kernel_size=100, stride=50)).to(default_device())\nfeature_extractor.to(xb.device)(xb).shape\n\ntorch.Size([8, 3, 100])\n\n\nOnce you decide what type of transform you want to apply, you just need to pass the layer as the feature_extractor attribute:\n\nbs = 16\nnvars = 4\nseq_len = 1000\nc_out = 2\nd_model = 128\n\nxb = torch.rand(bs, nvars, seq_len)\nfeature_extractor = partial(Conv1d, ks=5, stride=3, padding=0, groups=xb.shape[1])\nmodel = TSSequencerPlus(nvars, c_out, seq_len, d_model=d_model, feature_extractor=feature_extractor)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))",
    "crumbs": [
      "Models",
      "RNNs",
      "TSSequencerPlus"
    ]
  },
  {
    "objectID": "models.tssequencerplus.html#categorical-variables",
    "href": "models.tssequencerplus.html#categorical-variables",
    "title": "TSSequencerPlus",
    "section": "Categorical variables",
    "text": "Categorical variables\n\nfrom tsai.utils import alphabet, ALPHABET\n\n\na = alphabet[np.random.randint(0,3,40)]\nb = ALPHABET[np.random.randint(6,10,40)]\nc = np.random.rand(40).reshape(4,1,10)\nmap_a = {k:v for v,k in enumerate(np.unique(a))}\nmap_b = {k:v for v,k in enumerate(np.unique(b))}\nn_cat_embeds = [len(m.keys()) for m in [map_a, map_b]]\nszs = [emb_sz_rule(n) for n in n_cat_embeds]\na = np.asarray(a.map(map_a)).reshape(4,1,10)\nb = np.asarray(b.map(map_b)).reshape(4,1,10)\ninp = torch.from_numpy(np.concatenate((c,a,b), 1)).float()\nfeature_extractor = partial(Conv1d, ks=3, padding='same')\nmodel = TSSequencerPlus(3, 2, 10, d_model=64, cat_pos=[1,2], feature_extractor=feature_extractor)\ntest_eq(model(inp).shape, (4,2))",
    "crumbs": [
      "Models",
      "RNNs",
      "TSSequencerPlus"
    ]
  },
  {
    "objectID": "models.tssequencerplus.html#sequence-embedding",
    "href": "models.tssequencerplus.html#sequence-embedding",
    "title": "TSSequencerPlus",
    "section": "Sequence Embedding",
    "text": "Sequence Embedding\nSometimes you have a samples with a very long sequence length. In those cases you may want to reduce it’s length before passing it to the transformer. To do that you may just pass a token_size like in this example:\n\nt = torch.rand(8, 2, 10080)\nSeqTokenizer(2, 128, 60)(t).shape\n\ntorch.Size([8, 128, 168])\n\n\n\nt = torch.rand(8, 2, 10080)\nmodel = TSSequencerPlus(2, 5, 10080, d_model=64, token_size=60)\nmodel(t).shape\n\ntorch.Size([8, 5])",
    "crumbs": [
      "Models",
      "RNNs",
      "TSSequencerPlus"
    ]
  },
  {
    "objectID": "models.tabmodel.html",
    "href": "models.tabmodel.html",
    "title": "TabModel",
    "section": "",
    "text": "This is an implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on fastai’s TabularModel.\nWe built it so that it’s easy to change the head of the model, something that is particularly interesting when building hybrid models.\n\nsource\n\nTabHead\n\n TabHead (emb_szs, n_cont, c_out, layers=None, fc_dropout=None,\n          y_range=None, use_bn=True, bn_final=False, lin_first=False,\n          act=ReLU(inplace=True), skip=False)\n\nBasic head for tabular data.\n\nsource\n\n\nTabBackbone\n\n TabBackbone (emb_szs, n_cont, embed_p=0.0, bn_cont=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nTabModel\n\n TabModel (emb_szs, n_cont, c_out, layers=None, fc_dropout=None,\n           embed_p=0.0, y_range=None, use_bn=True, bn_final=False,\n           bn_cont=True, lin_first=False, act=ReLU(inplace=True),\n           skip=False)\n\nBasic model for tabular data.\n\nfrom fastai.tabular.core import *\nfrom tsai.data.tabular import *\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\n# df['salary'] = np.random.rand(len(df)) # uncomment to simulate a cont dependent variable\nprocs = [Categorify, FillMissing, Normalize]\ncat_names = ['workclass', 'education', 'marital-status', 'occupation', 'relationship', 'race']\ncont_names = ['age', 'fnlwgt', 'education-num']\ny_names = ['salary']\ny_block = RegressionBlock() if isinstance(df['salary'].values[0], float) else CategoryBlock()\nsplits = RandomSplitter()(range_of(df))\npd.options.mode.chained_assignment=None\nto = TabularPandas(df, procs=procs, cat_names=cat_names, cont_names=cont_names, y_names=y_names, y_block=y_block, splits=splits, inplace=True, \n                   reduce_memory=False)\nto.show(5)\ntab_dls = to.dataloaders(bs=16, val_bs=32)\nb = first(tab_dls.train)\ntest_eq((b[0].shape, b[1].shape, b[2].shape), (torch.Size([16, 7]), torch.Size([16, 3]), torch.Size([16, 1])))\n\n\n\n\n\nworkclass\neducation\nmarital-status\noccupation\nrelationship\nrace\neducation-num_na\nage\nfnlwgt\neducation-num\nsalary\n\n\n\n\n20505\nPrivate\nHS-grad\nMarried-civ-spouse\nSales\nHusband\nWhite\nFalse\n47.0\n197836.0\n9.0\n&lt;50k\n\n\n28679\nPrivate\nHS-grad\nMarried-civ-spouse\nCraft-repair\nHusband\nWhite\nFalse\n28.0\n65078.0\n9.0\n&gt;=50k\n\n\n11669\nPrivate\nHS-grad\nNever-married\nAdm-clerical\nNot-in-family\nWhite\nFalse\n38.0\n202683.0\n9.0\n&lt;50k\n\n\n29079\nSelf-emp-not-inc\nBachelors\nMarried-civ-spouse\nProf-specialty\nHusband\nWhite\nFalse\n41.0\n168098.0\n13.0\n&lt;50k\n\n\n7061\nPrivate\nHS-grad\nMarried-civ-spouse\nAdm-clerical\nHusband\nWhite\nFalse\n31.0\n243442.0\n9.0\n&lt;50k\n\n\n\n\n\n\ntab_model = build_tabular_model(TabModel, dls=tab_dls)\nb = first(tab_dls.train)\ntest_eq(tab_model.to(b[0].device)(*b[:-1]).shape, (tab_dls.bs, tab_dls.c))\nlearn = Learner(tab_dls, tab_model, splitter=ts_splitter)\np1 = count_parameters(learn.model)\nlearn.freeze()\np2 = count_parameters(learn.model)\nlearn.unfreeze()\np3 = count_parameters(learn.model)\nassert p1 == p3\nassert p1 &gt; p2 &gt; 0",
    "crumbs": [
      "Models",
      "Tabular models",
      "TabModel"
    ]
  },
  {
    "objectID": "export.html",
    "href": "export.html",
    "title": "nb2py",
    "section": "",
    "text": "nb2py will allow you to convert the notebook (.ipynb) where the function is executed to a python script.\n\nThe conversion applies these rules:\n\nThe notebook will be automatically saved when the function is executed.\nOnly code cells will be converted (not markdown cells).\nA header will be added to indicate the script has been automatically generated. It also indicates where the original ipynb is.\nCells with a #hide flag won’t be converted. Flag variants like # hide, #Hide, #HIDE, … are also acceptable.\nEmpty cells and unnecessary empty lines within cells will be removed.\nBy default the script will be created with the same name and in the same folder of the original notebook. But you can pass a dir folder and a different name if you wish.\nIf a script with the same name already exists, it will be overwriten.\n\nThis code is required to identify flags in the notebook. We are looking for #hide flags.\nThis code automatically gets the name of the notebook. It’s been tested to work on Jupyter notebooks, Jupyter Lab and Google Colab.\n\nsource\n\nget_script_path\n\n get_script_path (nb_name=None)\n\n\nsource\n\n\nnb_name_to_py\n\n nb_name_to_py (nb_name)\n\n\nsource\n\n\nget_nb_path\n\n get_nb_path ()\n\nReturns the absolute path of the notebook, or raises a FileNotFoundError exception if it cannot be determined.\n\nsource\n\n\nget_colab_nb_name\n\n get_colab_nb_name ()\n\n\nsource\n\n\nget_nb_name\n\n get_nb_name (d=None)\n\nReturns the short name of the notebook w/o the .ipynb extension, or raises a FileNotFoundError exception if it cannot be determined.\nThis code is used when trying to save a file to google drive. We first need to mount the drive.\n\nsource\n\n\nnb2py\n\n nb2py (nb:str&lt;absoluteorrelativefullpathtothenotebookyouwanttoconverttoap\n        ythonscript&gt;=None, folder:str&lt;absoluteorrelativepathtofolderofthes\n        criptyouwillcreate.Defaultstocurrentnb'sdirectory&gt;=None, name:str&lt;\n        nameofthescriptyouwanttocreate.Defaultstocurrentnbname.ipynbby.py&gt;\n        =None, save:&lt;savesthenbbeforeconvertingittoascript&gt;=True,\n        run:&lt;importandrunthescript&gt;=False,\n        verbose:&lt;controlsverbosity&gt;=True)\n\nConverts a notebook to a python script in a predefined folder.\n\nif not is_colab():\n    nb = None\n    folder = None\n    name = None\n    pyname = nb2py(nb=nb, folder=folder, name=name)\n    if pyname is not None: \n        assert os.path.isfile(pyname)\n        os.remove(pyname)\n        assert not os.path.isfile(pyname)\n\n    nb = '001_export.ipynb'\n    folder = None\n    name = None\n    pyname = nb2py(nb=nb, folder=folder, name=name)\n    if pyname is not None: \n        assert os.path.isfile(pyname)\n        os.remove(pyname)\n        assert not os.path.isfile(pyname)\n\n    nb = '../nbs/001_export'\n    folder = None\n    name = None\n    pyname = nb2py(nb=nb, folder=folder, name=name)\n    if pyname is not None: \n        assert os.path.isfile(pyname)\n        os.remove(pyname)\n        assert not os.path.isfile(pyname)\n\n    nb = None\n    folder = '../test_export/'\n    name = None\n    pyname = nb2py(nb=nb, folder=folder, name=name)\n    if pyname is not None: \n        assert os.path.isfile(pyname)\n        shutil.rmtree(folder)\n        assert not os.path.isfile(pyname)\n\nnb2py couldn't get the nb name. Pass it as an nb argument and rerun nb2py.\n001_export.ipynb converted to /Users/nacho/notebooks/tsai/nbs/001_export.py\n001_export.ipynb converted to /Users/nacho/notebooks/tsai/nbs/../nbs/001_export.py\nnb2py couldn't get the nb name. Pass it as an nb argument and rerun nb2py."
  },
  {
    "objectID": "data.metadatasets.html",
    "href": "data.metadatasets.html",
    "title": "Metadataset",
    "section": "",
    "text": "A dataset of datasets\n\nThis functionality will allow you to create a dataset from data stores in multiple, smaller datasets.\nI’d like to thank both Thomas Capelle (https://github.com/tcapelle) and Xander Dunn (https://github.com/xanderdunn) for their contributions to make this code possible.\nThis functionality allows you to use multiple numpy arrays instead of a single one, which may be very useful in many practical settings. It’s been tested it with 10k+ datasets and it works well.\n\nsource\n\nTSMetaDatasets\n\n TSMetaDatasets (metadataset, splits)\n\nBase class for lists with subsets\n\nsource\n\n\nTSMetaDataset\n\n TSMetaDataset (dataset_list, **kwargs)\n\nInitialize self. See help(type(self)) for accurate signature.\nLet’s create 3 datasets. In this case they will have different sizes.\n\nvocab = alphabet[:10]\ndsets = []\nfor i in range(3):\n    size = np.random.randint(50, 150)\n    X = torch.rand(size, 5, 50)\n    y = vocab[torch.randint(0, 10, (size,))]\n    tfms = [None, TSClassification(vocab=vocab)]\n    dset = TSDatasets(X, y, tfms=tfms)\n    dsets.append(dset)\n\n\n\nmetadataset = TSMetaDataset(dsets)\nsplits = TimeSplitter(show_plot=False)(metadataset)\nmetadatasets = TSMetaDatasets(metadataset, splits=splits)\ndls = TSDataLoaders.from_dsets(metadatasets.train, metadatasets.valid)\nxb, yb = dls.train.one_batch()\nxb, yb\n\n(TSTensor(samples:64, vars:5, len:50, device=cpu, dtype=torch.float32),\n TensorCategory([1, 0, 3, 9, 7, 2, 8, 6, 1, 1, 1, 8, 1, 1, 9, 2, 6, 6, 1, 5, 5,\n                 6, 9, 2, 7, 1, 6, 4, 9, 2, 5, 0, 4, 9, 1, 4, 4, 6, 0, 8, 8, 5,\n                 8, 6, 9, 0, 8, 8, 6, 4, 8, 9, 7, 3, 4, 7, 7, 8, 6, 2, 3, 0, 7,\n                 4]))\n\n\nYou can train metadatasets as you would train any other time series model in tsai:\nlearn = ts_learner(dls, arch=\"TSTPlus\")\nlearn.fit_one_cycle(1)\nlearn.export(\"test.pkl\")\nFor inference, you should create the new metadatasets using the same method you used when you trained it. The you use fastai’s learn.get_preds method to generate predictions:\nvocab = alphabet[:10]\ndsets = []\nfor i in range(3):\n    size = np.random.randint(50, 150)\n    X = torch.rand(size, 5, 50)\n    y = vocab[torch.randint(0, 10, (size,))]\n    tfms = [None, TSClassification(vocab=vocab)]\n    dset = TSDatasets(X, y, tfms=tfms)\n    dsets.append(dset)\nmetadataset = TSMetaDataset(dsets)\ndl = TSDataLoader(metadataset)\n\n\nlearn = load_learner(\"test.pkl\")\nlearn.get_preds(dl=dl)\nThere also en easy way to map any particular sample in a batch to the original dataset and id:\n\ndls = TSDataLoaders.from_dsets(metadatasets.train, metadatasets.valid)\nxb, yb = first(dls.train)\nmappings = dls.train.dataset.mapping_idxs\nfor i, (xbi, ybi) in enumerate(zip(xb, yb)):\n    ds, idx = mappings[i]\n    test_close(dsets[ds][idx][0].data.cpu(), xbi.cpu())\n    test_close(dsets[ds][idx][1].data.cpu(), ybi.cpu())\n\nFor example the 3rd sample in this batch would be:\n\ndls.train.dataset.mapping_idxs[2]\n\narray([  0, 112], dtype=int32)",
    "crumbs": [
      "Data",
      "Metadataset"
    ]
  },
  {
    "objectID": "calibration.html",
    "href": "calibration.html",
    "title": "Calibration",
    "section": "",
    "text": "Functionality to calibrate a trained, binary classification model using temperature scaling.\n\n\nsource\n\nECELoss\n\n ECELoss (n_bins=10)\n\nCalculates the Expected Calibration Error of a model.\n\nsource\n\n\nTemperatureSetter\n\n TemperatureSetter (model, lr=0.01, max_iter=1000, line_search_fn=None,\n                    n_bins=10, verbose=True)\n\nCalibrates a binary classification model optimizing temperature\n\nsource\n\n\nModelWithTemperature\n\n ModelWithTemperature (model)\n\nA decorator which wraps a model with temperature scaling\n\nsource\n\n\nplot_calibration_curve\n\n plot_calibration_curve (labels, logits, cal_logits=None, figsize=(6, 6),\n                         n_bins=10, strategy='uniform')\n\n\nsource\n\n\nLearner.calibrate_model\n\n Learner.calibrate_model (X=None, y=None, lr=0.01, max_iter=10000,\n                          line_search_fn=None, n_bins=10,\n                          strategy='uniform', show_plot=True, figsize=(6,\n                          6), verbose=True)\n\n\nfrom tsai.basics import *\n\n\nX, y, splits = get_UCR_data('FingerMovements', split_data=False)\ntfms  = [None, TSClassification()]\nbatch_tfms = TSRobustScale()\n# dls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nlearn = TSClassifier(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms,\n                     arch='FCNPlus', metrics=accuracy)\nlearn.fit_one_cycle(2)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.794469\n0.731429\n0.500000\n00:00\n\n\n1\n0.758404\n0.716087\n0.490000\n00:00\n\n\n\n\n\n\nlearn.calibrate_model()\ncalibrated_model = learn.calibrated_model\n\nBefore temperature - NLL: 0.716, ECE: 0.093\nCalibrating the model...\n...model calibrated\nOptimal temperature: 272.026\nAfter temperature  - NLL: 0.693, ECE: 0.010",
    "crumbs": [
      "Training",
      "Calibration"
    ]
  },
  {
    "objectID": "wandb.html",
    "href": "wandb.html",
    "title": "Weights & Biases Sweeps",
    "section": "",
    "text": "Weights & Biases Sweeps are used to automate hyperparameter optimization and explore the space of possible models.\n\n\nsource\n\nwandb_agent\n\n wandb_agent (script_path, sweep, entity=None, project=None, count=None,\n              run=True)\n\nRun wandb agent with sweep and `script_path\n\nsource\n\n\nupdate_run_config\n\n update_run_config (config, new_config, verbose=False)\n\nUpdate config with new_config\n\nsource\n\n\nget_sweep_config\n\n get_sweep_config (config)\n\nGet sweep config from config",
    "crumbs": [
      "HPO & experiment tracking",
      "Weights & Biases Sweeps"
    ]
  },
  {
    "objectID": "models.hydraplus.html",
    "href": "models.hydraplus.html",
    "title": "HydraPlus",
    "section": "",
    "text": "Hydra: competing convolutional kernels for fast and accurate time series classification.\n\nThis is a Pytorch implementation of Hydra adapted by Ignacio Oguiza and based on:\nDempster, A., Schmidt, D. F., & Webb, G. I. (2023). Hydra: Competing convolutional kernels for fast and accurate time series classification. Data Mining and Knowledge Discovery, 1-27.\nOriginal paper: https://link.springer.com/article/10.1007/s10618-023-00939-3\nOriginal repository: https://github.com/angus924/hydra\n\nsource\n\nHydraBackbonePlus\n\n HydraBackbonePlus (c_in, c_out, seq_len, k=8, g=64, max_c_in=8,\n                    clip=True, device=device(type='cpu'), zero_init=True)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nHydraPlus\n\n HydraPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None, k:int=8,\n            g:int=64, max_c_in:int=8, clip:bool=True, use_bn:bool=True,\n            fc_dropout:float=0.0, custom_head:Any=None,\n            zero_init:bool=True, use_diff:bool=True,\n            device:str=device(type='cpu'))\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nnum of channels in input\n\n\nc_out\nint\n\nnum of channels in output\n\n\nseq_len\nint\n\nsequence length\n\n\nd\ntuple\nNone\nshape of the output (when ndim &gt; 1)\n\n\nk\nint\n8\nnumber of kernels per group\n\n\ng\nint\n64\nnumber of groups\n\n\nmax_c_in\nint\n8\nmax number of channels per group\n\n\nclip\nbool\nTrue\nclip values &gt;= 0\n\n\nuse_bn\nbool\nTrue\nuse batch norm\n\n\nfc_dropout\nfloat\n0.0\ndropout probability\n\n\ncustom_head\nAny\nNone\noptional custom head as a torch.nn.Module or Callable\n\n\nzero_init\nbool\nTrue\nset head weights and biases to zero\n\n\nuse_diff\nbool\nTrue\nuse diff(X) as input\n\n\ndevice\nstr\ncpu\ndevice to use\n\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 20)).to(default_device())\n\nmodel = HydraPlus(5, 3, 20, d=None).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 3)\noutput.shape\n\ntorch.Size([16, 3])\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 20)).to(default_device())\n\nmodel = HydraPlus(5, 3, 20, d=None, use_diff=False).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 3)\noutput.shape\n\ntorch.Size([16, 3])\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 5, 20)).to(default_device())\n\nmodel = HydraPlus(5, 3, 20, d=20, use_diff=True).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 20, 3)\noutput.shape\n\ntorch.Size([16, 20, 3])",
    "crumbs": [
      "Models",
      "ROCKETs",
      "HydraPlus"
    ]
  },
  {
    "objectID": "models.layers.html",
    "href": "models.layers.html",
    "title": "Layers",
    "section": "",
    "text": "Helper functions used to build PyTorch timeseries models.\n\n\nsource\n\ntest_module_to_torchscript\n\n test_module_to_torchscript (m:torch.nn.modules.module.Module,\n                             inputs:torch.Tensor, trace:bool=True,\n                             script:bool=True, serialize:bool=True,\n                             verbose:bool=True)\n\nTests if a PyTorch module can be correctly traced or scripted and serialized\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nm\nModule\n\nThe PyTorch module to be tested.\n\n\ninputs\nTensor\n\nA tensor or tuple of tensors representing the inputs to the model.\n\n\ntrace\nbool\nTrue\nIf True, attempts to trace the model. Defaults to True.\n\n\nscript\nbool\nTrue\nIf True, attempts to script the model. Defaults to True.\n\n\nserialize\nbool\nTrue\nIf True, saves and loads the traced/scripted module to ensure it can be serialized. Defaults to True.\n\n\nverbose\nbool\nTrue\nIf True, prints detailed information about the tracing and scripting process. Defaults to True.\n\n\n\n\nm = nn.Linear(10, 2)\ninp = torch.randn(3, 10)\ntest_module_to_torchscript(m, inp, trace=True, script=True, serialize=True, verbose=True)\n\noutput.shape: torch.Size([3, 2])\nTracing...\n...Linear has been successfully traced 😃\n\n\n\nTrue\n\n\n\nsource\n\n\ninit_lin_zero\n\n init_lin_zero (m)\n\n\nsource\n\n\nSwishBeta\n\n SwishBeta ()\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nSmeLU\n\n SmeLU (beta:float=2.0)\n\nSmooth ReLU activation function based on https://arxiv.org/pdf/2202.06499.pdf\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nbeta\nfloat\n2.0\nBeta value\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nChomp1d\n\n Chomp1d (chomp_size)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nSameConv1d\n\n SameConv1d (ni, nf, ks=3, stride=1, dilation=1, **kwargs)\n\nConv1d with padding=‘same’\n\nsource\n\n\nPad1d\n\n Pad1d (padding, value=0.0)\n\n*Pads the input tensor boundaries with a constant value.\nFor N-dimensional padding, use :func:torch.nn.functional.pad().\nArgs: padding (int, tuple): the size of the padding. If is int, uses the same padding in both boundaries. If a 2-tuple, uses (:math:\\text{padding\\_left}, :math:\\text{padding\\_right})\nShape: - Input: :math:(C, W_{in}) or :math:(N, C, W_{in}). - Output: :math:(C, W_{out}) or :math:(N, C, W_{out}), where\n  :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\nExamples::\n&gt;&gt;&gt; # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n&gt;&gt;&gt; m = nn.ConstantPad1d(2, 3.5)\n&gt;&gt;&gt; input = torch.randn(1, 2, 4)\n&gt;&gt;&gt; input\ntensor([[[-1.0491, -0.7152, -0.0749,  0.8530],\n         [-1.3287,  1.8966,  0.1466, -0.2771]]])\n&gt;&gt;&gt; m(input)\ntensor([[[ 3.5000,  3.5000, -1.0491, -0.7152, -0.0749,  0.8530,  3.5000,\n           3.5000],\n         [ 3.5000,  3.5000, -1.3287,  1.8966,  0.1466, -0.2771,  3.5000,\n           3.5000]]])\n&gt;&gt;&gt; m = nn.ConstantPad1d(2, 3.5)\n&gt;&gt;&gt; input = torch.randn(1, 2, 3)\n&gt;&gt;&gt; input\ntensor([[[ 1.6616,  1.4523, -1.1255],\n         [-3.6372,  0.1182, -1.8652]]])\n&gt;&gt;&gt; m(input)\ntensor([[[ 3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000,  3.5000],\n         [ 3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000,  3.5000]]])\n&gt;&gt;&gt; # using different paddings for different sides\n&gt;&gt;&gt; m = nn.ConstantPad1d((3, 1), 3.5)\n&gt;&gt;&gt; m(input)\ntensor([[[ 3.5000,  3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000],\n         [ 3.5000,  3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000]]])*\n\nsource\n\n\nsame_padding1d\n\n same_padding1d (seq_len, ks, stride=1, dilation=1)\n\nSame padding formula as used in Tensorflow\n\nsource\n\n\nConv2d\n\n Conv2d (ni, nf, kernel_size=None, ks=None, stride=1, padding='same',\n         dilation=1, init='auto', bias_std=0.01, **kwargs)\n\nconv1d layer with padding=‘same’, ‘valid’, or any integer (defaults to ‘same’)\n\nsource\n\n\nConv2dSame\n\n Conv2dSame (ni, nf, ks=(3, 3), stride=(1, 1), dilation=(1, 1), **kwargs)\n\nConv2d with padding=‘same’\n\nsource\n\n\nPad2d\n\n Pad2d (padding, value=0.0)\n\n*Pads the input tensor boundaries with a constant value.\nFor N-dimensional padding, use :func:torch.nn.functional.pad().\nArgs: padding (int, tuple): the size of the padding. If is int, uses the same padding in all boundaries. If a 4-tuple, uses (:math:\\text{padding\\_left}, :math:\\text{padding\\_right}, :math:\\text{padding\\_top}, :math:\\text{padding\\_bottom})\nShape: - Input: :math:(N, C, H_{in}, W_{in}) or :math:(C, H_{in}, W_{in}). - Output: :math:(N, C, H_{out}, W_{out}) or :math:(C, H_{out}, W_{out}), where\n  :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n  :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\nExamples::\n&gt;&gt;&gt; # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n&gt;&gt;&gt; m = nn.ConstantPad2d(2, 3.5)\n&gt;&gt;&gt; input = torch.randn(1, 2, 2)\n&gt;&gt;&gt; input\ntensor([[[ 1.6585,  0.4320],\n         [-0.8701, -0.4649]]])\n&gt;&gt;&gt; m(input)\ntensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n         [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n         [ 3.5000,  3.5000,  1.6585,  0.4320,  3.5000,  3.5000],\n         [ 3.5000,  3.5000, -0.8701, -0.4649,  3.5000,  3.5000],\n         [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n         [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])\n&gt;&gt;&gt; # using different paddings for different sides\n&gt;&gt;&gt; m = nn.ConstantPad2d((3, 0, 2, 1), 3.5)\n&gt;&gt;&gt; m(input)\ntensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n         [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n         [ 3.5000,  3.5000,  3.5000,  1.6585,  0.4320],\n         [ 3.5000,  3.5000,  3.5000, -0.8701, -0.4649],\n         [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])*\n\nsource\n\n\nsame_padding2d\n\n same_padding2d (H, W, ks, stride=(1, 1), dilation=(1, 1))\n\nSame padding formula as used in Tensorflow\n\nbs = 2\nc_in = 3\nc_out = 5\nh = 16\nw = 20\nt = torch.rand(bs, c_in, h, w)\ntest_eq(Conv2dSame(c_in, c_out, ks=3, stride=1, dilation=1, bias=False)(t).shape, (bs, c_out, h, w))\ntest_eq(Conv2dSame(c_in, c_out, ks=(3, 1), stride=1, dilation=1, bias=False)(t).shape, (bs, c_out, h, w))\ntest_eq(Conv2dSame(c_in, c_out, ks=3, stride=(1, 1), dilation=(2, 2), bias=False)(t).shape, (bs, c_out, h, w))\ntest_eq(Conv2dSame(c_in, c_out, ks=3, stride=(2, 2), dilation=(1, 1), bias=False)(t).shape, (bs, c_out, h//2, w//2))\ntest_eq(Conv2dSame(c_in, c_out, ks=3, stride=(2, 2), dilation=(2, 2), bias=False)(t).shape, (bs, c_out, h//2, w//2))\ntest_eq(Conv2d(c_in, c_out, ks=3, padding='same', stride=1, dilation=1, bias=False)(t).shape, (bs, c_out, h, w))\n\n\nsource\n\n\nCausalConv1d\n\n CausalConv1d (ni, nf, ks, stride=1, dilation=1, groups=1, bias=True)\n\n*Applies a 1D convolution over an input signal composed of several input planes.\nIn the simplest case, the output value of the layer with input size :math:(N, C_{\\text{in}}, L) and output :math:(N, C_{\\text{out}}, L_{\\text{out}}) can be precisely described as:\n.. math:: (N_i, C_{j}) = (C{j}) + {k = 0}^{C_{in} - 1} (C_{_j}, k) (N_i, k)\nwhere :math:\\star is the valid cross-correlation_ operator, :math:N is a batch size, :math:C denotes a number of channels, :math:L is a length of signal sequence.\nThis module supports :ref:TensorFloat32&lt;tf32_on_ampere&gt;.\nOn certain ROCm devices, when using float16 inputs this module will use :ref:different precision&lt;fp16_on_mi200&gt; for backward.\n\n:attr:stride controls the stride for the cross-correlation, a single number or a one-element tuple.\n:attr:padding controls the amount of padding applied to the input. It can be either a string {‘valid’, ‘same’} or a tuple of ints giving the amount of implicit padding applied on both sides.\n:attr:dilation controls the spacing between the kernel points; also known as the à trous algorithm. It is harder to describe, but this link_ has a nice visualization of what :attr:dilation does.\n:attr:groups controls the connections between inputs and outputs. :attr:in_channels and :attr:out_channels must both be divisible by :attr:groups. For example,\n\nAt groups=1, all inputs are convolved to all outputs.\nAt groups=2, the operation becomes equivalent to having two conv layers side by side, each seeing half the input channels and producing half the output channels, and both subsequently concatenated.\nAt groups= :attr:in_channels, each input channel is convolved with its own set of filters (of size :math:\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}).\n\n\nNote: When groups == in_channels and out_channels == K * in_channels, where K is a positive integer, this operation is also known as a “depthwise convolution”.\nIn other words, for an input of size :math:`(N, C_{in}, L_{in})`,\na depthwise convolution with a depthwise multiplier `K` can be performed with the arguments\n:math:`(C_\\text{in}=C_\\text{in}, C_\\text{out}=C_\\text{in} \\times \\text{K}, ..., \\text{groups}=C_\\text{in})`.\nNote: In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting torch.backends.cudnn.deterministic = True. See :doc:/notes/randomness for more information.\nNote: padding='valid' is the same as no padding. padding='same' pads the input so the output has the shape as the input. However, this mode doesn’t support any stride values other than 1.\nNote: This module supports complex data types i.e. complex32, complex64, complex128.\nArgs: in_channels (int): Number of channels in the input image out_channels (int): Number of channels produced by the convolution kernel_size (int or tuple): Size of the convolving kernel stride (int or tuple, optional): Stride of the convolution. Default: 1 padding (int, tuple or str, optional): Padding added to both sides of the input. Default: 0 dilation (int or tuple, optional): Spacing between kernel elements. Default: 1 groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1 bias (bool, optional): If True, adds a learnable bias to the output. Default: True padding_mode (str, optional): 'zeros', 'reflect', 'replicate' or 'circular'. Default: 'zeros'\nShape: - Input: :math:(N, C_{in}, L_{in}) or :math:(C_{in}, L_{in}) - Output: :math:(N, C_{out}, L_{out}) or :math:(C_{out}, L_{out}), where\n  .. math::\n      L_{out} = \\left\\lfloor\\frac{L_{in} + 2 \\times \\text{padding} - \\text{dilation}\n                \\times (\\text{kernel\\_size} - 1) - 1}{\\text{stride}} + 1\\right\\rfloor\nAttributes: weight (Tensor): the learnable weights of the module of shape :math:(\\text{out\\_channels},         \\frac{\\text{in\\_channels}}{\\text{groups}}, \\text{kernel\\_size}). The values of these weights are sampled from :math:\\mathcal{U}(-\\sqrt{k}, \\sqrt{k}) where :math:k = \\frac{groups}{C_\\text{in} * \\text{kernel\\_size}} bias (Tensor): the learnable bias of the module of shape (out_channels). If :attr:bias is True, then the values of these weights are sampled from :math:\\mathcal{U}(-\\sqrt{k}, \\sqrt{k}) where :math:k = \\frac{groups}{C_\\text{in} * \\text{kernel\\_size}}\nExamples::\n&gt;&gt;&gt; m = nn.Conv1d(16, 33, 3, stride=2)\n&gt;&gt;&gt; input = torch.randn(20, 16, 50)\n&gt;&gt;&gt; output = m(input)\n.. _cross-correlation: https://en.wikipedia.org/wiki/Cross-correlation\n.. _link: https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md*\n\nsource\n\n\nConv1d\n\n Conv1d (ni, nf, kernel_size=None, ks=None, stride=1, padding='same',\n         dilation=1, init='auto', bias_std=0.01, **kwargs)\n\nconv1d layer with padding=‘same’, ‘causal’, ‘valid’, or any integer (defaults to ‘same’)\n\nbs = 2\nc_in = 3\nc_out = 5\nseq_len = 512\nt = torch.rand(bs, c_in, seq_len)\ndilation = 1\ntest_eq(CausalConv1d(c_in, c_out, ks=3, dilation=dilation)(t).shape, Conv1d(c_in, c_out, ks=3, padding=\"same\", dilation=dilation)(t).shape)\ndilation = 2\ntest_eq(CausalConv1d(c_in, c_out, ks=3, dilation=dilation)(t).shape, Conv1d(c_in, c_out, ks=3, padding=\"same\", dilation=dilation)(t).shape)\n\n\nbs = 2\nni = 3\nnf = 5\nseq_len = 6\nks = 3\nt = torch.rand(bs, c_in, seq_len)\ntest_eq(Conv1d(ni, nf, ks, padding=0)(t).shape, (bs, c_out, seq_len - (2 * (ks//2))))\ntest_eq(Conv1d(ni, nf, ks, padding='valid')(t).shape, (bs, c_out, seq_len - (2 * (ks//2))))\ntest_eq(Conv1d(ni, nf, ks, padding='same')(t).shape, (bs, c_out, seq_len))\ntest_eq(Conv1d(ni, nf, ks, padding='causal')(t).shape, (bs, c_out, seq_len))\ntest_error('use kernel_size or ks but not both simultaneously', Conv1d, ni, nf, kernel_size=3, ks=3)\ntest_error('you need to pass a ks', Conv1d, ni, nf)\n\n\nconv = Conv1d(ni, nf, ks, padding='same')\ninit_linear(conv, None, init='auto', bias_std=.01)\nconv\n\nConv1d(3, 5, kernel_size=(3,), stride=(1,), padding=(1,))\n\n\n\nconv = Conv1d(ni, nf, ks, padding='causal')\ninit_linear(conv, None, init='auto', bias_std=.01)\nconv\n\nCausalConv1d(3, 5, kernel_size=(3,), stride=(1,))\n\n\n\nconv = Conv1d(ni, nf, ks, padding='valid')\ninit_linear(conv, None, init='auto', bias_std=.01)\nweight_norm(conv)\nconv\n\nConv1d(3, 5, kernel_size=(3,), stride=(1,))\n\n\n\nconv = Conv1d(ni, nf, ks, padding=0)\ninit_linear(conv, None, init='auto', bias_std=.01)\nweight_norm(conv)\nconv\n\nConv1d(3, 5, kernel_size=(3,), stride=(1,))\n\n\n\nsource\n\n\nSeparableConv1d\n\n SeparableConv1d (ni, nf, ks, stride=1, padding='same', dilation=1,\n                  bias=True, bias_std=0.01)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 64\nc_in = 6\nc_out = 5\nseq_len = 512\nt = torch.rand(bs, c_in, seq_len)\ntest_eq(SeparableConv1d(c_in, c_out, 3)(t).shape, (bs, c_out, seq_len))\n\n\nsource\n\n\nAddCoords1d\n\n AddCoords1d ()\n\nAdd coordinates to ease position identification without modifying mean and std\n\nbs = 2\nc_in = 3\nc_out = 5\nseq_len = 50\n\nt = torch.rand(bs, c_in, seq_len)\nt = (t - t.mean()) / t.std()\ntest_eq(AddCoords1d()(t).shape, (bs, c_in + 1, seq_len))\nnew_t = AddCoords1d()(t)\ntest_close(new_t.mean(),0, 1e-2)\ntest_close(new_t.std(), 1, 1e-2)\n\n\nsource\n\n\nConvBlock\n\n ConvBlock (ni, nf, kernel_size=None, ks=3, stride=1, padding='same',\n            bias=None, bias_std=0.01, norm='Batch', zero_norm=False,\n            bn_1st=True, act=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n            act_kwargs={}, init='auto', dropout=0.0, xtra=None,\n            coord=False, separable=False, **kwargs)\n\nCreate a sequence of conv1d (ni to nf), activation (if act_cls) and norm_type layers.\n\nsource\n\n\nResBlock1dPlus\n\n ResBlock1dPlus (expansion, ni, nf, coord=False, stride=1, groups=1,\n                 reduction=None, nh1=None, nh2=None, dw=False, g2=1,\n                 sa=False, sym=False, norm='Batch', zero_norm=True,\n                 act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;, ks=3,\n                 pool=&lt;function AvgPool&gt;, pool_first=True, **kwargs)\n\nResnet block from ni to nh with stride\n\nsource\n\n\nSEModule1d\n\n SEModule1d (ni, reduction=16, act=&lt;class\n             'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\nSqueeze and excitation module for 1d\n\nt = torch.rand(8, 32, 12)\ntest_eq(SEModule1d(t.shape[1], 16, act=nn.ReLU, act_kwargs={})(t).shape, t.shape)\n\n\nsource\n\n\nNorm\n\n Norm (nf, ndim=1, norm='Batch', zero_norm=False, init=True, **kwargs)\n\nNorm layer with nf features and ndim with auto init.\n\nbs = 2\nni = 3\nnf = 5\nsl = 4\nks = 5\n\nt = torch.rand(bs, ni, sl)\ntest_eq(ConvBlock(ni, nf, ks)(t).shape, (bs, nf, sl))\ntest_eq(ConvBlock(ni, nf, ks, padding='causal')(t).shape, (bs, nf, sl))\ntest_eq(ConvBlock(ni, nf, ks, coord=True)(t).shape, (bs, nf, sl))\n\n\ntest_eq(BN1d(ni)(t).shape, (bs, ni, sl))\ntest_eq(BN1d(ni).weight.data.mean().item(), 1.)\ntest_eq(BN1d(ni, zero_norm=True).weight.data.mean().item(), 0.)\n\n\ntest_eq(ConvBlock(ni, nf, ks, norm='batch', zero_norm=True)[1].weight.data.unique().item(), 0)\ntest_ne(ConvBlock(ni, nf, ks, norm='batch', zero_norm=False)[1].weight.data.unique().item(), 0)\ntest_eq(ConvBlock(ni, nf, ks, bias=False)[0].bias, None)\nConvBlock(ni, nf, ks, act=Swish, coord=True)\n\nConvBlock(\n  (0): AddCoords1d()\n  (1): Conv1d(4, 5, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n  (2): BatchNorm1d(5, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (3): SiLU()\n)\n\n\n\nsource\n\n\nLinLnDrop\n\n LinLnDrop (n_in, n_out, ln=True, p=0.0, act=None, lin_first=False)\n\nModule grouping LayerNorm1d, Dropout and Linear layers\n\nLinLnDrop(2, 3, p=.5)\n\nLinLnDrop(\n  (0): LayerNorm((2,), eps=1e-05, elementwise_affine=True)\n  (1): Dropout(p=0.5, inplace=False)\n  (2): Linear(in_features=2, out_features=3, bias=False)\n)\n\n\n\nsource\n\n\nLambdaPlus\n\n LambdaPlus (func, *args, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nReZero\n\n ReZero (module)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nClip\n\n Clip (min=None, max=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nClamp\n\n Clamp (min=None, max=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nSoftMax\n\n SoftMax (dim=-1)\n\nSoftMax layer\n\nsource\n\n\nLastStep\n\n LastStep ()\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nMax\n\n Max (dim=None, keepdim=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nReshape\n\n Reshape (*shape)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nView\n\n View (*shape)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nTranspose\n\n Transpose (*dims, contiguous=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nPermute\n\n Permute (*dims)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nUnfold\n\n Unfold (dim, size, step=1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nConcat\n\n Concat (dim=1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nAdd\n\n Add ()\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nUnsqueeze\n\n Unsqueeze (dim=-1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nSqueeze\n\n Squeeze (dim=-1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 2\nnf = 5\nsl = 4\n\nt = torch.rand(bs, nf, sl)\ntest_eq(Permute(0,2,1)(t).shape, (bs, sl, nf))\ntest_eq(Max(1)(t).shape, (bs, sl))\ntest_eq(Transpose(1,2)(t).shape, (bs, sl, nf))\ntest_eq(Transpose(1,2, contiguous=True)(t).shape, (bs, sl, nf))\ntest_eq(View(-1, 2, 10)(t).shape, (bs, 1, 2, 10))\ntest_eq(Reshape(-1, 2, 10)(t).shape, (bs, 1, 2, 10))\ntest_eq(Reshape()(t).shape, (2, 20))\ntest_eq(Reshape(-1)(t).shape, (40,))\nTranspose(1,2), Permute(0,2,1), View(-1, 2, 10), Transpose(1,2, contiguous=True), Reshape(-1, 2, 10), Noop\n\n(Transpose(dims=1, 2).contiguous(),\n Permute(dims=0, 2, 1),\n View(bs, -1, 2, 10),\n Transpose(dims=1, 2).contiguous(),\n Reshape(bs, -1, 2, 10),\n Sequential())\n\n\n\nsource\n\n\nDropPath\n\n DropPath (p=None)\n\n*Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).\nIt’s similar to Dropout but it drops individual connections instead of nodes. Original code in https://github.com/rwightman/pytorch-image-models (timm library)*\n\nt = torch.ones(100,2,3)\ntest_eq(DropPath(0.)(t), t)\nassert DropPath(0.5)(t).max() &gt;= 1\n\n\nsource\n\n\nSharpen\n\n Sharpen (T=0.5)\n\nThis is used to increase confidence in predictions - MixMatch paper\n\nn_samples = 1000\nn_classes = 3\n\nt = (torch.rand(n_samples, n_classes) - .5) * 10\nprobas = F.softmax(t, -1)\nsharpened_probas = Sharpen()(probas)\nplt.plot(probas.flatten().sort().values, color='r')\nplt.plot(sharpened_probas.flatten().sort().values, color='b')\nplt.show()\ntest_gt(sharpened_probas[n_samples//2:].max(-1).values.sum().item(), probas[n_samples//2:].max(-1).values.sum().item())\n\n\n\n\n\n\n\n\n\nsource\n\n\nSequential\n\n Sequential (*args)\n\nClass that allows you to pass one or multiple inputs\n\nsource\n\n\nTimeDistributed\n\n TimeDistributed (module, batch_first=False)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nget_calibrator\n\n get_calibrator (calibrator=None, n_classes=1, **kwargs)\n\n\nsource\n\n\nMatrix_Scale\n\n Matrix_Scale (n_classes=1, dirichlet=False)\n\nUsed to perform Matrix Scaling (dirichlet=False) or Dirichlet calibration (dirichlet=True)\n\nsource\n\n\nVector_Scale\n\n Vector_Scale (n_classes=1, dirichlet=False)\n\nUsed to perform Vector Scaling (dirichlet=False) or Diagonal Dirichlet calibration (dirichlet=True)\n\nsource\n\n\nTemp_Scale\n\n Temp_Scale (temp=1.0, dirichlet=False)\n\nUsed to perform Temperature Scaling (dirichlet=False) or Single-parameter Dirichlet calibration (dirichlet=True)\n\nbs = 2\nc_out = 3\n\nt = torch.rand(bs, c_out)\nfor calibrator, cal_name in zip(['temp', 'vector', 'matrix'], ['Temp_Scale', 'Vector_Scale', 'Matrix_Scale']):\n    cal = get_calibrator(calibrator, n_classes=c_out)\n#     print(calibrator)\n#     print(cal.weight, cal.bias, '\\n')\n    test_eq(cal(t), t)\n    test_eq(cal.__class__.__name__, cal_name)\nfor calibrator, cal_name in zip(['dtemp', 'dvector', 'dmatrix'], ['Temp_Scale', 'Vector_Scale', 'Matrix_Scale']):\n    cal = get_calibrator(calibrator, n_classes=c_out)\n#     print(calibrator)\n#     print(cal.weight, cal.bias, '\\n')\n    test_eq(cal(t), F.log_softmax(t, dim=1))\n    test_eq(cal.__class__.__name__, cal_name)\n\n\nbs = 2\nc_out = 3\n\nt = torch.rand(bs, c_out)\n\ntest_eq(Temp_Scale()(t).shape, t.shape)\ntest_eq(Vector_Scale(c_out)(t).shape, t.shape)\ntest_eq(Matrix_Scale(c_out)(t).shape, t.shape)\ntest_eq(Temp_Scale(dirichlet=True)(t).shape, t.shape)\ntest_eq(Vector_Scale(c_out, dirichlet=True)(t).shape, t.shape)\ntest_eq(Matrix_Scale(c_out, dirichlet=True)(t).shape, t.shape)\n\ntest_eq(Temp_Scale()(t), t)\ntest_eq(Vector_Scale(c_out)(t), t)\ntest_eq(Matrix_Scale(c_out)(t), t)\n\n\nbs = 2\nc_out = 5\n\nt = torch.rand(bs, c_out)\ntest_eq(Vector_Scale(c_out)(t), t)\ntest_eq(Vector_Scale(c_out).weight.data, torch.ones(c_out))\ntest_eq(Vector_Scale(c_out).weight.requires_grad, True)\ntest_eq(type(Vector_Scale(c_out).weight), torch.nn.parameter.Parameter)\n\n\nbs = 2\nc_out = 3\nweight = 2\nbias = 1\n\nt = torch.rand(bs, c_out)\ntest_eq(Matrix_Scale(c_out)(t).shape, t.shape)\ntest_eq(Matrix_Scale(c_out).weight.requires_grad, True)\ntest_eq(type(Matrix_Scale(c_out).weight), torch.nn.parameter.Parameter)\n\n\nsource\n\n\nLogitAdjustmentLayer\n\n LogitAdjustmentLayer (class_priors)\n\nLogit Adjustment for imbalanced datasets\n\nbs, n_classes = 16, 3\nclass_priors = torch.rand(n_classes)\nlogits = torch.randn(bs, n_classes) * 2\ntest_eq(LogitAdjLayer(class_priors)(logits), logits + class_priors)\n\n\nsource\n\n\nMaxPPVPool1d\n\n MaxPPVPool1d ()\n\nDrop-in replacement for AdaptiveConcatPool1d - multiplies nf by 2\n\nsource\n\n\nPPAuc\n\n PPAuc (dim=-1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nPPV\n\n PPV (dim=-1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 2\nnf = 5\nsl = 4\n\nt = torch.rand(bs, nf, sl)\ntest_eq(MaxPPVPool1d()(t).shape, (bs, nf*2, 1))\ntest_eq(MaxPPVPool1d()(t).shape, AdaptiveConcatPool1d(1)(t).shape)\n\n\nsource\n\n\nAdaptiveWeightedAvgPool1d\n\n AdaptiveWeightedAvgPool1d (n_in, seq_len, mult=2, n_layers=2, ln=False,\n                            dropout=0.5, act=ReLU(), zero_init=True)\n\n*Global Pooling layer that performs a weighted average along the temporal axis\nIt can be considered as a channel-wise form of local temporal attention. Inspired by the paper: Hyun, J., Seong, H., & Kim, E. (2019). Universal Pooling–A New Pooling Method for Convolutional Neural Networks. arXiv preprint arXiv:1907.11440.*\n\nsource\n\n\nGAWP1d\n\n GAWP1d (n_in, seq_len, n_layers=2, ln=False, dropout=0.5, act=ReLU(),\n         zero_init=False)\n\nGlobal AdaptiveWeightedAvgPool1d + Flatten\n\nsource\n\n\nGACP1d\n\n GACP1d (output_size=1)\n\nGlobal AdaptiveConcatPool + Flatten\n\nsource\n\n\nGAP1d\n\n GAP1d (output_size=1)\n\nGlobal Adaptive Pooling + Flatten\n\nsource\n\n\ngwa_pool_head\n\n gwa_pool_head (n_in, c_out, seq_len, bn=True, fc_dropout=0.0)\n\n\nsource\n\n\nGlobalWeightedAveragePool1d\n\n GlobalWeightedAveragePool1d (n_in, seq_len)\n\n*Global Weighted Average Pooling layer\nInspired by Building Efficient CNN Architecture for Offline Handwritten Chinese Character Recognition https://arxiv.org/pdf/1804.01259.pdf*\n\nt = torch.randn(16, 64, 50)\nhead = gwa_pool_head(64, 5, 50)\ntest_eq(head(t).shape, (16, 5))\n\n\nsource\n\n\nattentional_pool_head\n\n attentional_pool_head (n_in, c_out, seq_len=None, bn=True, **kwargs)\n\n\nsource\n\n\nGAttP1d\n\n GAttP1d (n_in, c_out, bn=False)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nAttentionalPool1d\n\n AttentionalPool1d (n_in, c_out, bn=False)\n\nGlobal Adaptive Pooling layer inspired by Attentional Pooling for Action Recognition https://arxiv.org/abs/1711.01467\n\nbs, c_in, seq_len = 16, 1, 50\nc_out = 3\nt = torch.rand(bs, c_in, seq_len)\ntest_eq(GAP1d()(t).shape, (bs, c_in))\ntest_eq(GACP1d()(t).shape, (bs, c_in*2))\nbs, c_in, seq_len = 16, 4, 50\nt = torch.rand(bs, c_in, seq_len)\ntest_eq(GAP1d()(t).shape, (bs, c_in))\ntest_eq(GACP1d()(t).shape, (bs, c_in*2))\ntest_eq(GAWP1d(c_in, seq_len, n_layers=2, ln=False, dropout=0.5, act=nn.ReLU(), zero_init=False)(t).shape, (bs, c_in))\ntest_eq(GAWP1d(c_in, seq_len, n_layers=2, ln=False, dropout=0.5, act=nn.ReLU(), zero_init=False)(t).shape, (bs, c_in))\ntest_eq(GAWP1d(c_in, seq_len, n_layers=1, ln=False, dropout=0.5, zero_init=False)(t).shape, (bs, c_in))\ntest_eq(GAWP1d(c_in, seq_len, n_layers=1, ln=False, dropout=0.5, zero_init=True)(t).shape, (bs, c_in))\ntest_eq(AttentionalPool1d(c_in, c_out)(t).shape, (bs, c_out, 1))\n\n\nbs, c_in, seq_len = 16, 128, 50\nc_out = 14\nt = torch.rand(bs, c_in, seq_len)\nattp = attentional_pool_head(c_in, c_out)\ntest_eq(attp(t).shape, (bs, c_out))\n\n\nsource\n\n\nPoolingLayer\n\n PoolingLayer (method='cls', seq_len=None, token=True, seq_last=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nt = torch.arange(24).reshape(2, 3, 4).float()\ntest_eq(PoolingLayer('cls', token=True, seq_last=True)(t), tensor([[ 0.,  4.,  8.], [12., 16., 20.]]))\ntest_eq(PoolingLayer('max', token=True, seq_last=True)(t), tensor([[ 3.,  7., 11.], [15., 19., 23.]]))\ntest_close(PoolingLayer('mean', token=True, seq_last=True)(t), tensor([[ 2.,  6., 10.], [14., 18., 22.]]))\ntest_close(PoolingLayer('max-mean', token=True, seq_last=True)(t), tensor([[ 3.,  7., 11.,  2.,  6., 10.],\n                                                                           [15., 19., 23., 14., 18., 22.]]))\ntest_close(PoolingLayer('flatten', token=True, seq_last=True)(t), tensor([[ 1.,  2.,  3.,  5.,  6.,  7.,  9., 10., 11.],\n                                                                          [13., 14., 15., 17., 18., 19., 21., 22., 23.]]))\ntest_eq(PoolingLayer('linear', seq_len=4, token=True, seq_last=True)(t).shape, (2, 3))\ntest_eq(PoolingLayer('max', token=False, seq_last=True)(t), tensor([[ 3.,  7., 11.], [15., 19., 23.]]))\ntest_close(PoolingLayer('mean', token=False, seq_last=True)(t), tensor([[ 1.5000,  5.5000,  9.5000],\n                                                                        [13.5000, 17.5000, 21.5000]]))\ntest_close(PoolingLayer('max-mean', token=False, seq_last=True)(t), tensor([[ 3.,  7., 11.,  1.5000,  5.5000,  9.5000],\n                                                                            [15., 19., 23., 13.5000, 17.5000, 21.5000]]))\ntest_close(PoolingLayer('flatten', token=False, seq_last=True)(t), tensor([[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.],\n                                                                           [12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23.]]))\ntest_eq(PoolingLayer('linear', seq_len=4, token=False, seq_last=True)(t).shape, (2, 3))\n\n\nt = torch.arange(24).reshape(2, 3, 4).swapaxes(1,2).float()\ntest_eq(PoolingLayer('cls', token=True, seq_last=False)(t), tensor([[ 0.,  4.,  8.], [12., 16., 20.]]))\ntest_eq(PoolingLayer('max', token=True, seq_last=False)(t), tensor([[ 3.,  7., 11.], [15., 19., 23.]]))\ntest_close(PoolingLayer('mean', token=True, seq_last=False)(t), tensor([[ 2.,  6., 10.], [14., 18., 22.]]))\ntest_close(PoolingLayer('max-mean', token=True, seq_last=False)(t), tensor([[ 3.,  7., 11.,  2.,  6., 10.],\n                                                                           [15., 19., 23., 14., 18., 22.]]))\ntest_close(PoolingLayer('flatten', token=True, seq_last=False)(t), tensor([[ 1.,  5.,  9.,  2.,  6., 10.,  3.,  7., 11.],\n                                                                           [13., 17., 21., 14., 18., 22., 15., 19., 23.]]))\nt = torch.arange(24).reshape(2, 3, 4).swapaxes(1,2).float()\ntest_eq(PoolingLayer('conv1d', seq_len=4, token=False, seq_last=False)(t).shape, (2, 3))\ntest_eq(PoolingLayer('max', token=False, seq_last=False)(t), tensor([[ 3.,  7., 11.], [15., 19., 23.]]))\ntest_close(PoolingLayer('mean', token=False, seq_last=False)(t), tensor([[ 1.5000,  5.5000,  9.5000],\n                                                                        [13.5000, 17.5000, 21.5000]]))\ntest_close(PoolingLayer('max-mean', token=False, seq_last=False)(t), tensor([[ 3.,  7., 11.,  1.5000,  5.5000,  9.5000],\n                                                                            [15., 19., 23., 13.5000, 17.5000, 21.5000]]))\ntest_close(PoolingLayer('flatten', token=False, seq_last=False)(t), tensor([[ 0.,  4.,  8.,  1.,  5.,  9.,  2.,  6., 10.,  3.,  7., 11.],\n                                                                            [12., 16., 20., 13., 17., 21., 14., 18., 22., 15., 19., 23.]]))\ntest_eq(PoolingLayer('conv1d', seq_len=4, token=False, seq_last=False)(t).shape, (2, 3))\n\n\nsource\n\n\nReGLU\n\n ReGLU ()\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nGEGLU\n\n GEGLU ()\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nget_act_fn\n\n get_act_fn (act, **act_kwargs)\n\n\ntest_eq(get_act_fn(nn.ReLU).__repr__(), \"ReLU()\")\ntest_eq(get_act_fn(nn.ReLU()).__repr__(), \"ReLU()\")\ntest_eq(get_act_fn(nn.LeakyReLU, negative_slope=0.05).__repr__(), \"LeakyReLU(negative_slope=0.05)\")\ntest_eq(get_act_fn('reglu').__repr__(), \"ReGLU()\")\ntest_eq(get_act_fn('leakyrelu', negative_slope=0.05).__repr__(), \"LeakyReLU(negative_slope=0.05)\")\n\n\nsource\n\n\nRevIN\n\n RevIN (c_in:int, affine:bool=True, subtract_last:bool=False, dim:int=2,\n        eps:float=1e-05)\n\n*Reversible Instance Normalization layer adapted from\nKim, T., Kim, J., Tae, Y., Park, C., Choi, J. H., & Choo, J. (2021, September). Reversible instance normalization for accurate time-series forecasting against distribution shift. In International Conference on Learning Representations. Original code: https://github.com/ts-kim/RevIN*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\n#features (aka variables or channels)\n\n\naffine\nbool\nTrue\nflag to incidate if RevIN has learnable weight and bias\n\n\nsubtract_last\nbool\nFalse\n\n\n\ndim\nint\n2\nint or tuple of dimensions used to calculate mean and std\n\n\neps\nfloat\n1e-05\nepsilon - parameter added for numerical stability\n\n\n\n\nsource\n\n\nRevIN\n\n RevIN (c_in:int, affine:bool=True, subtract_last:bool=False, dim:int=2,\n        eps:float=1e-05)\n\n*Reversible Instance Normalization layer adapted from\nKim, T., Kim, J., Tae, Y., Park, C., Choi, J. H., & Choo, J. (2021, September). Reversible instance normalization for accurate time-series forecasting against distribution shift. In International Conference on Learning Representations. Original code: https://github.com/ts-kim/RevIN*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\n#features (aka variables or channels)\n\n\naffine\nbool\nTrue\nflag to incidate if RevIN has learnable weight and bias\n\n\nsubtract_last\nbool\nFalse\n\n\n\ndim\nint\n2\nint or tuple of dimensions used to calculate mean and std\n\n\neps\nfloat\n1e-05\nepsilon - parameter added for numerical stability\n\n\n\n\nt = ((torch.rand(16, 5, 100) - .25) * torch.Tensor([.01, .1, 1, 10, 100]).reshape(1, -1, 1)).cumsum(-1)\nt_clone = t.clone()\nl = RevIN(5)\nt_norm = l(t, torch.tensor(True))\nt_denorm = l(t_norm, torch.tensor(False))\ntest_close(t_clone, t_denorm, eps=1e-3)\n\n\nmodel = RevIN(5, affine=True)\ntry:\n    scripted_model = torch.jit.script(model)\n    file_path = f\"test_scripted_model.pt\"\n    torch.jit.save(scripted_model, file_path)\n    scripted_model = torch.jit.load(file_path)\n\n    inp = ((torch.rand(16, 5, 100) - .25) * torch.Tensor([.01, .1, 1, 10, 100]).reshape(1, -1, 1)).cumsum(-1)\n    normed_output = model(inp, torch.tensor(True))\n    demormed_output = model(normed_output, torch.tensor(False))\n    scripted_normed_output = scripted_model(inp, torch.tensor(True))\n    scripted_denormed_output = scripted_model(scripted_normed_output, torch.tensor(False))\n    test_close(normed_output, scripted_normed_output)\n    test_close(demormed_output, scripted_denormed_output)\n    os.remove(file_path)\n    del scripted_model\n    gc.collect()\n    print('scripting ok')\nexcept Exception as e:\n    print(f'scripting failed: {e}')\n\nscripting ok\n\n\n\nsource\n\n\ncreate_pool_head\n\n create_pool_head (n_in, c_out, seq_len=None, concat_pool=False,\n                   fc_dropout=0.0, bn=False, y_range=None, **kwargs)\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(create_pool_head(nf, c_out, seq_len, fc_dropout=0.5)(t).shape, (bs, c_out))\ntest_eq(create_pool_head(nf, c_out, seq_len, concat_pool=True, fc_dropout=0.5)(t).shape, (bs, c_out))\ncreate_pool_head(nf, c_out, seq_len, concat_pool=True, bn=True, fc_dropout=.5)\n\nSequential(\n  (0): GACP1d(\n    (gacp): AdaptiveConcatPool1d(\n      (ap): AdaptiveAvgPool1d(output_size=1)\n      (mp): AdaptiveMaxPool1d(output_size=1)\n    )\n    (flatten): Reshape(bs)\n  )\n  (1): LinBnDrop(\n    (0): BatchNorm1d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (1): Dropout(p=0.5, inplace=False)\n    (2): Linear(in_features=24, out_features=2, bias=False)\n  )\n)\n\n\n\nsource\n\n\nmax_pool_head\n\n max_pool_head (n_in, c_out, seq_len, fc_dropout=0.0, bn=False,\n                y_range=None, **kwargs)\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(max_pool_head(nf, c_out, seq_len, fc_dropout=0.5)(t).shape, (bs, c_out))\n\n\nsource\n\n\ncreate_pool_plus_head\n\n create_pool_plus_head (*args, lin_ftrs=None, fc_dropout=0.0,\n                        concat_pool=True, bn_final=False, lin_first=False,\n                        y_range=None)\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(create_pool_plus_head(nf, c_out, seq_len, fc_dropout=0.5)(t).shape, (bs, c_out))\ntest_eq(create_pool_plus_head(nf, c_out, concat_pool=True, fc_dropout=0.5)(t).shape, (bs, c_out))\ncreate_pool_plus_head(nf, c_out, seq_len, fc_dropout=0.5)\n\nSequential(\n  (0): AdaptiveConcatPool1d(\n    (ap): AdaptiveAvgPool1d(output_size=1)\n    (mp): AdaptiveMaxPool1d(output_size=1)\n  )\n  (1): Reshape(bs)\n  (2): BatchNorm1d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (3): Dropout(p=0.25, inplace=False)\n  (4): Linear(in_features=24, out_features=512, bias=False)\n  (5): ReLU(inplace=True)\n  (6): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (7): Dropout(p=0.5, inplace=False)\n  (8): Linear(in_features=512, out_features=2, bias=False)\n)\n\n\n\nsource\n\n\ncreate_conv_head\n\n create_conv_head (*args, adaptive_size=None, y_range=None)\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(create_conv_head(nf, c_out, seq_len)(t).shape, (bs, c_out))\ntest_eq(create_conv_head(nf, c_out, adaptive_size=50)(t).shape, (bs, c_out))\ncreate_conv_head(nf, c_out, 50)\n\nSequential(\n  (0): ConvBlock(\n    (0): Conv1d(12, 6, kernel_size=(1,), stride=(1,), bias=False)\n    (1): BatchNorm1d(6, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (1): ConvBlock(\n    (0): Conv1d(6, 3, kernel_size=(1,), stride=(1,), bias=False)\n    (1): BatchNorm1d(3, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (2): ConvBlock(\n    (0): Conv1d(3, 2, kernel_size=(1,), stride=(1,), bias=False)\n    (1): BatchNorm1d(2, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (3): GAP1d(\n    (gap): AdaptiveAvgPool1d(output_size=1)\n    (flatten): Reshape(bs)\n  )\n)\n\n\n\nsource\n\n\ncreate_mlp_head\n\n create_mlp_head (nf, c_out, seq_len=None, flatten=True, fc_dropout=0.0,\n                  bn=False, lin_first=False, y_range=None)\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(create_mlp_head(nf, c_out, seq_len, fc_dropout=0.5)(t).shape, (bs, c_out))\nt = torch.rand(bs, nf, seq_len)\ncreate_mlp_head(nf, c_out, seq_len, bn=True, fc_dropout=.5)\n\nSequential(\n  (0): Reshape(bs)\n  (1): LinBnDrop(\n    (0): BatchNorm1d(240, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (1): Dropout(p=0.5, inplace=False)\n    (2): Linear(in_features=240, out_features=2, bias=False)\n  )\n)\n\n\n\nsource\n\n\ncreate_fc_head\n\n create_fc_head (nf, c_out, seq_len=None, flatten=True, lin_ftrs=None,\n                 y_range=None, fc_dropout=0.0, bn=False, bn_final=False,\n                 act=ReLU(inplace=True))\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(create_fc_head(nf, c_out, seq_len, fc_dropout=0.5)(t).shape, (bs, c_out))\ncreate_mlp_head(nf, c_out, seq_len, bn=True, fc_dropout=.5)\n\nSequential(\n  (0): Reshape(bs)\n  (1): LinBnDrop(\n    (0): BatchNorm1d(240, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (1): Dropout(p=0.5, inplace=False)\n    (2): Linear(in_features=240, out_features=2, bias=False)\n  )\n)\n\n\n\nsource\n\n\ncreate_rnn_head\n\n create_rnn_head (*args, fc_dropout=0.0, bn=False, y_range=None)\n\n\nbs = 16\nnf = 12\nc_out = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\ntest_eq(create_rnn_head(nf, c_out, seq_len, fc_dropout=0.5)(t).shape, (bs, c_out))\ncreate_rnn_head(nf, c_out, seq_len, bn=True, fc_dropout=.5)\n\nSequential(\n  (0): LastStep()\n  (1): LinBnDrop(\n    (0): BatchNorm1d(12, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (1): Dropout(p=0.5, inplace=False)\n    (2): Linear(in_features=12, out_features=2, bias=False)\n  )\n)\n\n\n\nsource\n\n\nimputation_head\n\n imputation_head (c_in, c_out, seq_len=None, ks=1, y_range=None,\n                  fc_dropout=0.0)\n\n\nbs = 16\nnf = 12\nni = 2\nseq_len = 20\nt = torch.rand(bs, nf, seq_len)\nhead = imputation_head(nf, ni, seq_len=None, ks=1, y_range=None, fc_dropout=0.)\ntest_eq(head(t).shape, (bs, ni, seq_len))\nhead = imputation_head(nf, ni, seq_len=None, ks=1, y_range=(.3,.7), fc_dropout=0.)\ntest_ge(head(t).min(), .3)\ntest_le(head(t).max(), .7)\ny_range = (tensor([0.1000, 0.1000, 0.1000, 0.1000, 0.2000, 0.2000, 0.2000, 0.2000, 0.3000,\n                   0.3000, 0.3000, 0.3000]),\n           tensor([0.6000, 0.6000, 0.6000, 0.6000, 0.7000, 0.7000, 0.7000, 0.7000, 0.8000,\n                   0.8000, 0.8000, 0.8000]))\ntest_ge(head(t).min(), .1)\ntest_le(head(t).max(), .9)\nhead = imputation_head(nf, ni, seq_len=None, ks=1, y_range=y_range, fc_dropout=0.)\nhead\n\nSequential(\n  (0): Dropout(p=0.0, inplace=False)\n  (1): Conv1d(12, 2, kernel_size=(1,), stride=(1,))\n  (2): fastai.layers.SigmoidRange(low=tensor([0.1000, 0.1000, 0.1000, 0.1000, 0.2000, 0.2000, 0.2000, 0.2000, 0.3000,\n          0.3000, 0.3000, 0.3000]), high=tensor([0.6000, 0.6000, 0.6000, 0.6000, 0.7000, 0.7000, 0.7000, 0.7000, 0.8000,\n          0.8000, 0.8000, 0.8000]))\n)\n\n\n\nsource\n\n\ncreate_conv_lin_nd_head\n\n create_conv_lin_nd_head (n_in, n_out, seq_len, d, conv_first=True,\n                          conv_bn=False, lin_bn=False, fc_dropout=0.0,\n                          **kwargs)\n\nModule to create a nd output head\n\nbs = 16\nnf = 32\nc = 5\nseq_len = 10\nd = 2\ntarg = torch.randint(0, c, (bs,d))\nt = torch.randn(bs, nf, seq_len)\nhead = conv_lin_nd_head(nf, c, seq_len, d, conv_first=True, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, (bs, d, c))\nloss = CrossEntropyLossFlat()(inp, targ)\nloss, head\n\n(TensorBase(1.7252, grad_fn=&lt;AliasBackward0&gt;),\n create_conv_lin_nd_head(\n   (0): Conv1d(32, 5, kernel_size=(1,), stride=(1,))\n   (1): Dropout(p=0.5, inplace=False)\n   (2): Linear(in_features=10, out_features=2, bias=True)\n   (3): Transpose(dims=-1, -2).contiguous()\n   (4): Reshape(bs, 2, 5)\n ))\n\n\n\nbs = 16\nnf = 32\nc = 5\nseq_len = 10\nd = [2, 8]\ntarg = torch.randint(0, c, [bs]+d)\nt = torch.randn(bs, nf, seq_len)\nhead = conv_lin_nd_head(nf, c, seq_len, d, conv_first=False, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, [bs]+d+[c])\nloss = CrossEntropyLossFlat()(inp, targ)\nloss, head\n\n(TensorBase(1.6647, grad_fn=&lt;AliasBackward0&gt;),\n create_conv_lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Linear(in_features=10, out_features=16, bias=True)\n   (2): Conv1d(32, 5, kernel_size=(1,), stride=(1,))\n   (3): Transpose(dims=-1, -2).contiguous()\n   (4): Reshape(bs, 2, 8, 5)\n ))\n\n\n\nbs = 16\nnf = 32\nc = 1\nseq_len = 10\nd = 2\ntarg = torch.rand(bs, d)\nt = torch.randn(bs, nf, seq_len)\nhead = conv_lin_nd_head(nf, c, seq_len, d, conv_first=False, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, (bs, d))\nloss = L1LossFlat()(inp, targ)\nloss, head\n\n(TensorBase(0.7063, grad_fn=&lt;AliasBackward0&gt;),\n create_conv_lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Linear(in_features=10, out_features=2, bias=True)\n   (2): Conv1d(32, 1, kernel_size=(1,), stride=(1,))\n   (3): Transpose(dims=-1, -2).contiguous()\n   (4): Reshape(bs, 2)\n ))\n\n\n\nbs = 16\nnf = 32\nc = 1\nseq_len = 10\nd = [2,3]\ntarg = torch.rand(bs, *d)\nt = torch.randn(bs, nf, seq_len)\nhead = conv_lin_nd_head(nf, c, seq_len, d, conv_first=False, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, [bs]+d)\nloss = L1LossFlat()(inp, targ)\nloss, head\n\n(TensorBase(0.6203, grad_fn=&lt;AliasBackward0&gt;),\n create_conv_lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Linear(in_features=10, out_features=6, bias=True)\n   (2): Conv1d(32, 1, kernel_size=(1,), stride=(1,))\n   (3): Transpose(dims=-1, -2).contiguous()\n   (4): Reshape(bs, 2, 3)\n ))\n\n\n\nsource\n\n\nlin_nd_head\n\n lin_nd_head (n_in, n_out, seq_len=None, d=None, flatten=False,\n              use_bn=False, fc_dropout=0.0)\n\nModule to create a nd output head with linear layers\n\nbs = 16\nnf = 32\nseq_len = 50\nx = torch.normal(0, 1, (bs, nf, seq_len))\n\nfor use_bn in [False, True]:\n    for fc_dropout in [0, 0.2]:\n        for flatten in [False, True]:\n            for c in [1, 3]:\n                for d in [None, (50,), (50,10), (30,5), (50,2,3), (30,2,3)]:\n                    for q_len in [1, seq_len]:\n                        head = lin_nd_head(nf, c, q_len, d, flatten=flatten, use_bn=use_bn, fc_dropout=fc_dropout)\n                        test_eq(head(x).shape, (bs, ) + (d if d is not None else ()) + ((c,) if c != 1 else ()))\n\n\nbs = 16\nnf = 32\nc = 5\nseq_len = 10\nd = 2\ntarg = torch.randint(0, c, (bs,d))\nt = torch.randn(bs, nf, seq_len)\nhead = lin_nd_head(nf, c, seq_len, d, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, (bs, d, c))\nloss = CrossEntropyLossFlat()(inp, targ)\nloss, head\n\n(TensorBase(1.7711, grad_fn=&lt;AliasBackward0&gt;),\n lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Reshape(bs)\n   (2): Linear(in_features=320, out_features=10, bias=True)\n   (3): Reshape(bs, 2, 5)\n ))\n\n\n\nbs = 16\nnf = 32\nc = 5\nseq_len = 10\nd = [2, 8]\ntarg = torch.randint(0, c, [bs]+d)\nt = torch.randn(bs, nf, seq_len)\nhead = lin_nd_head(nf, c, seq_len, d, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, [bs]+d+[c])\nloss = CrossEntropyLossFlat()(inp, targ)\nloss, head\n\n(TensorBase(1.8884, grad_fn=&lt;AliasBackward0&gt;),\n lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Reshape(bs)\n   (2): Linear(in_features=320, out_features=80, bias=True)\n   (3): Reshape(bs, 2, 8, 5)\n ))\n\n\n\nbs = 16\nnf = 32\nc = 1\nseq_len = 10\nd = 2\ntarg = torch.rand(bs, d)\nt = torch.randn(bs, nf, seq_len)\nhead = lin_nd_head(nf, c, seq_len, d, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, (bs, d))\nloss = L1LossFlat()(inp, targ)\nloss, head\n\n(TensorBase(0.7737, grad_fn=&lt;AliasBackward0&gt;),\n lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Reshape(bs)\n   (2): Linear(in_features=320, out_features=2, bias=True)\n   (3): Reshape(bs, 2)\n ))\n\n\n\nbs = 16\nnf = 32\nc = 1\nseq_len = 10\nd = [2,3]\ntarg = torch.rand(bs, *d)\nt = torch.randn(bs, nf, seq_len)\nhead = lin_nd_head(nf, c, seq_len, d, fc_dropout=.5)\ninp = head(t)\ntest_eq(inp.shape, [bs]+d)\nloss = L1LossFlat()(inp, targ)\nloss, head\n\n(TensorBase(0.8873, grad_fn=&lt;AliasBackward0&gt;),\n lin_nd_head(\n   (0): Dropout(p=0.5, inplace=False)\n   (1): Reshape(bs)\n   (2): Linear(in_features=320, out_features=6, bias=True)\n   (3): Reshape(bs, 2, 3)\n ))\n\n\n\nsource\n\n\nrocket_nd_head\n\n rocket_nd_head (n_in, n_out, seq_len=None, d=None, use_bn=False,\n                 fc_dropout=0.0, zero_init=True)\n\nModule to create a nd output head with linear layers for the rocket family of models\n\nbs = 16\nnf = 99\nseq_len = 1\nx = torch.normal(0, 1, (bs, nf, seq_len))\n\nfor use_bn in [False, True]:\n    for fc_dropout in [0, 0.2]:\n        for c in [1, 3]:\n            for d in [None, (50,), (50,10), (30,5), (50,2,3), (30,2,3)]:\n                head = rocket_nd_head(nf, c, 1, d, use_bn=use_bn, fc_dropout=fc_dropout)\n                test_eq(head(x).shape, (bs, ) + (d if d is not None else ()) + ((c,) if c != 1 else ()))\n\n\nsource\n\n\nxresnet1d_nd_head\n\n xresnet1d_nd_head (n_in, n_out, seq_len=None, d=None, use_bn=False,\n                    fc_dropout=0.0, zero_init=True)\n\nModule to create a nd output head with linear layers for the xresnet family of models\n\nbs = 16\nnf = 99\nseq_len = 2\nx = torch.normal(0, 1, (bs, nf, seq_len))\n\nfor use_bn in [False, True]:\n    for fc_dropout in [0, 0.2]:\n        for c in [1, 3]:\n            for d in [None, (50,), (50,10), (30,5), (50,2,3), (30,2,3)]:\n                head = xresnet1d_nd_head(nf, c, 1, d, use_bn=use_bn, fc_dropout=fc_dropout)\n                test_eq(head(x).shape, (bs, ) + (d if d is not None else ()) + ((c,) if c != 1 else ()))\n\n\nsource\n\n\ncreate_conv_3d_head\n\n create_conv_3d_head (n_in, n_out, seq_len, d, use_bn=False, **kwargs)\n\nModule to create a nd output head with a convolutional layer\n\nbs = 16\nnf = 32\nc = 5\nseq_len = 10\nd = 10\ntarg = torch.randint(0, c, (bs,d))\nt = torch.randn(bs, nf, seq_len)\nhead = conv_3d_head(nf, c, seq_len, d)\ninp = head(t)\ntest_eq(inp.shape, (bs, d, c))\nloss = CrossEntropyLossFlat()(inp, targ)\nloss, head\n\n(TensorBase(1.8352, grad_fn=&lt;AliasBackward0&gt;),\n create_conv_3d_head(\n   (0): ConvBlock(\n     (0): Conv1d(32, 5, kernel_size=(1,), stride=(1,))\n   )\n   (1): Transpose(dims=-1, -2).contiguous()\n ))\n\n\n\nbs = 16\nnf = 32\nc = 1\nseq_len = 10\nd = 10\ntarg = torch.rand(bs, d)\nt = torch.randn(bs, nf, seq_len)\nhead = conv_3d_head(nf, c, seq_len, d)\ninp = head(t)\ntest_eq(inp.shape, (bs, d))\nloss = L1LossFlat()(inp, targ)\nloss, head\n\n(TensorBase(0.6711, grad_fn=&lt;AliasBackward0&gt;),\n create_conv_3d_head(\n   (0): ConvBlock(\n     (0): Conv1d(32, 1, kernel_size=(1,), stride=(1,))\n   )\n   (1): Transpose(dims=-1, -2).contiguous()\n   (2): Squeeze(dim=-1)\n ))\n\n\n\nsource\n\n\nuniversal_pool_head\n\n universal_pool_head (n_in, c_out, seq_len, mult=2, pool_n_layers=2,\n                      pool_ln=True, pool_dropout=0.5, pool_act=ReLU(),\n                      zero_init=True, bn=True, fc_dropout=0.0)\n\n\nbs, c_in, seq_len = 16, 128, 50\nc_out = 14\nt = torch.rand(bs, c_in, seq_len)\nuph = universal_pool_head(c_in, c_out, seq_len)\ntest_eq(uph(t).shape, (bs, c_out))\nuph = universal_pool_head(c_in, c_out, seq_len, 2)\ntest_eq(uph(t).shape, (bs, c_out))\n\n\nbs, c_in, seq_len = 16, 128, 50\nc_out = 14\nd = 5\nt = torch.rand(bs, c_in, seq_len)\nfor head in heads:\n    print(head.__name__)\n    if head.__name__ == \"create_conv_3d_head\":\n        h = head(c_in, c_out, seq_len, seq_len)\n        test_eq(h(t).shape, (bs, seq_len, c_out))\n    elif 'nd' in head.__name__:\n        h = head(c_in, c_out, seq_len, d)\n        test_eq(h(t).shape, (bs, d, c_out))\n    else:\n        h = head(c_in, c_out, seq_len)\n        test_eq(h(t).shape, (bs, c_out))\n\ncreate_mlp_head\ncreate_fc_head\naverage_pool_head\nmax_pool_head\nconcat_pool_head\ncreate_pool_plus_head\ncreate_conv_head\ncreate_rnn_head\ncreate_conv_lin_nd_head\nlin_nd_head\ncreate_conv_3d_head\nattentional_pool_head\nuniversal_pool_head\ngwa_pool_head\n\n\n\nsource\n\n\nSqueezeExciteBlock\n\n SqueezeExciteBlock (ni, reduction=16)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 2\nni = 32\nsl = 4\nt = torch.rand(bs, ni, sl)\ntest_eq(SqueezeExciteBlock(ni)(t).shape, (bs, ni, sl))\n\n\nsource\n\n\nGaussianNoise\n\n GaussianNoise (sigma=0.1, is_relative_detach=True)\n\n*Gaussian noise regularizer.\nArgs: sigma (float, optional): relative standard deviation used to generate the noise. Relative means that it will be multiplied by the magnitude of the value your are adding the noise to. This means that sigma can be the same regardless of the scale of the vector. is_relative_detach (bool, optional): whether to detach the variable before computing the scale of the noise. If False then the scale of the noise won’t be seen as a constant but something to optimize: this will bias the network to generate vectors with smaller values.*\n\nt = torch.ones(2,3,4)\ntest_ne(GaussianNoise()(t), t)\ntest_eq(GaussianNoise()(t).shape, t.shape)\nt = torch.ones(2,3)\ntest_ne(GaussianNoise()(t), t)\ntest_eq(GaussianNoise()(t).shape, t.shape)\nt = torch.ones(2)\ntest_ne(GaussianNoise()(t), t)\ntest_eq(GaussianNoise()(t).shape, t.shape)\n\n\nsource\n\n\nTokenLayer\n\n TokenLayer (token=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nPositionwiseFeedForward\n\n PositionwiseFeedForward (dim, dropout=0.0, act='reglu', mlp_ratio=1)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nt = torch.randn(2,3,10)\nm = PositionwiseFeedForward(10, dropout=0., act='reglu', mlp_ratio=1)\ntest_eq(m(t).shape, t.shape)\nm = PositionwiseFeedForward(10, dropout=0., act='smelu', mlp_ratio=1)\ntest_eq(m(t).shape, t.shape)\n\n\nsource\n\n\nScaledDotProductAttention\n\n ScaledDotProductAttention (d_model, n_heads, attn_dropout=0.0,\n                            res_attention=False, lsa=False)\n\nScaled Dot-Product Attention module (Attention is all you need by Vaswani et al., 2017) with optional residual attention from previous layer (Realformer: Transformer likes residual attention by He et al, 2020) and locality self sttention (Vision Transformer for Small-Size Datasets by Lee et al, 2021)\n\nB = 16\nC = 10\nM = 1500 # seq_len\n\nn_heads = 1\nD = 128 # model dimension\nN = 512 # max_seq_len - latent's index dimension\nd_k = D // n_heads\n\nxb = torch.randn(B, C, M)\nxb = (xb - xb.mean()) / xb.std()\n\n# Attention\n# input (Q)\nlin = nn.Linear(M, N, bias=False)\nQ = lin(xb).transpose(1,2)\ntest_eq(Q.shape, (B, N, C))\n\n# q\nto_q = nn.Linear(C, D, bias=False)\nq = to_q(Q)\nq = nn.LayerNorm(D)(q)\n\n# k, v\ncontext = xb.transpose(1,2)\nto_kv = nn.Linear(C, D * 2, bias=False)\nk, v = to_kv(context).chunk(2, dim = -1)\nk = k.transpose(-1, -2)\nk = nn.LayerNorm(M)(k)\nv = nn.LayerNorm(D)(v)\n\ntest_eq(q.shape, (B, N, D))\ntest_eq(k.shape, (B, D, M))\ntest_eq(v.shape, (B, M, D))\n\noutput, attn, scores = ScaledDotProductAttention(D, n_heads, res_attention=True)(q.unsqueeze(1), k.unsqueeze(1), v.unsqueeze(1))\ntest_eq(output.shape, (B, 1, N, D))\ntest_eq(attn.shape, (B, 1, N, M))\ntest_eq(scores.shape, (B, 1, N, M))\nscores.mean(), scores.std()\n\n(tensor(-2.3159e-10, grad_fn=&lt;MeanBackward0&gt;),\n tensor(0.9743, grad_fn=&lt;StdBackward0&gt;))\n\n\n\nsource\n\n\nMultiheadAttention\n\n MultiheadAttention (d_model, n_heads, d_k=None, d_v=None,\n                     res_attention=False, attn_dropout=0.0,\n                     proj_dropout=0.0, qkv_bias=True, lsa=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nq = torch.rand([16, 3, 50, 8])\nk = torch.rand([16, 3, 50, 8]).transpose(-1, -2)\nv = torch.rand([16, 3, 50, 6])\nattn_mask = torch.triu(torch.ones(50, 50)) # shape: q_len x q_len\nkey_padding_mask = torch.zeros(16, 50)\nkey_padding_mask[[1, 3, 6, 15], -10:] = 1\nkey_padding_mask = key_padding_mask.bool()\nprint('attn_mask', attn_mask.shape, 'key_padding_mask', key_padding_mask.shape)\noutput, attn = ScaledDotProductAttention(24, 3, attn_dropout=.1)(q, k, v, attn_mask=attn_mask, key_padding_mask=key_padding_mask)\noutput.shape, attn.shape\n\nattn_mask torch.Size([50, 50]) key_padding_mask torch.Size([16, 50])\n\n\n(torch.Size([16, 3, 50, 6]), torch.Size([16, 3, 50, 50]))\n\n\n\nt = torch.rand(16, 50, 128)\noutput, attn = MultiheadAttention(d_model=128, n_heads=3, d_k=8, d_v=6)(t, t, t, key_padding_mask=key_padding_mask, attn_mask=attn_mask)\noutput.shape, attn.shape\n\n(torch.Size([16, 50, 128]), torch.Size([16, 3, 50, 50]))\n\n\nTest multi-head attention with self-locality attention\n\n# lsa (locality self-sttention)\nt = torch.rand(16, 50, 128)\nattn_mask = torch.eye(50).reshape(1, 1, 50, 50).bool()\noutput, attn = MultiheadAttention(d_model=128, n_heads=8, lsa=True)(t, t, t, key_padding_mask=key_padding_mask, attn_mask=attn_mask)\noutput.shape, attn.shape\n\n(torch.Size([16, 50, 128]), torch.Size([16, 8, 50, 50]))\n\n\n\nt = torch.rand(16, 50, 128)\natt_mask = (torch.rand((50, 50)) &gt; .85).float()\natt_mask[att_mask == 1] = -np.inf\n\nmha = MultiheadAttention(d_model=128, n_heads=3, d_k=8, d_v=6)\noutput, attn = mha(t, t, t, attn_mask=att_mask)\ntest_eq(torch.isnan(output).sum().item(), 0)\ntest_eq(torch.isnan(attn).sum().item(), 0)\nloss = output[:2, :].sum()\ntest_eq(torch.isnan(loss).sum().item(), 0)\nloss.backward()\nfor n, p in mha.named_parameters():\n    if p.grad is not None:\n        test_eq(torch.isnan(p.grad).sum().item(), 0)\n\n\nt = torch.rand(16, 50, 128)\nattn_mask = (torch.rand((50, 50)) &gt; .85)\n\n# True values will be masked\nmha = MultiheadAttention(d_model=128, n_heads=3, d_k=8, d_v=6)\noutput, attn = mha(t, t, t, attn_mask=att_mask)\ntest_eq(torch.isnan(output).sum().item(), 0)\ntest_eq(torch.isnan(attn).sum().item(), 0)\nloss = output[:2, :].sum()\ntest_eq(torch.isnan(loss).sum().item(), 0)\nloss.backward()\nfor n, p in mha.named_parameters():\n    if p.grad is not None:\n        test_eq(torch.isnan(p.grad).sum().item(), 0)\n\n\nsource\n\n\nMultiConv1d\n\n MultiConv1d (ni, nf=None, kss=[1, 3, 5, 7], keep_original=False,\n              separable=False, dim=1, **kwargs)\n\nModule that applies multiple convolutions with different kernel sizes\n\nt = torch.rand(16, 6, 37)\ntest_eq(MultiConv1d(6, None, kss=[1,3,5], keep_original=True)(t).shape, [16, 24, 37])\ntest_eq(MultiConv1d(6, 36, kss=[1,3,5], keep_original=False)(t).shape, [16, 36, 37])\ntest_eq(MultiConv1d(6, None, kss=[1,3,5], keep_original=True, dim=-1)(t).shape, [16, 6, 37*4])\ntest_eq(MultiConv1d(6, 60, kss=[1,3,5], keep_original=True)(t).shape, [16, 60, 37])\ntest_eq(MultiConv1d(6, 60, kss=[1,3,5], separable=True)(t).shape, [16, 60, 37])\n\n\nsource\n\n\nLSTMOutput\n\n LSTMOutput ()\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nt = ([1], [2], [3])\ntest_eq(LSTMOutput()(t), [1])\n\n\nsource\n\n\nemb_sz_rule\n\n emb_sz_rule (n_cat)\n\nRule of thumb to pick embedding size corresponding to n_cat (original from fastai)\n\ntest_eq(emb_sz_rule(7), 5)\n\n\nsource\n\n\nTSEmbedding\n\n TSEmbedding (ni, nf, std=0.01, padding_idx=None)\n\nEmbedding layer with truncated normal initialization adapted from fastai\n\nsource\n\n\nMultiEmbedding\n\n MultiEmbedding (c_in, n_cat_embeds, cat_embed_dims=None, cat_pos=None,\n                 std=0.01, cat_padding_idxs=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\na = alphabet[np.random.randint(0,3,40)]\nb = ALPHABET[np.random.randint(6,10,40)]\nc = np.random.rand(40).reshape(4,1,10)\nmap_a = {k:v for v,k in enumerate(np.unique(a))}\nmap_b = {k:v for v,k in enumerate(np.unique(b))}\nn_embeds = [len(m.keys()) for m in [map_a, map_b]]\nszs = [emb_sz_rule(n) for n in n_embeds]\na = np.asarray(a.map(map_a)).reshape(4,1,10)\nb = np.asarray(b.map(map_b)).reshape(4,1,10)\ninp = torch.from_numpy(np.concatenate((c,a,b), 1)).float()\nmemb = MultiEmbedding(3, n_embeds, cat_pos=[1,2])\n# registered buffers are part of the state_dict() but not module.parameters()\nassert all([(k in memb.state_dict().keys()) for k in ['cat_pos', 'cont_pos']])\nembeddings = memb(inp)\nprint(n_embeds, szs, inp.shape, embeddings.shape)\ntest_eq(embeddings.shape, (inp.shape[0],sum(szs)+1,inp.shape[-1]))\n\n[3, 4] [3, 3] torch.Size([4, 3, 10]) torch.Size([4, 7, 10])\n\n\n\nme = MultiEmbedding(3, 4, cat_pos=2)\ntest_eq(me.cat_embed[0].weight.shape, (4,3))\ntest_eq(me.cat_pos.cpu().item(), 2)",
    "crumbs": [
      "Models",
      "Layers"
    ]
  },
  {
    "objectID": "models.resnet.html",
    "href": "models.resnet.html",
    "title": "ResNet",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\nResNet\n\n ResNet (c_in, c_out)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nResBlock\n\n ResBlock (ni, nf, kss=[7, 5, 3])\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nxb = torch.rand(2, 3, 4)\ntest_eq(ResNet(3,2)(xb).shape, [xb.shape[0], 2])\ntest_eq(count_parameters(ResNet(3, 2)), 479490) # for (3,2)\n\n\nResNet(3,2)\n\nResNet(\n  (resblock1): ResBlock(\n    (convblock1): ConvBlock(\n      (0): Conv1d(3, 64, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n      (1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock2): ConvBlock(\n      (0): Conv1d(64, 64, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n      (1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock3): ConvBlock(\n      (0): Conv1d(64, 64, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n      (1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (shortcut): ConvBlock(\n      (0): Conv1d(3, 64, kernel_size=(1,), stride=(1,), bias=False)\n      (1): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (add): Add\n    (act): ReLU()\n  )\n  (resblock2): ResBlock(\n    (convblock1): ConvBlock(\n      (0): Conv1d(64, 128, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock2): ConvBlock(\n      (0): Conv1d(128, 128, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock3): ConvBlock(\n      (0): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (shortcut): ConvBlock(\n      (0): Conv1d(64, 128, kernel_size=(1,), stride=(1,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (add): Add\n    (act): ReLU()\n  )\n  (resblock3): ResBlock(\n    (convblock1): ConvBlock(\n      (0): Conv1d(128, 128, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock2): ConvBlock(\n      (0): Conv1d(128, 128, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock3): ConvBlock(\n      (0): Conv1d(128, 128, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (shortcut): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (add): Add\n    (act): ReLU()\n  )\n  (gap): AdaptiveAvgPool1d(output_size=1)\n  (squeeze): Squeeze(dim=-1)\n  (fc): Linear(in_features=128, out_features=2, bias=True)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "ResNet"
    ]
  },
  {
    "objectID": "models.tstplus.html",
    "href": "models.tstplus.html",
    "title": "TSTPlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza of - oguiza@timeseriesAI.co based on:\nThis implementation is adapted to work with the rest of the tsai library, and contain some hyperparameters that are not available in the original implementation. I included them for experimenting.",
    "crumbs": [
      "Models",
      "Transformers",
      "TSTPlus"
    ]
  },
  {
    "objectID": "models.tstplus.html#imports",
    "href": "models.tstplus.html#imports",
    "title": "TSTPlus",
    "section": "Imports",
    "text": "Imports",
    "crumbs": [
      "Models",
      "Transformers",
      "TSTPlus"
    ]
  },
  {
    "objectID": "models.tstplus.html#tst",
    "href": "models.tstplus.html#tst",
    "title": "TSTPlus",
    "section": "TST",
    "text": "TST\n\nt = torch.rand(16, 50, 128)\nattn_mask = torch.triu(torch.ones(50, 50)) # shape: q_len x q_len\nkey_padding_mask = torch.zeros(16, 50)\nkey_padding_mask[[1, 3, 6, 15], -10:] = 1\nkey_padding_mask = key_padding_mask.bool()\nprint('attn_mask', attn_mask.shape, 'key_padding_mask', key_padding_mask.shape)\nencoder = _TSTEncoderLayer(q_len=50, d_model=128, n_heads=8, d_k=None, d_v=None, d_ff=512, attn_dropout=0., dropout=0.1, store_attn=True, activation='gelu')\noutput = encoder(t, key_padding_mask=key_padding_mask, attn_mask=attn_mask)\noutput.shape\n\nattn_mask torch.Size([50, 50]) key_padding_mask torch.Size([16, 50])\n\n\ntorch.Size([16, 50, 128])\n\n\n\ncmap='viridis'\nfigsize=(6,5)\nplt.figure(figsize=figsize)\nplt.pcolormesh(encoder.attn[0][0].detach().cpu().numpy(), cmap=cmap)\nplt.title('Self-attention map')\nplt.colorbar()\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\nTSTPlus\n\n TSTPlus (c_in:int, c_out:int, seq_len:int, max_seq_len:Optional[int]=512,\n          n_layers:int=3, d_model:int=128, n_heads:int=16,\n          d_k:Optional[int]=None, d_v:Optional[int]=None, d_ff:int=256,\n          norm:str='BatchNorm', attn_dropout:float=0.0, dropout:float=0.0,\n          act:str='gelu', key_padding_mask:bool='auto',\n          padding_var:Optional[int]=None,\n          attn_mask:Optional[torch.Tensor]=None, res_attention:bool=True,\n          pre_norm:bool=False, store_attn:bool=False, pe:str='zeros',\n          learn_pe:bool=True, flatten:bool=True, fc_dropout:float=0.0,\n          concat_pool:bool=False, bn:bool=False,\n          custom_head:Optional[Callable]=None,\n          y_range:Optional[tuple]=None, verbose:bool=False, **kwargs)\n\nTST (Time Series Transformer) is a Transformer that takes continuous time series as inputs\n\nfrom tsai.models.utils import build_ts_model\n\n\nbs = 8\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 1_500\n\nxb = torch.randn(bs, c_in, seq_len).to(device)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nmax_seq_len = 256\nd_model = 128\nn_heads = 16\nd_k = d_v = None  # if None --&gt; d_model // n_heads\nd_ff = 256\nnorm = \"BatchNorm\"\ndropout = 0.1\nactivation = \"gelu\"\nn_layers = 3\nfc_dropout = 0.1\npe = None\nlearn_pe = True\nkwargs = {}\n\nmodel = TSTPlus(c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n                d_k=d_k, d_v=d_v, d_ff=d_ff, norm=norm, dropout=dropout, activation=activation, n_layers=n_layers,\n                fc_dropout=fc_dropout, pe=pe, learn_pe=learn_pe, **kwargs).to(device)\ntest_eq(model(xb).shape, [bs, c_out])\ntest_eq(model[0], model.backbone)\ntest_eq(model[1], model.head)\nmodel2 = build_ts_model(TSTPlus, c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n                           d_k=d_k, d_v=d_v, d_ff=d_ff, norm=norm, dropout=dropout, activation=activation, n_layers=n_layers,\n                           fc_dropout=fc_dropout, pe=pe, learn_pe=learn_pe, **kwargs).to(device)\ntest_eq(model2(xb).shape, [bs, c_out])\ntest_eq(model2[0], model2.backbone)\ntest_eq(model2[1], model2.head)\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 470018\n\n\n\nkey_padding_mask = torch.sort(torch.randint(0, 2, (bs, max_seq_len))).values.bool().to(device)\nkey_padding_mask[0]\n\ntensor([False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False, False, False, False, False, False,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         True,  True,  True,  True,  True,  True])\n\n\n\nmodel2.key_padding_mask = True\nmodel2.to(device)((xb, key_padding_mask)).shape\n\ntorch.Size([8, 2])\n\n\n\nmodel.head\n\nSequential(\n  (0): GELU(approximate='none')\n  (1): fastai.layers.Flatten(full=False)\n  (2): LinBnDrop(\n    (0): Dropout(p=0.1, inplace=False)\n    (1): Linear(in_features=32768, out_features=2, bias=True)\n  )\n)\n\n\n\nmodel = TSTPlus(c_in, c_out, seq_len, pre_norm=True)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\n\n\nbs = 8\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 5000\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\nmodel = TSTPlus(c_in, c_out, seq_len, res_attention=True)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 605698\n\n\n\ncustom_head = partial(create_pool_head, concat_pool=True)\nmodel = TSTPlus(c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, dropout=dropout, activation=activation, n_layers=n_layers,\n            fc_dropout=fc_dropout, pe=pe, learn_pe=learn_pe, flatten=False, custom_head=custom_head, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 421122\n\n\n\ncustom_head = partial(create_pool_plus_head, concat_pool=True)\nmodel = TSTPlus(c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, dropout=dropout, activation=activation, n_layers=n_layers,\n            fc_dropout=fc_dropout, pe=pe, learn_pe=learn_pe, flatten=False, custom_head=custom_head, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 554240\n\n\n\nbs = 8\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 60\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nmax_seq_len = 120\nd_model = 128\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\ndropout = 0.1\nact = \"gelu\"\nn_layers = 3\nfc_dropout = 0.1\npe='zeros'\nlearn_pe=True\nkwargs = {}\n# kwargs = dict(kernel_size=5, padding=2)\n\nmodel = TSTPlus(c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, dropout=dropout, act=act, n_layers=n_layers,\n            fc_dropout=fc_dropout, pe=pe, learn_pe=learn_pe, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\nbody, head = model[0], model[1]\ntest_eq(body.to(xb.device)(xb).ndim, 3)\ntest_eq(head.to(xb.device)(body.to(xb.device)(xb)).ndim, 2)\nhead\n\nmodel parameters: 421762\n\n\nSequential(\n  (0): GELU(approximate='none')\n  (1): fastai.layers.Flatten(full=False)\n  (2): LinBnDrop(\n    (0): Dropout(p=0.1, inplace=False)\n    (1): Linear(in_features=7680, out_features=2, bias=True)\n  )\n)\n\n\n\nmodel.show_pe()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel = TSTPlus(3, 2, 10)\nxb = torch.randn(4, 3, 10)\nyb = torch.randint(0, 2, (4,))\ntest_eq(model.backbone._key_padding_mask(xb)[1], None)\nrandom_idxs = random_choice(len(xb), 2, False)\nxb[random_idxs, :, -5:] = np.nan\nxb[random_idxs, 0, 1] = np.nan\ntest_eq(model.backbone._key_padding_mask(xb.clone())[1].data, (torch.isnan(xb).float().mean(1)==1).bool())\ntest_eq(model.backbone._key_padding_mask(xb.clone())[1].data.shape, (4,10))\nprint(torch.isnan(xb).sum())\npred = model.to(xb.device)(xb.clone())\nloss = CrossEntropyLossFlat()(pred, yb)\nloss.backward()\nmodel.to(xb.device).backbone._key_padding_mask(xb)[1].data.shape\n\ntensor(32)\n\n\ntorch.Size([4, 10])\n\n\n\nbs = 4\nc_in = 3\nseq_len = 10\nc_out = 2\nxb = torch.randn(bs, c_in, seq_len)\nxb[:, -1] = torch.randint(0, 2, (bs, seq_len)).sort()[0]\nmodel = TSTPlus(c_in, c_out, seq_len).to(xb.device)\ntest_eq(model.backbone._key_padding_mask(xb)[1], None)\nmodel = TSTPlus(c_in, c_out, seq_len, padding_var=-1).to(xb.device)\ntest_eq(model.backbone._key_padding_mask(xb)[1], (xb[:, -1]==1))\nmodel = TSTPlus(c_in, c_out, seq_len, padding_var=2).to(xb.device)\ntest_eq(model.backbone._key_padding_mask(xb)[1], (xb[:, -1]==1))\ntest_eq(model(xb).shape, (bs, c_out))\n\n\nbs = 4\nc_in = 3\nseq_len = 10\nc_out = 2\nxb = torch.randn(bs, c_in, seq_len)\nmodel = TSTPlus(c_in, c_out, seq_len, act='smelu')\n\n\nsource\n\n\nMultiTSTPlus\n\n MultiTSTPlus (feat_list, c_out, seq_len, max_seq_len:Optional[int]=512,\n               custom_head=None, n_layers:int=3, d_model:int=128,\n               n_heads:int=16, d_k:Optional[int]=None,\n               d_v:Optional[int]=None, d_ff:int=256, norm:str='BatchNorm',\n               attn_dropout:float=0.0, dropout:float=0.0, act:str='gelu',\n               key_padding_mask:bool='auto',\n               padding_var:Optional[int]=None,\n               attn_mask:Optional[torch.Tensor]=None,\n               res_attention:bool=True, pre_norm:bool=False,\n               store_attn:bool=False, pe:str='zeros', learn_pe:bool=True,\n               flatten:bool=True, fc_dropout:float=0.0,\n               concat_pool:bool=False, bn:bool=False,\n               y_range:Optional[tuple]=None, verbose:bool=False)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nbs = 8\nc_in = 7  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 10\nxb2 = torch.randn(bs, c_in, seq_len)\nmodel1 = MultiTSTPlus([2, 5], c_out, seq_len)\nmodel2 = MultiTSTPlus(7, c_out, seq_len)\ntest_eq(model1.to(xb2.device)(xb2).shape, (bs, c_out))\ntest_eq(model1.to(xb2.device)(xb2).shape, model2.to(xb2.device)(xb2).shape)\ntest_eq(count_parameters(model1) &gt; count_parameters(model2), True)\n\n\nbs = 8\nc_in = 7  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 10\nxb2 = torch.randn(bs, c_in, seq_len)\nmodel1 = MultiTSTPlus([2, 5], c_out, seq_len, )\nmodel2 = MultiTSTPlus([[0,2,5], [0,1,3,4,6]], c_out, seq_len)\ntest_eq(model1.to(xb2.device)(xb2).shape, (bs, c_out))\ntest_eq(model1.to(xb2.device)(xb2).shape, model2.to(xb2.device)(xb2).shape)\n\n\nmodel1 = MultiTSTPlus([2, 5], c_out, seq_len, y_range=(0.5, 5.5))\nbody, head = split_model(model1)\ntest_eq(body.to(xb2.device)(xb2).ndim, 3)\ntest_eq(head.to(xb2.device)(body.to(xb2.device)(xb2)).ndim, 2)\nhead\n\nSequential(\n  (0): Sequential(\n    (0): GELU(approximate='none')\n    (1): fastai.layers.Flatten(full=False)\n    (2): LinBnDrop(\n      (0): Linear(in_features=2560, out_features=2, bias=True)\n    )\n  )\n)\n\n\n\nmodel = MultiTSTPlus([2, 5], c_out, seq_len, pre_norm=True)\n\n\nbs = 8\nn_vars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\nnet = MultiTSTPlus(n_vars, c_out, seq_len)\nchange_model_head(net, create_pool_plus_head, concat_pool=False)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([8, 2])\n\n\nSequential(\n  (0): AdaptiveAvgPool1d(output_size=1)\n  (1): Reshape(bs)\n  (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (3): Linear(in_features=128, out_features=512, bias=False)\n  (4): ReLU(inplace=True)\n  (5): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (6): Linear(in_features=512, out_features=2, bias=False)\n)\n\n\n\nbs = 8\nn_vars = 3\nseq_len = 12\nc_out = 10\nxb = torch.rand(bs, n_vars, seq_len)\nnew_head = partial(conv_lin_nd_head, d=(5 ,2))\nnet = MultiTSTPlus(n_vars, c_out, seq_len, custom_head=new_head)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([8, 5, 2, 10])\n\n\nSequential(\n  (0): create_conv_lin_nd_head(\n    (0): Conv1d(128, 10, kernel_size=(1,), stride=(1,))\n    (1): Linear(in_features=12, out_features=10, bias=True)\n    (2): Transpose(-1, -2)\n    (3): Reshape(bs, 5, 2, 10)\n  )\n)",
    "crumbs": [
      "Models",
      "Transformers",
      "TSTPlus"
    ]
  },
  {
    "objectID": "models.inceptiontime.html",
    "href": "models.inceptiontime.html",
    "title": "InceptionTime",
    "section": "",
    "text": "An ensemble of deep Convolutional Neural Network (CNN) models, inspired by the Inception-v4 architecture\n\nThis is an unofficial PyTorch implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on:\nFawaz, H. I., Lucas, B., Forestier, G., Pelletier, C., Schmidt, D. F., Weber, J. & Petitjean, F. (2019). InceptionTime: Finding AlexNet for Time Series Classification. arXiv preprint arXiv:1909.04939.\nOfficial InceptionTime tensorflow implementation: https://github.com/hfawaz/InceptionTime\n\nsource\n\nInceptionTime\n\n InceptionTime (c_in, c_out, seq_len=None, nf=32, nb_filters=None, ks=40,\n                bottleneck=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nInceptionBlock\n\n InceptionBlock (ni, nf=32, residual=True, depth=6, ks=40,\n                 bottleneck=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nInceptionModule\n\n InceptionModule (ni, nf, ks=40, bottleneck=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.models.utils import count_parameters\n\n\nbs = 16\nvars = 1\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, vars, seq_len)\ntest_eq(InceptionTime(vars,c_out)(xb).shape, [bs, c_out])\ntest_eq(InceptionTime(vars,c_out, bottleneck=False)(xb).shape, [bs, c_out])\ntest_eq(InceptionTime(vars,c_out, residual=False)(xb).shape, [bs, c_out])\ntest_eq(count_parameters(InceptionTime(3, 2)), 455490)\n\n\nInceptionTime(3,2)\n\nInceptionTime(\n  (inceptionblock): InceptionBlock(\n    (inception): ModuleList(\n      (0): InceptionModule(\n        (bottleneck): Conv1d(3, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), bias=False)\n          (1): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), bias=False)\n          (2): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), bias=False)\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(3, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n        (bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (act): ReLU()\n      )\n      (1): InceptionModule(\n        (bottleneck): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), bias=False)\n          (1): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), bias=False)\n          (2): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), bias=False)\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n        (bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (act): ReLU()\n      )\n      (2): InceptionModule(\n        (bottleneck): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), bias=False)\n          (1): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), bias=False)\n          (2): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), bias=False)\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n        (bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (act): ReLU()\n      )\n      (3): InceptionModule(\n        (bottleneck): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), bias=False)\n          (1): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), bias=False)\n          (2): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), bias=False)\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n        (bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (act): ReLU()\n      )\n      (4): InceptionModule(\n        (bottleneck): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), bias=False)\n          (1): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), bias=False)\n          (2): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), bias=False)\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n        (bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (act): ReLU()\n      )\n      (5): InceptionModule(\n        (bottleneck): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), bias=False)\n          (1): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), bias=False)\n          (2): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), bias=False)\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(128, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n        (bn): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (act): ReLU()\n      )\n    )\n    (shortcut): ModuleList(\n      (0): ConvBlock(\n        (0): Conv1d(3, 128, kernel_size=(1,), stride=(1,), bias=False)\n        (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (add): Add\n    (act): ReLU()\n  )\n  (gap): GAP1d(\n    (gap): AdaptiveAvgPool1d(output_size=1)\n    (flatten): Flatten(full=False)\n  )\n  (fc): Linear(in_features=128, out_features=2, bias=True)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "InceptionTime"
    ]
  },
  {
    "objectID": "data.tabular.html",
    "href": "data.tabular.html",
    "title": "Time Series Tabular Data",
    "section": "",
    "text": "Main Tabular functions used throughout the library. This is helpful when you have additional time series data like metadata, time series features, etc.\n\n\nsource\n\nget_tabular_ds\n\n get_tabular_ds (df, procs=[&lt;class 'fastai.tabular.core.Categorify'&gt;,\n                 &lt;class 'fastai.tabular.core.FillMissing'&gt;, &lt;class\n                 'fastai.data.transforms.Normalize'&gt;], cat_names=None,\n                 cont_names=None, y_names=None, groupby=None,\n                 y_block=None, splits=None, do_setup=True, inplace=False,\n                 reduce_memory=True, device=None)\n\n\nsource\n\n\nget_tabular_dls\n\n get_tabular_dls (df, procs=[&lt;class 'fastai.tabular.core.Categorify'&gt;,\n                  &lt;class 'fastai.tabular.core.FillMissing'&gt;, &lt;class\n                  'fastai.data.transforms.Normalize'&gt;], cat_names=None,\n                  cont_names=None, y_names=None, bs=64, y_block=None,\n                  splits=None, do_setup=True, inplace=False,\n                  reduce_memory=True, device=None, path:str|Path='.')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\n\n\n\nprocs\nlist\n[&lt;class ‘fastai.tabular.core.Categorify’&gt;, &lt;class ‘fastai.tabular.core.FillMissing’&gt;, &lt;class ‘fastai.data.transforms.Normalize’&gt;]\n\n\n\ncat_names\nNoneType\nNone\n\n\n\ncont_names\nNoneType\nNone\n\n\n\ny_names\nNoneType\nNone\n\n\n\nbs\nint\n64\n\n\n\ny_block\nNoneType\nNone\n\n\n\nsplits\nNoneType\nNone\n\n\n\ndo_setup\nbool\nTrue\n\n\n\ninplace\nbool\nFalse\n\n\n\nreduce_memory\nbool\nTrue\n\n\n\ndevice\nNoneType\nNone\nDevice to put DataLoaders\n\n\npath\nstr | pathlib.Path\n.\nPath to store export objects\n\n\n\n\nsource\n\n\npreprocess_df\n\n preprocess_df (df, procs=[&lt;class 'fastai.tabular.core.Categorify'&gt;,\n                &lt;class 'fastai.tabular.core.FillMissing'&gt;, &lt;class\n                'fastai.data.transforms.Normalize'&gt;], cat_names=None,\n                cont_names=None, y_names=None, sample_col=None,\n                reduce_memory=True)\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\n# df['salary'] = np.random.rand(len(df)) # uncomment to simulate a cont dependent variable\n\ncat_names = ['workclass', 'education', 'education-num', 'marital-status', 'occupation', 'relationship', 'race', 'sex',\n             'capital-gain', 'capital-loss', 'native-country']\ncont_names = ['age', 'fnlwgt', 'hours-per-week']\ntarget = ['salary']\nsplits = RandomSplitter()(range_of(df))\n\ndls = get_tabular_dls(df, cat_names=cat_names, cont_names=cont_names, y_names='salary', splits=splits, bs=512, device=device)\ndls.show_batch()\n\n\n\n\n\nworkclass\neducation\neducation-num\nmarital-status\noccupation\nrelationship\nrace\nsex\ncapital-gain\ncapital-loss\nnative-country\nage\nfnlwgt\nhours-per-week\nsalary\n\n\n\n\n0\nPrivate\nSome-college\n10.0\nDivorced\nExec-managerial\nNot-in-family\nWhite\nMale\n0\n0\nUnited-States\n48.000000\n190072.000005\n50.000000\n&gt;=50k\n\n\n1\nSelf-emp-not-inc\nSome-college\n10.0\nMarried-civ-spouse\nSales\nHusband\nWhite\nMale\n0\n0\nUnited-States\n72.000001\n284120.002964\n40.000000\n&lt;50k\n\n\n2\nPrivate\nSome-college\n10.0\nMarried-civ-spouse\nProtective-serv\nHusband\nBlack\nMale\n0\n0\nUnited-States\n72.000001\n53684.002497\n40.000000\n&lt;50k\n\n\n3\nSelf-emp-inc\nSome-college\n10.0\nMarried-civ-spouse\nFarming-fishing\nHusband\nWhite\nMale\n0\n0\nUnited-States\n47.000000\n337049.998875\n40.000000\n&lt;50k\n\n\n4\nPrivate\nHS-grad\n9.0\nDivorced\nCraft-repair\nNot-in-family\nWhite\nMale\n0\n0\nUnited-States\n46.000000\n207677.000707\n30.000000\n&lt;50k\n\n\n5\nPrivate\n5th-6th\n3.0\nDivorced\nPriv-house-serv\nUnmarried\nWhite\nFemale\n0\n0\nMexico\n45.000000\n265082.999142\n35.000000\n&lt;50k\n\n\n6\nPrivate\nAssoc-acdm\n12.0\nNever-married\nOther-service\nNot-in-family\nWhite\nFemale\n0\n0\nUnited-States\n28.000000\n150296.001328\n79.999999\n&lt;50k\n\n\n7\nPrivate\nHS-grad\n9.0\nMarried-civ-spouse\nExec-managerial\nHusband\nWhite\nMale\n0\n0\nUnited-States\n50.000000\n94080.999353\n40.000000\n&gt;=50k\n\n\n8\nPrivate\nAssoc-voc\n11.0\nMarried-civ-spouse\nExec-managerial\nHusband\nWhite\nMale\n0\n0\nGermany\n58.000000\n235624.000302\n40.000000\n&gt;=50k\n\n\n9\nPrivate\nHS-grad\n9.0\nNever-married\nOther-service\nUnmarried\nBlack\nFemale\n0\n0\nJapan\n29.000000\n419721.008996\n40.000000\n&lt;50k\n\n\n\n\n\n\nmetrics = mae if dls.c == 1 else accuracy\nlearn = tabular_learner(dls, layers=[200, 100], y_range=None, metrics=metrics)\nlearn.fit(1, 1e-2)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.349525\n0.288922\n0.866093\n00:05\n\n\n\n\n\n\nlearn.dls.one_batch()\n\n(tensor([[  5,  12,   9,  ...,   1,   1,  21],\n         [  1,  10,  13,  ...,   1,   1,   3],\n         [  5,   4,   2,  ...,   1,   1,   6],\n         ...,\n         [  5,   6,   4,  ...,   1,   1,  40],\n         [  3,  10,  13,  ...,   1,   1,  40],\n         [  5,  12,   9,  ..., 116,   1,  40]]),\n tensor([[-0.2593,  0.1234,  1.1829],\n         [-0.9913, -1.4041, -0.0347],\n         [-0.1129,  0.4583, -0.0347],\n         ...,\n         [-1.5769, -0.1989,  0.3712],\n         [ 0.4727, -1.4400,  0.3712],\n         [ 1.5708, -0.2222, -0.0347]]),\n tensor([[1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [1],\n         [1],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [1],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [1],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [0],\n         [0],\n         [1],\n         [0],\n         [0],\n         [1],\n         [1]], dtype=torch.int8))\n\n\n\nlearn.model\n\nTabularModel(\n  (embeds): ModuleList(\n    (0): Embedding(10, 6)\n    (1): Embedding(17, 8)\n    (2): Embedding(17, 8)\n    (3): Embedding(8, 5)\n    (4): Embedding(16, 8)\n    (5): Embedding(7, 5)\n    (6): Embedding(6, 4)\n    (7): Embedding(3, 3)\n    (8): Embedding(117, 23)\n    (9): Embedding(90, 20)\n    (10): Embedding(43, 13)\n  )\n  (emb_drop): Dropout(p=0.0, inplace=False)\n  (bn_cont): BatchNorm1d(3, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (layers): Sequential(\n    (0): LinBnDrop(\n      (0): Linear(in_features=106, out_features=200, bias=False)\n      (1): ReLU(inplace=True)\n      (2): BatchNorm1d(200, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (1): LinBnDrop(\n      (0): Linear(in_features=200, out_features=100, bias=False)\n      (1): ReLU(inplace=True)\n      (2): BatchNorm1d(100, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (2): LinBnDrop(\n      (0): Linear(in_features=100, out_features=2, bias=True)\n    )\n  )\n)\n\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\ncat_names = ['workclass', 'education', 'education-num', 'marital-status', 'occupation', 'relationship', 'race', 'sex',\n             'capital-gain', 'capital-loss', 'native-country']\ncont_names = ['age', 'fnlwgt', 'hours-per-week']\ntarget = ['salary']\ndf, procs = preprocess_df(df, procs=[Categorify, FillMissing, Normalize], cat_names=cat_names, cont_names=cont_names, y_names=target, \n                          sample_col=None, reduce_memory=True)\ndf.head()\n\n\n\n\n\n\n\n\nworkclass\neducation\neducation-num\nmarital-status\noccupation\nrelationship\nrace\nsex\ncapital-gain\ncapital-loss\nnative-country\nage\nfnlwgt\nhours-per-week\nsalary\n\n\n\n\n0\n5\n8\n12\n3\n0\n6\n5\n1\n1\n48\n40\n0.763796\n-0.838084\n-0.035429\n1\n\n\n1\n5\n13\n14\n1\n5\n2\n5\n2\n101\n1\n40\n0.397233\n0.444987\n0.369519\n1\n\n\n2\n5\n12\n0\n1\n0\n5\n3\n1\n1\n1\n40\n-0.042642\n-0.886734\n-0.683348\n0\n\n\n3\n6\n15\n15\n3\n11\n1\n2\n2\n1\n1\n40\n-0.042642\n-0.728873\n-0.035429\n1\n\n\n4\n7\n6\n0\n3\n9\n6\n3\n1\n1\n1\n40\n0.250608\n-1.018314\n0.774468\n0\n\n\n\n\n\n\n\n\nprocs.classes, procs.means, procs.stds\n\n({'workclass': ['#na#', ' ?', ' Federal-gov', ' Local-gov', ' Never-worked', ' Private', ' Self-emp-inc', ' Self-emp-not-inc', ' State-gov', ' Without-pay'],\n  'education': ['#na#', ' 10th', ' 11th', ' 12th', ' 1st-4th', ' 5th-6th', ' 7th-8th', ' 9th', ' Assoc-acdm', ' Assoc-voc', ' Bachelors', ' Doctorate', ' HS-grad', ' Masters', ' Preschool', ' Prof-school', ' Some-college'],\n  'education-num': ['#na#', 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0],\n  'marital-status': ['#na#', ' Divorced', ' Married-AF-spouse', ' Married-civ-spouse', ' Married-spouse-absent', ' Never-married', ' Separated', ' Widowed'],\n  'occupation': ['#na#', ' ?', ' Adm-clerical', ' Armed-Forces', ' Craft-repair', ' Exec-managerial', ' Farming-fishing', ' Handlers-cleaners', ' Machine-op-inspct', ' Other-service', ' Priv-house-serv', ' Prof-specialty', ' Protective-serv', ' Sales', ' Tech-support', ' Transport-moving'],\n  'relationship': ['#na#', ' Husband', ' Not-in-family', ' Other-relative', ' Own-child', ' Unmarried', ' Wife'],\n  'race': ['#na#', ' Amer-Indian-Eskimo', ' Asian-Pac-Islander', ' Black', ' Other', ' White'],\n  'sex': ['#na#', ' Female', ' Male'],\n  'capital-gain': ['#na#', 0, 114, 401, 594, 914, 991, 1055, 1086, 1111, 1151, 1173, 1409, 1424, 1455, 1471, 1506, 1639, 1797, 1831, 1848, 2009, 2036, 2050, 2062, 2105, 2174, 2176, 2202, 2228, 2290, 2329, 2346, 2354, 2387, 2407, 2414, 2463, 2538, 2580, 2597, 2635, 2653, 2829, 2885, 2907, 2936, 2961, 2964, 2977, 2993, 3103, 3137, 3273, 3325, 3411, 3418, 3432, 3456, 3464, 3471, 3674, 3781, 3818, 3887, 3908, 3942, 4064, 4101, 4386, 4416, 4508, 4650, 4687, 4787, 4865, 4931, 4934, 5013, 5060, 5178, 5455, 5556, 5721, 6097, 6360, 6418, 6497, 6514, 6723, 6767, 6849, 7298, 7430, 7443, 7688, 7896, 7978, 8614, 9386, 9562, 10520, 10566, 10605, 11678, 13550, 14084, 14344, 15020, 15024, 15831, 18481, 20051, 22040, 25124, 25236, 27828, 34095, 41310, 99999],\n  'capital-loss': ['#na#', 0, 155, 213, 323, 419, 625, 653, 810, 880, 974, 1092, 1138, 1258, 1340, 1380, 1408, 1411, 1485, 1504, 1539, 1564, 1573, 1579, 1590, 1594, 1602, 1617, 1628, 1648, 1651, 1668, 1669, 1672, 1719, 1721, 1726, 1735, 1740, 1741, 1755, 1762, 1816, 1825, 1844, 1848, 1876, 1887, 1902, 1944, 1974, 1977, 1980, 2001, 2002, 2042, 2051, 2057, 2080, 2129, 2149, 2163, 2174, 2179, 2201, 2205, 2206, 2231, 2238, 2246, 2258, 2267, 2282, 2339, 2352, 2377, 2392, 2415, 2444, 2457, 2467, 2472, 2489, 2547, 2559, 2603, 2754, 2824, 3004, 3683, 3770, 3900, 4356],\n  'native-country': ['#na#', ' ?', ' Cambodia', ' Canada', ' China', ' Columbia', ' Cuba', ' Dominican-Republic', ' Ecuador', ' El-Salvador', ' England', ' France', ' Germany', ' Greece', ' Guatemala', ' Haiti', ' Holand-Netherlands', ' Honduras', ' Hong', ' Hungary', ' India', ' Iran', ' Ireland', ' Italy', ' Jamaica', ' Japan', ' Laos', ' Mexico', ' Nicaragua', ' Outlying-US(Guam-USVI-etc)', ' Peru', ' Philippines', ' Poland', ' Portugal', ' Puerto-Rico', ' Scotland', ' South', ' Taiwan', ' Thailand', ' Trinadad&Tobago', ' United-States', ' Vietnam', ' Yugoslavia']},\n {'age': 38.58164675532078,\n  'fnlwgt': 189778.36651208502,\n  'hours-per-week': 40.437455852092995},\n {'age': 13.640223192304274,\n  'fnlwgt': 105548.3568809908,\n  'hours-per-week': 12.347239175707989})",
    "crumbs": [
      "Data",
      "Time Series Tabular Data"
    ]
  },
  {
    "objectID": "models.fcn.html",
    "href": "models.fcn.html",
    "title": "FCN",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on:\n\nWang, Z., Yan, W., & Oates, T. (2017, May). Time series classification from scratch with deep neural networks: A strong baseline. In 2017 international joint conference on neural networks (IJCNN) (pp. 1578-1585). IEEE.\nFawaz, H. I., Forestier, G., Weber, J., Idoumghar, L., & Muller, P. A. (2019). Deep learning for time series classification: a review. Data Mining and Knowledge Discovery, 33(4), 917-963.\n\nOfficial FCN TensorFlow implementation: https://github.com/hfawaz/dl-4-tsc/blob/master/classifiers/fcn.py.\nNote: kernel filter size 8 has been replaced by 7 (since we believe it’s a bug).\n\nsource\n\nFCN\n\n FCN (c_in, c_out, layers=[128, 256, 128], kss=[7, 5, 3])\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nnvars = 3\nseq_len = 128\nc_out = 2\nxb = torch.rand(bs, nvars, seq_len)\nmodel = FCN(nvars, c_out)\ntest_eq(model(xb).shape, (bs, c_out))\nmodel\n\nFCN(\n  (convblock1): ConvBlock(\n    (0): Conv1d(3, 128, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n    (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (convblock2): ConvBlock(\n    (0): Conv1d(128, 256, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n    (1): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (convblock3): ConvBlock(\n    (0): Conv1d(256, 128, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n    (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (gap): GAP1d(\n    (gap): AdaptiveAvgPool1d(output_size=1)\n    (flatten): Flatten(full=False)\n  )\n  (fc): Linear(in_features=128, out_features=2, bias=True)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "FCN"
    ]
  },
  {
    "objectID": "models.hydramultirocketplus.html",
    "href": "models.hydramultirocketplus.html",
    "title": "HydraMultiRocketPlus",
    "section": "",
    "text": "Hydra: competing convolutional kernels for fast and accurate time series classification.\n\nThis is a Pytorch implementation of Hydra-MultiRocket adapted by Ignacio Oguiza and based on:\nDempster, A., Schmidt, D. F., & Webb, G. I. (2023). Hydra: Competing convolutional kernels for fast and accurate time series classification. Data Mining and Knowledge Discovery, 1-27.\nOriginal paper: https://link.springer.com/article/10.1007/s10618-023-00939-3\nOriginal repository: https://github.com/angus924/hydra\n\nsource\n\nHydraMultiRocketBackbonePlus\n\n HydraMultiRocketBackbonePlus (c_in, c_out, seq_len, d=None, k=8, g=64,\n                               max_c_in=8, clip=True, num_features=50000,\n                               max_dilations_per_kernel=32, kernel_size=9,\n                               max_num_channels=None, max_num_kernels=84,\n                               use_bn=True, fc_dropout=0,\n                               custom_head=None, zero_init=True,\n                               use_diff=True, device=device(type='cpu'))\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nHydraMultiRocketPlus\n\n HydraMultiRocketPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                       k:int=8, g:int=64, max_c_in:int=8, clip:bool=True,\n                       num_features:int=50000,\n                       max_dilations_per_kernel:int=32, kernel_size:int=9,\n                       max_num_channels:int=None, max_num_kernels:int=84,\n                       use_bn:bool=True, fc_dropout:float=0.0,\n                       custom_head:Any=None, zero_init:bool=True,\n                       use_diff:bool=True, device:str=device(type='cpu'))\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nnum of channels in input\n\n\nc_out\nint\n\nnum of channels in output\n\n\nseq_len\nint\n\nsequence length\n\n\nd\ntuple\nNone\nshape of the output (when ndim &gt; 1)\n\n\nk\nint\n8\nnumber of kernels per group in HydraBackbone\n\n\ng\nint\n64\nnumber of groups in HydraBackbone\n\n\nmax_c_in\nint\n8\nmax number of channels per group in HydraBackbone\n\n\nclip\nbool\nTrue\nclip values &gt;= 0 in HydraBackbone\n\n\nnum_features\nint\n50000\nnumber of MultiRocket features\n\n\nmax_dilations_per_kernel\nint\n32\nmax dilations per kernel in MultiRocket\n\n\nkernel_size\nint\n9\nkernel size in MultiRocket\n\n\nmax_num_channels\nint\nNone\nmax number of channels in MultiRocket\n\n\nmax_num_kernels\nint\n84\nmax number of kernels in MultiRocket\n\n\nuse_bn\nbool\nTrue\nuse batch norm\n\n\nfc_dropout\nfloat\n0.0\ndropout probability\n\n\ncustom_head\nAny\nNone\noptional custom head as a torch.nn.Module or Callable\n\n\nzero_init\nbool\nTrue\nset head weights and biases to zero\n\n\nuse_diff\nbool\nTrue\nuse diff(X) as input\n\n\ndevice\nstr\ncpu\ndevice to use\n\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 20)).to(default_device())\n\nmodel = HydraMultiRocketPlus(5, 3, 20, d=None).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 3)\noutput.shape\n\ntorch.Size([16, 3])\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 20)).to(default_device())\n\nmodel = HydraMultiRocketPlus(5, 3, 20, d=None, use_diff=False).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 3)\noutput.shape\n\ntorch.Size([16, 3])\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 5, 20)).to(default_device())\n\nmodel = HydraMultiRocketPlus(5, 3, 20, d=20, use_diff=True).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 20, 3)\noutput.shape\n\ntorch.Size([16, 20, 3])",
    "crumbs": [
      "Models",
      "ROCKETs",
      "HydraMultiRocketPlus"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utilities",
    "section": "",
    "text": "General helper functions used throughout the library\n\n\nsource\n\nrandom_rand\n\n random_rand (*d, dtype=None, out=None, seed=None)\n\nSame as np.random.rand but with a faster random generator, dtype and seed\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd\nVAR_POSITIONAL\n\nint or tuple of ints, optional. The dimensions of the returned array, must be non-negative.\n\n\ndtype\nNoneType\nNone\ndata type of the output.\n\n\nout\nNoneType\nNone\nndarray, optional. Alternative output array in which to place the result.\n\n\nseed\nNoneType\nNone\nint or None, optional. Seed for the random number generator.\n\n\n\n\nsource\n\n\nrandom_randint\n\n random_randint (low, high=None, size=None, dtype=&lt;class 'int'&gt;,\n                 endpoint=False, seed=None)\n\nSame as np.random.randint but with a faster random generator and seed\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlow\n\n\nint, lower endpoint of interval (inclusive)\n\n\nhigh\nNoneType\nNone\nint, upper endpoint of interval (exclusive), or None for a single-argument form of low.\n\n\nsize\nNoneType\nNone\nint or tuple of ints, optional. Output shape.\n\n\ndtype\ntype\nint\ndata type of the output.\n\n\nendpoint\nbool\nFalse\nbool, optional. If True, high is an inclusive endpoint. If False, the range is open on the right.\n\n\nseed\nNoneType\nNone\nint or None, optional. Seed for the random number generator.\n\n\n\n\nsource\n\n\nrandom_choice\n\n random_choice (a, size=None, replace=True, p=None, axis=0, shuffle=True,\n                dtype=None, seed=None)\n\nSame as np.random.choice but with a faster random generator, dtype and seed\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\na\n\n\n1-D array-like or int. The values from which to draw the samples.\n\n\nsize\nNoneType\nNone\nint or tuple of ints, optional. The shape of the output.\n\n\nreplace\nbool\nTrue\nbool, optional. Whether or not to allow the same value to be drawn multiple times.\n\n\np\nNoneType\nNone\n1-D array-like, optional. The probabilities associated with each entry in a.\n\n\naxis\nint\n0\nint, optional. The axis along which the samples are drawn.\n\n\nshuffle\nbool\nTrue\nbool, optional. Whether or not to shuffle the samples before returning them.\n\n\ndtype\nNoneType\nNone\ndata type of the output.\n\n\nseed\nNoneType\nNone\nint or None, optional. Seed for the random number generator.\n\n\n\n\na = random_choice(10, size=(2,3,4), replace=True, p=None, seed=1)\nb = random_choice(10, size=(2,3,4), replace=True, p=None, seed=1)\ntest_eq(a, b)\nc = random_choice(10, size=(2,3,4), replace=True, p=None, seed=2)\ntest_ne(a, c)\n\nassert random_choice(10, size=3, replace=True, p=None).shape == (3,)\nassert random_choice(10, size=(2,3,4), replace=True, p=None).shape == (2,3,4)\n\nprint(random_choice(10, size=3, replace=True, p=None))\nprint(random_choice(10, size=3, replace=False, p=None))\na = [2, 5, 4, 9, 13, 25, 56, 83, 99, 100]\nprint(random_choice(a, size=3, replace=False, p=None))\n\n[5 7 5]\n[0 1 6]\n[  4  83 100]\n\n\n\na = random_randint(10, 20, 100, seed=1)\nb = random_randint(10, 20, 100, seed=1)\ntest_eq(a, b)\nc = random_randint(10, 20, 100, seed=2)\ntest_ne(a, c)\nassert (a &gt;= 10).all() and (a &lt; 20).all()\n\n\na = random_rand(2, 3, 4, seed=123)\nb = random_rand(2, 3, 4, seed=123)\ntest_eq(a, b)\nc = random_rand(2, 3, 4, seed=124)\ntest_ne(a, c)\nassert (a &gt;= 0).all() and (a &lt; 1).all()\n\na = random_rand(2, 3, 4)\na_copy = a.copy()\nrandom_rand(2, 3, 4, out=a)\ntest_ne(a, a_copy)\n\n\nsource\n\n\nis_slice\n\n is_slice (o)\n\n\nsource\n\n\nis_memmap\n\n is_memmap (o)\n\n\nsource\n\n\nis_dask\n\n is_dask (o)\n\n\nsource\n\n\nis_zarr\n\n is_zarr (o)\n\n\nsource\n\n\nis_tensor\n\n is_tensor (o)\n\n\nsource\n\n\nis_nparray\n\n is_nparray (o)\n\n\n# ensure these folders exist for testing purposes\nfns = ['data', 'export', 'models']\nfor fn in fns:\n    path = Path('.')/fn\n    if not os.path.exists(path): os.makedirs(path)\n\n\nsource\n\n\ntodtype\n\n todtype (dtype)\n\n\nsource\n\n\nto3dPlusArray\n\n to3dPlusArray (o)\n\n\nsource\n\n\nto3dPlusTensor\n\n to3dPlusTensor (o)\n\n\nsource\n\n\nto2dPlusArray\n\n to2dPlusArray (o)\n\n\nsource\n\n\nto2dPlusTensor\n\n to2dPlusTensor (o)\n\n\nsource\n\n\nto3dPlus\n\n to3dPlus (o)\n\n\nsource\n\n\nto2dPlus\n\n to2dPlus (o)\n\n\nsource\n\n\nto1d\n\n to1d (o)\n\n\nsource\n\n\nto2d\n\n to2d (o)\n\n\nsource\n\n\nto3d\n\n to3d (o)\n\n\nsource\n\n\nto1darray\n\n to1darray (o)\n\n\nsource\n\n\nto2darray\n\n to2darray (o)\n\n\nsource\n\n\nto3darray\n\n to3darray (o)\n\n\nsource\n\n\nto1dtensor\n\n to1dtensor (o)\n\n\nsource\n\n\nto2dtensor\n\n to2dtensor (o)\n\n\nsource\n\n\nto3dtensor\n\n to3dtensor (o)\n\n\nsource\n\n\ntoL\n\n toL (o)\n\n\nsource\n\n\ntoarray\n\n toarray (o)\n\n\nsource\n\n\ntotensor\n\n totensor (o)\n\n\na = np.random.rand(100).astype(np.float32)\nb = torch.from_numpy(a).float()\ntest_eq(totensor(a), b)\ntest_eq(a, toarray(b))\ntest_eq(to3dtensor(a).ndim, 3)\ntest_eq(to2dtensor(a).ndim, 2)\ntest_eq(to1dtensor(a).ndim, 1)\ntest_eq(to3darray(b).ndim, 3)\ntest_eq(to2darray(b).ndim, 2)\ntest_eq(to1darray(b).ndim, 1)\n\n\ndata = np.random.rand(10, 20)\ndf = pd.DataFrame(data)\ndf['target'] = np.random.randint(0, 3, len(df))\nX = df[df.columns[:-1]]\ny = df['target']\ntest_eq(to3darray(X).shape, (10, 1, 20))\ntest_eq(toarray(y).shape, (10,))\n\n\nsource\n\n\nget_file_size\n\n get_file_size (file_path:str, return_str:bool=True, decimals:int=2)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfile_path\nstr\n\npath to file\n\n\nreturn_str\nbool\nTrue\nTrue returns size in human-readable format (KB, MB, GB, …). False in bytes.\n\n\ndecimals\nint\n2\nNumber of decimals in the output\n\n\n\n\nsource\n\n\nget_dir_size\n\n get_dir_size (dir_path:str, return_str:bool=True, decimals:int=2,\n               verbose:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndir_path\nstr\n\npath to directory\n\n\nreturn_str\nbool\nTrue\nTrue returns size in human-readable format (KB, MB, GB, …). False in bytes.\n\n\ndecimals\nint\n2\nNumber of decimals in the output\n\n\nverbose\nbool\nFalse\nControls verbosity\n\n\n\n\nsource\n\n\nget_size\n\n get_size (o, return_str=False, decimals=2)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\no\n\n\nAny python object\n\n\nreturn_str\nbool\nFalse\nTrue returns size in human-readable format (KB, MB, GB, …). False in bytes.\n\n\ndecimals\nint\n2\nNumber of decimals in the output\n\n\n\n\nsource\n\n\nbytes2str\n\n bytes2str (size_bytes:int, decimals=2)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsize_bytes\nint\n\nNumber of bytes\n\n\ndecimals\nint\n2\nNumber of decimals in the output\n\n\nReturns\nstr\n\n\n\n\n\n\na = np.random.rand(10, 5, 3)\ntest_eq(get_size(a, True, 1), '1.2 KB')\n\n\nsource\n\n\nis_np_view\n\n is_np_view (o)\n\n\n\n\n\nDetails\n\n\n\n\no\na numpy array\n\n\n\n\na = np.array([1., 2., 3.])\ntest_eq(is_np_view(a), False)\ntest_eq(is_np_view(a[1:]), True)\n\n\nsource\n\n\nis_dir\n\n is_dir (path)\n\n\nsource\n\n\nis_file\n\n is_file (path)\n\n\ntest_eq(is_file(\"002_utils.ipynb\"), True)\ntest_eq(is_file(\"utils.ipynb\"), False)\n\n\nsource\n\n\ndelete_all_in_dir\n\n delete_all_in_dir (tgt_dir, exception=None)\n\n\nsource\n\n\nreverse_dict\n\n reverse_dict (dictionary)\n\n\nsource\n\n\nis_tuple\n\n is_tuple (o)\n\n\nsource\n\n\nitemify\n\n itemify (*o, tup_id=None)\n\n\na = [1, 2, 3]\nb = [4, 5, 6]\nprint(itemify(a, b))\ntest_eq(len(itemify(a, b)), len(a))\na = [1, 2, 3]\nb = None\nprint(itemify(a, b))\ntest_eq(len(itemify(a, b)), len(a))\na = [1, 2, 3]\nb = [4, 5, 6]\nc = None\nprint(itemify(a, b, c))\ntest_eq(len(itemify(a, b, c)), len(a))\n\n[(1, 4), (2, 5), (3, 6)]\n[(1,), (2,), (3,)]\n[(1, 4), (2, 5), (3, 6)]\n\n\n\nsource\n\n\nifelse\n\n ifelse (a, b, c)\n\nb if a is True else c\n\nsource\n\n\nexists\n\n exists (o)\n\n\nsource\n\n\nisnone\n\n isnone (o)\n\n\na = np.array(3)\ntest_eq(isnone(a), False)\ntest_eq(exists(a), True)\nb = None\ntest_eq(isnone(b), True)\ntest_eq(exists(b), False)\n\n\nsource\n\n\ntest_eq_nan\n\n test_eq_nan (a, b)\n\ntest that a==b excluding nan values (valid for torch.Tensor and np.ndarray)\n\nsource\n\n\ntest_error\n\n test_error (error, f, *args, **kwargs)\n\n\nsource\n\n\ntest_not_ok\n\n test_not_ok (f, *args, **kwargs)\n\n\nsource\n\n\ntest_ok\n\n test_ok (f, *args, **kwargs)\n\n\nsource\n\n\ntest_type\n\n test_type (a, b)\n\n\nsource\n\n\ntest_not_close\n\n test_not_close (a, b, eps=1e-05)\n\ntest that a is within eps of b\n\nsource\n\n\nis_not_close\n\n is_not_close (a, b, eps=1e-05)\n\nIs a within eps of b\n\nsource\n\n\nassert_fn\n\n assert_fn (*args, **kwargs)\n\n\nsource\n\n\ntest_le\n\n test_le (a, b)\n\ntest that a&gt;b\n\nsource\n\n\ntest_lt\n\n test_lt (a, b)\n\ntest that a&gt;b\n\nsource\n\n\ntest_ge\n\n test_ge (a, b)\n\ntest that a&gt;=b\n\nsource\n\n\ntest_gt\n\n test_gt (a, b)\n\ntest that a&gt;b\n\ntest_ok(test_gt, 5, 4)\ntest_not_ok(test_gt, 4, 4)\ntest_ok(test_ge, 4, 4)\ntest_not_ok(test_ge, 3, 4)\n\ntest_ok(test_lt, 3, 4)\ntest_not_ok(test_lt, 4, 4)\ntest_ok(test_le, 4, 4)\ntest_not_ok(test_le, 5, 4)\n\n\nt = torch.rand(100)\ntest_eq(t, t)\ntest_eq_nan(t, t)\n\n\nsource\n\n\nstack_pad\n\n stack_pad (o, padding_value=nan)\n\nConverts a an iterable into a numpy array using padding if necessary\n\nsource\n\n\nstack\n\n stack (o, axis=0, retain=True)\n\n\no = [[0,1,2], [4,5,6,7]]\ntest_eq(stack_pad(o).shape, (1, 2, 4))\ntest_eq(type(stack_pad(o)), np.ndarray)\ntest_eq(np.isnan(stack_pad(o)).sum(), 1)\n\n\no = 3\nprint(stack_pad(o))\ntest_eq(stack_pad(o), np.array([[3.]]))\no = [4,5]\nprint(stack_pad(o))\ntest_eq(stack_pad(o), np.array([[4., 5.]]))\no = [[0,1,2], [4,5,6,7]]\nprint(stack_pad(o))\no = np.array([0, [1,2]], dtype=object)\nprint(stack_pad(o))\no = np.array([[[0], [10, 20], [100, 200, 300]], [[0, 1, 2, 3], [10, 20], [100]]], dtype=object)\nprint(stack_pad(o))\no = np.array([0, [10, 20]], dtype=object)\nprint(stack_pad(o))\n\n[[3.]]\n[[4. 5.]]\n[[[ 0.  1.  2. nan]\n  [ 4.  5.  6.  7.]]]\n[[ 0. nan]\n [ 1.  2.]]\n[[[  0.  nan  nan  nan]\n  [ 10.  20.  nan  nan]\n  [100. 200. 300.  nan]]\n\n [[  0.   1.   2.   3.]\n  [ 10.  20.  nan  nan]\n  [100.  nan  nan  nan]]]\n[[ 0. nan]\n [10. 20.]]\n\n\n\na = np.random.rand(2, 3, 4)\nt = torch.from_numpy(a)\ntest_eq_type(stack(itemify(a, tup_id=0)), a)\ntest_eq_type(stack(itemify(t, tup_id=0)), t)\n\n\nsource\n\n\npad_sequences\n\n pad_sequences (o, maxlen:int=None,\n                dtype:(&lt;class'str'&gt;,&lt;class'type'&gt;)=&lt;class\n                'numpy.float64'&gt;, padding:str='pre', truncating:str='pre',\n                padding_value:float=nan)\n\nTransforms an iterable with sequences into a 3d numpy array using padding or truncating sequences if necessary\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\no\n\n\nIterable object\n\n\nmaxlen\nint\nNone\nOptional max length of the output. If None, max length of the longest individual sequence.\n\n\ndtype\n(&lt;class ‘str’&gt;, &lt;class ‘type’&gt;)\nfloat64\nType of the output sequences. To pad sequences with variable length strings, you can use object.\n\n\npadding\nstr\npre\n‘pre’ or ‘post’ pad either before or after each sequence.\n\n\ntruncating\nstr\npre\n‘pre’ or ‘post’ remove values from sequences larger than maxlen, either at the beginning or at the end of the sequences.\n\n\npadding_value\nfloat\nnan\nValue used for padding.\n\n\n\nThis function transforms a list (of length n_samples) of sequences into a 3d numpy array of shape:\n                          [n_samples x n_vars x seq_len]\nseq_len is either the maxlen argument if provided, or the length of the longest sequence in the list.\nSequences that are shorter than seq_len are padded with value until they are seq_len long.\nSequences longer than seq_len are truncated so that they fit the desired length.\nThe position where padding or truncation happens is determined by the arguments padding and truncating, respectively. Pre-padding or removing values from the beginning of the sequence is the default.\nInput sequences to pad_sequences may be have 1, 2 or 3 dimensions:\n\n# 1 dim\na1 = np.arange(6)\na2 = np.arange(3) * 10\na3 = np.arange(2) * 100\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=4, dtype=np.float64, padding='post', truncating='pre', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 1, 4))\npadded_o\n\narray([[[  2.,   3.,   4.,   5.]],\n\n       [[  0.,  10.,  20.,  nan]],\n\n       [[  0., 100.,  nan,  nan]]])\n\n\n\n# 2 dim\na1 = np.arange(12).reshape(2, 6)\na2 = np.arange(6).reshape(2, 3) * 10\na3 = np.arange(4).reshape(2, 2) * 100\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=4, dtype=np.float64, padding='post', truncating='pre', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 2, 4))\npadded_o\n\narray([[[  2.,   3.,   4.,   5.],\n        [  8.,   9.,  10.,  11.]],\n\n       [[  0.,  10.,  20.,  nan],\n        [ 30.,  40.,  50.,  nan]],\n\n       [[  0., 100.,  nan,  nan],\n        [200., 300.,  nan,  nan]]])\n\n\n\n# 3 dim\na1 = np.arange(10).reshape(1, 2, 5)\na2 = np.arange(6).reshape(1, 2, 3) * 10\na3 = np.arange(4).reshape(1, 2, 2) * 100\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=None, dtype=np.float64, padding='pre', truncating='pre', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 2, 5))\npadded_o\n\narray([[[  0.,   1.,   2.,   3.,   4.],\n        [  5.,   6.,   7.,   8.,   9.]],\n\n       [[ nan,  nan,   0.,  10.,  20.],\n        [ nan,  nan,  30.,  40.,  50.]],\n\n       [[ nan,  nan,  nan,   0., 100.],\n        [ nan,  nan,  nan, 200., 300.]]])\n\n\n\n# 3 dim\na1 = np.arange(10).reshape(1, 2, 5)\na2 = np.arange(6).reshape(1, 2, 3) * 10\na3 = np.arange(4).reshape(1, 2, 2) * 100\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=4, dtype=np.float64, padding='pre', truncating='pre', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 2, 4))\npadded_o\n\narray([[[  1.,   2.,   3.,   4.],\n        [  6.,   7.,   8.,   9.]],\n\n       [[ nan,   0.,  10.,  20.],\n        [ nan,  30.,  40.,  50.]],\n\n       [[ nan,  nan,   0., 100.],\n        [ nan,  nan, 200., 300.]]])\n\n\n\n# 3 dim\na1 = np.arange(10).reshape(1, 2, 5)\na2 = np.arange(6).reshape(1, 2, 3) * 10\na3 = np.arange(4).reshape(1, 2, 2) * 100\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=4, dtype=np.float64, padding='post', truncating='pre', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 2, 4))\npadded_o\n\narray([[[  1.,   2.,   3.,   4.],\n        [  6.,   7.,   8.,   9.]],\n\n       [[  0.,  10.,  20.,  nan],\n        [ 30.,  40.,  50.,  nan]],\n\n       [[  0., 100.,  nan,  nan],\n        [200., 300.,  nan,  nan]]])\n\n\n\n# 3 dim\na1 = np.arange(10).reshape(1, 2, 5)\na2 = np.arange(6).reshape(1, 2, 3) * 10\na3 = np.arange(4).reshape(1, 2, 2) * 100\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=4, dtype=np.float64, padding='post', truncating='post', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 2, 4))\npadded_o\n\narray([[[  0.,   1.,   2.,   3.],\n        [  5.,   6.,   7.,   8.]],\n\n       [[  0.,  10.,  20.,  nan],\n        [ 30.,  40.,  50.,  nan]],\n\n       [[  0., 100.,  nan,  nan],\n        [200., 300.,  nan,  nan]]])\n\n\n\n# iterable is a list of lists\na1 = np.arange(12).reshape(1, 2, 6).tolist()\na2 = (np.arange(6).reshape(1, 2, 3) * 10).tolist()\na3 = (np.arange(4).reshape(1, 2, 2) * 100).tolist()\no  = [a1, a2, a3]\npadded_o = pad_sequences(o, maxlen=None, dtype=np.float64, padding='post', truncating='pre', padding_value=np.nan)\ntest_eq(padded_o.shape, (3, 2, 6))\npadded_o\n\narray([[[  0.,   1.,   2.,   3.,   4.,   5.],\n        [  6.,   7.,   8.,   9.,  10.,  11.]],\n\n       [[  0.,  10.,  20.,  nan,  nan,  nan],\n        [ 30.,  40.,  50.,  nan,  nan,  nan]],\n\n       [[  0., 100.,  nan,  nan,  nan,  nan],\n        [200., 300.,  nan,  nan,  nan,  nan]]])\n\n\n\nsource\n\n\nmatch_seq_len\n\n match_seq_len (*arrays)\n\n\na = np.random.rand(10, 5, 8)\nb = np.random.rand(3, 5, 10)\nc, d = match_seq_len(a, b)\ntest_eq(c.shape[-1], d.shape[-1])\n\n\nsource\n\n\nrandom_shuffle\n\n random_shuffle (o, random_state=None)\n\n\na = np.arange(10)\ntest_eq_type(random_shuffle(a, 1), np.array([2, 9, 6, 4, 0, 3, 1, 7, 8, 5]))\nt = torch.arange(10)\ntest_eq_type(random_shuffle(t, 1), tensor([2, 9, 6, 4, 0, 3, 1, 7, 8, 5]))\nl = list(a)\ntest_eq(random_shuffle(l, 1), [2, 9, 6, 4, 0, 3, 1, 7, 8, 5])\nl2 = L(l)\ntest_eq_type(random_shuffle(l2, 1), L([2, 9, 6, 4, 0, 3, 1, 7, 8, 5]))\n\n\nsource\n\n\ncat2int\n\n cat2int (o)\n\n\na = np.array(['b', 'a', 'a', 'b', 'a', 'b', 'a'])\ntest_eq_type(cat2int(a), TensorCategory([1, 0, 0, 1, 0, 1, 0]))\n\n\nTensorBase([1,2,3])\n\nTensorBase([1, 2, 3])\n\n\n\nsource\n\n\ncycle_dl_estimate\n\n cycle_dl_estimate (dl, iters=10)\n\n\nsource\n\n\ncycle_dl_to_device\n\n cycle_dl_to_device (dl, show_progress_bar=True)\n\n\nsource\n\n\ncycle_dl\n\n cycle_dl (dl, show_progress_bar=True)\n\n\nsource\n\n\ncache_data\n\n cache_data (o, slice_len=10000, verbose=False)\n\n\nsource\n\n\nget_func_defaults\n\n get_func_defaults (f)\n\n\nsource\n\n\nget_idx_from_df_col_vals\n\n get_idx_from_df_col_vals (df, col, val_list)\n\n\nsource\n\n\nget_sublist_idxs\n\n get_sublist_idxs (aList, bList)\n\nGet idxs that when applied to aList will return bList. aList must contain all values in bList\n\nx = np.array([3, 5, 7, 1, 9, 8, 6, 2])\ny = np.array([6, 1, 5, 7])\nidx = get_sublist_idxs(x, y)\ntest_eq(x[idx], y)\nx = np.array([3, 5, 7, 1, 9, 8, 6, 6, 2])\ny = np.array([6, 1, 5, 7, 5])\nidx = get_sublist_idxs(x, y)\ntest_eq(x[idx], y)\n\n\nsource\n\n\nflatten_list\n\n flatten_list (l)\n\n\nsource\n\n\ndisplay_pd_df\n\n display_pd_df (df, max_rows:Union[bool,int]=False,\n                max_columns:Union[bool,int]=False)\n\n\nold_max_rows, old_max_columns = pd.get_option('display.max_rows'), pd.get_option('display.max_columns')\ndf = pd.DataFrame(np.random.rand(70, 25))\ndisplay_pd_df(df, max_rows=2, max_columns=3)\ntest_eq(old_max_rows, pd.get_option('display.max_rows'))\ntest_eq(old_max_columns, pd.get_option('display.max_columns'))\n\n\n\n\n\n\n\n\n0\n...\n24\n\n\n\n\n0\n0.436034\n...\n0.231616\n\n\n...\n...\n...\n...\n\n\n69\n0.633051\n...\n0.051762\n\n\n\n\n70 rows × 25 columns\n\n\n\n\nsource\n\n\ntscore\n\n tscore (o)\n\n\nsource\n\n\nkstest\n\n kstest (data1, data2, alternative='two-sided', mode='auto', by_axis=None)\n\n*Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.\nParameters data1, data2: Two arrays of sample observations assumed to be drawn from a continuous distributions. Sample sizes can be different. alternative: {‘two-sided’, ‘less’, ‘greater’}, optional. Defines the null and alternative hypotheses. Default is ‘two-sided’. mode: {‘auto’, ‘exact’, ‘asymp’}, optional. Defines the method used for calculating the p-value. by_axis (optional, int): for arrays with more than 1 dimension, the test will be run for each variable in that axis if by_axis is not None.*\n\nsource\n\n\nttest\n\n ttest (data1, data2, equal_var=False)\n\nCalculates t-statistic and p-value based on 2 sample distributions\n\na = np.random.normal(0.5, 1, 100)\nb = np.random.normal(0.15, .5, 50)\nplt.hist(a, 50)\nplt.hist(b, 50)\nplt.show()\nttest(a,b)\n\n\n\n\n\n\n\n\n\na = np.random.normal(0.5, 1, (100,3))\nb = np.random.normal(0.5, 1, (50,))\nkstest(a,b)\n\n(0.22333333333333333, 0.02452803315700394)\n\n\n\na = np.random.normal(0.5, 1, (100,3))\nb = np.random.normal(0.15, .5, (50,))\nkstest(a,b)\n\n(0.31, 0.0004061333917852463)\n\n\n\ndata1 = np.random.normal(0,1,(100, 5, 3))\ndata2 = np.random.normal(0,2,(100, 5, 3))\nkstest(data1, data2, by_axis=1)\n\n([0.22,\n  0.16333333333333333,\n  0.16333333333333333,\n  0.18666666666666668,\n  0.21666666666666667],\n [8.994053173844458e-07,\n  0.0006538374533623971,\n  0.0006538374533623971,\n  5.522790313356146e-05,\n  1.4007759411179028e-06])\n\n\n\na = np.random.normal(0.5, 1, 100)\nt = torch.normal(0.5, 1, (100, ))\ntscore(a), tscore(t)\n\n(4.33309224863388, tensor(5.7798))\n\n\n\nsource\n\n\nscc\n\n scc (a, b)\n\n\nsource\n\n\npcc\n\n pcc (a, b)\n\n\nsource\n\n\nremove_fn\n\n remove_fn (fn, verbose=False)\n\nRemoves a file (fn) if exists\n\nsource\n\n\nnpsave\n\n npsave (array_fn, array, verbose=True)\n\n\nfn = 'data/remove_fn_test.npy'\na = np.zeros(1)\nnpsave(fn, a)\ndel a\nnp.load(fn, mmap_mode='r+')\nremove_fn(fn, True)\nremove_fn(fn, True)\n\ndata/remove_fn_test.npy does not exist\nsaving data/remove_fn_test.npy...\n...data/remove_fn_test.npy saved\ndata/remove_fn_test.npy file removed\ndata/remove_fn_test.npy does not exist\n\n\n\nsource\n\n\npermute_2D\n\n permute_2D (array, axis=None)\n\nPermute rows or columns in an array. This can be used, for example, in feature permutation\n\ns = np.arange(100 * 50).reshape(100, 50)\ntest_eq(permute_2D(s, axis=0).mean(0), s.mean(0))\ntest_ne(permute_2D(s, axis=0), s)\ntest_eq(permute_2D(s, axis=1).mean(1), s.mean(1))\ntest_ne(permute_2D(s, axis=1), s)\ntest_ne(permute_2D(s), s)\n\n\nsource\n\n\nrandom_half_normal_tensor\n\n random_half_normal_tensor (shape=1, device=None)\n\nReturns a tensor of a predefined shape between 0 and 1 with a half-normal distribution\n\nsource\n\n\nrandom_normal_tensor\n\n random_normal_tensor (shape=1, device=None)\n\nReturns a tensor of a predefined shape between -1 and 1 with a normal distribution\n\nsource\n\n\nrandom_half_normal\n\n random_half_normal ()\n\nReturns a number between 0 and 1 with a half-normal distribution\n\nsource\n\n\nrandom_normal\n\n random_normal ()\n\nReturns a number between -1 and 1 with a normal distribution\n\nsource\n\n\nfig2buf\n\n fig2buf (fig)\n\n\nsource\n\n\nget_plot_fig\n\n get_plot_fig (size=None, dpi=100)\n\n\nsource\n\n\ndefault_dpi\n\n default_dpi ()\n\n\ndefault_dpi()\n\n100\n\n\n\nsource\n\n\nplot_scatter\n\n plot_scatter (x, y, deg=1)\n\n\na = np.random.rand(100)\nb = np.random.rand(100)**2\nplot_scatter(a, b)\n\n\n\n\n\n\n\n\n\nsource\n\n\nget_idxs\n\n get_idxs (o, aList)\n\n\na = random_shuffle(np.arange(100, 200))\nb = np.random.choice(a, 10, False)\nidxs = get_idxs(a, b)\ntest_eq(a[idxs], b)\n\n\nsource\n\n\napply_cmap\n\n apply_cmap (o, cmap)\n\n\na = np.random.rand(16, 1, 40, 50)\ns = L(a.shape)\ns[1] = 3\ntest_eq(L(apply_cmap(a, 'viridis').shape), s)\n\ns[0] = 1\na = np.random.rand(1, 40, 50)\ntest_eq(L(apply_cmap(a, 'viridis').shape), s)\n\n\nsource\n\n\ntorch_tile\n\n torch_tile (a, n_tile, dim=0)\n\n\ntest_eq(torch_tile(torch.arange(2), 3), tensor([0, 1, 0, 1, 0, 1]))\n\n\nsource\n\n\nto_tsfresh_df\n\n to_tsfresh_df (ts)\n\nPrepares a time series (Tensor/ np.ndarray) to be used as a tsfresh dataset to allow feature extraction\n\nts = torch.rand(16, 3, 20)\na = to_tsfresh_df(ts)\nts = ts.numpy()\nb = to_tsfresh_df(ts)\n\n\nsource\n\n\nscorr\n\n scorr (a, b)\n\n\nsource\n\n\npcorr\n\n pcorr (a, b)\n\n\nsource\n\n\ntorch_diff\n\n torch_diff (t, lag=1, pad=True, append=0)\n\n\nt = torch.arange(24).reshape(2,3,4)\ntest_eq(torch_diff(t, 1)[..., 1:].float().mean(), 1.)\ntest_eq(torch_diff(t, 2)[..., 2:].float().mean(), 2.)\n\n\nsource\n\n\ntorch_clamp\n\n torch_clamp (o, min=None, max=None)\n\nClamp torch.Tensor using 1 or multiple dimensions\n\nsource\n\n\nget_percentile\n\n get_percentile (o, percentile, axis=None)\n\n\nsource\n\n\nclip_outliers\n\n clip_outliers (o, axis=None)\n\n\nsource\n\n\nget_outliers_IQR\n\n get_outliers_IQR (o, axis=None, quantile_range=(25.0, 75.0))\n\n\nt = torch.randn(2,3,100)\ntest_eq(type(get_outliers_IQR(t, -1)[0]), torch.Tensor)\na = t.numpy()\ntest_eq(type(get_outliers_IQR(a, -1)[0]), np.ndarray)\ntest_close(get_percentile(t, 25).numpy(), get_percentile(a, 25))\n\n\nsource\n\n\nget_robustscale_params\n\n get_robustscale_params (o, sel_vars=None, not_sel_vars=None, by_var=True,\n                         percentiles=(25, 75), eps=1e-06)\n\nCalculates median and inter-quartile range required to robust scaler inputs\n\na = np.random.rand(16, 3, 100)\na[a&gt;.8] = np.nan\nmedian, IQR = get_robustscale_params(a, by_var=True, percentiles=(25, 75))\na_scaled = (a - median) / IQR\ntest_eq(a.shape, a_scaled.shape)\ntest_eq(np.isnan(median).sum(),0)\ntest_eq(np.isnan(IQR).sum(),0)\ntest_eq(np.isnan(a), np.isnan(a_scaled))\n\n\nsource\n\n\ntorch_slice_by_dim\n\n torch_slice_by_dim (t, index, dim=-1, **kwargs)\n\n\nt = torch.rand(5, 3)\nindex = torch.randint(0, 3, (5, 1))\n# index = [[0, 2], [0, 1], [1, 2], [0, 2], [0, 1]]\ntorch_slice_by_dim(t, index)\n\ntensor([[0.5341],\n        [0.4543],\n        [0.0942],\n        [0.9645],\n        [0.0405]])\n\n\n\nsource\n\n\ntorch_nanstd\n\n torch_nanstd (o, dim=None, keepdim=False)\n\nThere’s currently no torch.nanstd function\n\nsource\n\n\ntorch_nanmean\n\n torch_nanmean (o, dim=None, keepdim=False)\n\nThere’s currently no torch.nanmean function\n\nt = torch.rand(1000)\nt[:100] = float('nan')\nassert torch_nanmean(t).item() &gt; 0\n\n\nsource\n\n\nconcat\n\n concat (*ls, dim=0)\n\nConcatenate tensors, arrays, lists, or tuples by a dimension\n\nsource\n\n\nreduce_memory_usage\n\n reduce_memory_usage (df)\n\n\nsource\n\n\ncls_name\n\n cls_name (o)\n\n\ntest_eq(cls_name(timer), 'Timer')\n\n\nsource\n\n\nrotate_axis2\n\n rotate_axis2 (o, steps=1)\n\n\nsource\n\n\nrotate_axis1\n\n rotate_axis1 (o, steps=1)\n\n\nsource\n\n\nrotate_axis0\n\n rotate_axis0 (o, steps=1)\n\n\nsource\n\n\nrandom_roll3d\n\n random_roll3d (o, axis=(), replace=False)\n\nRandomly rolls a 3D object along the indicated axes This solution is based on https://stackoverflow.com/questions/20360675/roll-rows-of-a-matrix-independently\n\nsource\n\n\nrandom_roll2d\n\n random_roll2d (o, axis=(), replace=False)\n\nRolls a 2D object on the indicated axis This solution is based on https://stackoverflow.com/questions/20360675/roll-rows-of-a-matrix-independently\n\nsource\n\n\nroll3d\n\n roll3d (o, roll1:Union[NoneType,list,int]=None,\n         roll2:Union[NoneType,list,int]=None,\n         roll3:Union[NoneType,list,int]=None)\n\nRolls a 3D object on the indicated axis This solution is based on https://stackoverflow.com/questions/20360675/roll-rows-of-a-matrix-independently\n\nsource\n\n\nroll2d\n\n roll2d (o, roll1:Union[NoneType,list,int]=None,\n         roll2:Union[NoneType,list,int]=None)\n\nRolls a 2D object on the indicated axis This solution is based on https://stackoverflow.com/questions/20360675/roll-rows-of-a-matrix-independently\n\na = np.tile(np.arange(10), 3).reshape(3, 10) * np.array([1, 10, 100]).reshape(-1, 1)\na\n\narray([[  0,   1,   2,   3,   4,   5,   6,   7,   8,   9],\n       [  0,  10,  20,  30,  40,  50,  60,  70,  80,  90],\n       [  0, 100, 200, 300, 400, 500, 600, 700, 800, 900]])\n\n\n\nroll2d(a, roll1=[2, 1, 0])\n\narray([[  0, 100, 200, 300, 400, 500, 600, 700, 800, 900],\n       [  0,  10,  20,  30,  40,  50,  60,  70,  80,  90],\n       [  0,   1,   2,   3,   4,   5,   6,   7,   8,   9]])\n\n\n\nroll2d(a, roll2=3)\n\narray([[  7,   8,   9,   0,   1,   2,   3,   4,   5,   6],\n       [ 70,  80,  90,   0,  10,  20,  30,  40,  50,  60],\n       [700, 800, 900,   0, 100, 200, 300, 400, 500, 600]])\n\n\n\no = torch.arange(24).reshape(2,3,4)\ntest_eq(rotate_axis0(o)[1], o[0])\ntest_eq(rotate_axis1(o)[:,1], o[:,0])\ntest_eq(rotate_axis2(o)[...,1], o[...,0])\n\n\nsource\n\n\nchunks_calculator\n\n chunks_calculator (shape, dtype='float32', n_bytes=1073741824)\n\n*Function to calculate chunks for a given size of n_bytes (default = 1024**3 == 1GB). It guarantees &gt; 50% of the chunk will be filled*\n\nshape = (1_000, 10, 1000)\ndtype = 'float32'\ntest_eq(chunks_calculator(shape, dtype), False)\n\nshape = (54684, 10, 1000)\ndtype = 'float32'\ntest_eq(chunks_calculator(shape, dtype), (27342, -1, -1))\n\n\nsource\n\n\nis_memory_shared\n\n is_memory_shared (a, b)\n\nCheck if 2 array-like objects share memory\n\na = np.random.rand(2,3,4)\nt1 = torch.from_numpy(a)\ntest_eq(is_memory_shared(a, t1), True)\na = np.random.rand(2,3,4)\nt2 = torch.as_tensor(a)\ntest_eq(is_memory_shared(a, t2), True)\na = np.random.rand(2,3,4)\nt3 = torch.tensor(a)\ntest_eq(is_memory_shared(a, t3), False)\n\n\nsource\n\n\nassign_in_chunks\n\n assign_in_chunks (a, b, chunksize='auto', inplace=True, verbose=True)\n\nAssigns values in b to an array-like object a using chunks to avoid memory overload. The resulting a retains it’s dtype and share it’s memory. a: array-like object b: may be an integer, float, str, ‘rand’ (for random data), or another array like object. chunksize: is the size of chunks. If ‘auto’ chunks will have around 1GB each.\n\na = np.random.rand(10,3,4).astype('float32')\na_dtype = a.dtype\na_id = id(a)\nb = np.random.rand(10,3,4).astype('float64')\nassign_in_chunks(a, b, chunksize=2, inplace=True, verbose=True)\ntest_close(a, b)\ntest_eq(a.dtype, a_dtype)\ntest_eq(id(a), a_id)\n\na = np.random.rand(10,3,4).astype('float32')\na_dtype = a.dtype\na_id = id(a)\nb = 1\nassign_in_chunks(a, b, chunksize=2, inplace=True, verbose=True)\ntest_eq(a, np.ones_like(a).astype(a.dtype))\ntest_eq(a.dtype, a_dtype)\ntest_eq(id(a), a_id)\n\na = np.random.rand(10,3,4).astype('float32')\na_dtype = a.dtype\na_id = id(a)\nb = 0.5\nassign_in_chunks(a, b, chunksize=2, inplace=True, verbose=True)\ntest_eq(a.dtype, a_dtype)\ntest_eq(id(a), a_id)\n\na = np.random.rand(10,3,4).astype('float32')\na_dtype = a.dtype\na_id = id(a)\nb = 'rand'\nassign_in_chunks(a, b, chunksize=2, inplace=True, verbose=True)\ntest_eq(a.dtype, a_dtype)\ntest_eq(id(a), a_id)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\na = np.random.rand(10,3,4).astype('float32')\nb = np.random.rand(10,3,4).astype('float64')\nc = assign_in_chunks(a, b, chunksize=2, inplace=False, verbose=True)\ntest_close(c, b)\ntest_eq(a.dtype, c.dtype)\ntest_eq(is_memory_shared(a, c), True)\n\na = np.random.rand(10,3,4).astype('float32')\nb = 1\nc = assign_in_chunks(a, b, chunksize=2, inplace=False, verbose=True)\ntest_eq(a, np.ones_like(a).astype(a.dtype))\ntest_eq(a.dtype, c.dtype)\ntest_eq(is_memory_shared(a, c), True)\n\na = np.random.rand(10,3,4).astype('float32')\nb = 0.5\nc = assign_in_chunks(a, b, chunksize=2, inplace=False, verbose=True)\ntest_eq(a.dtype, c.dtype)\ntest_eq(is_memory_shared(a, c), True)\n\na = np.random.rand(10,3,4).astype('float32')\nb = 'rand'\nc = assign_in_chunks(a, b, chunksize=2, inplace=False, verbose=True)\ntest_eq(a.dtype, c.dtype)\ntest_eq(is_memory_shared(a, c), True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\ncreate_array\n\n create_array (shape, fname=None, path='./data', on_disk=True,\n               dtype='float32', mode='r+', fill_value='rand',\n               chunksize='auto', verbose=True, **kwargs)\n\nmode: ‘r’: Open existing file for reading only. ‘r+’: Open existing file for reading and writing. ‘w+’: Create or overwrite existing file for reading and writing. ‘c’: Copy-on-write: assignments affect data in memory, but changes are not saved to disk. The file on disk is read-only. fill_value: ‘rand’ (for random numbers), int or float chunksize = ‘auto’ to calculate chunks of 1GB, or any integer (for a given number of samples)\n\nfname = 'X_on_disk'\nshape = (100, 10, 10)\nX = create_array(shape, fname, on_disk=True, mode='r+')\ntest_ne(abs(X).sum(), 0)\nos.remove(X.filename)\ndel X\n\nauto chunksize: 100\n\n\n\n\n\n\n\n\n\n\nfname = 'X_on_disk'\nshape = (100, 10, 10)\nX = create_empty_array(shape, fname, on_disk=True, mode='r+')\ntest_eq(abs(X).sum(), 0)\n\nchunksize = 10\npbar = progress_bar(range(math.ceil(len(X) / chunksize)), leave=False)\nstart = 0\nfor i in pbar:\n    end = min(start + chunksize, len(X))\n    partial_data = np.random.rand(end - start, X.shape[1] , X.shape[2])\n    X[start:end] = partial_data\n    start = end\n    del partial_data\n    gc.collect()\nfilename = X.filename\ndel X\nX = np.load(filename, mmap_mode='r+')\ntest_eq((X == 0).sum(), 0)\ntest_eq(X.shape, shape)\nos.remove(X.filename)\ndel X\n\n\n\n\n\n\n\n\n\nsource\n\n\nnp_load_compressed\n\n np_load_compressed (fname=None, path='./data', **kwargs)\n\n\nsource\n\n\nnp_save_compressed\n\n np_save_compressed (arr, fname=None, path='./data', verbose=False,\n                     **kwargs)\n\n\nX1 = np.random.rand(10)\nnp_save_compressed(X1, 'X_comp', path='./data')\nX2 = np_load_compressed('X_comp')\ntest_eq(X1, X2)\n\n\nsource\n\n\nnp2memmap\n\n np2memmap (arr, fname=None, path='./data', dtype='float32', mode='c',\n            **kwargs)\n\nFunction that turns an ndarray into a memmap ndarray mode: ‘r’: Open existing file for reading only. ‘r+’: Open existing file for reading and writing. ‘w+’: Create or overwrite existing file for reading and writing. ‘c’: Copy-on-write: assignments affect data in memory, but changes are not saved to disk. The file on disk is read-only.\n\nX1 = np.random.rand(10)\nX2 = np2memmap(X1, 'X1_test')\ntest_eq(X1, X2)\ntest_ne(type(X1), type(X2))\n\n\nsource\n\n\ntorch_mean_groupby\n\n torch_mean_groupby (o, idxs)\n\nComputes torch mean along axis 0 grouped by the idxs. Need to ensure that idxs have the same order as o\n\no = torch.arange(6*2*3).reshape(6, 2, 3).float()\nidxs = np.array([[0,1,2,3], [2,3]], dtype=object)\noutput = torch_mean_groupby(o, idxs)\ntest_eq(o[:2], output[:2])\ntest_eq(o[2:4].mean(0), output[2])\ntest_eq(o[4:6].mean(0), output[3])\n\n\nsource\n\n\ntorch_flip\n\n torch_flip (t, dims=-1)\n\n\nt = torch.randn(2, 3, 4)\ntest_eq(torch.flip(t, (2,)), torch_flip(t, dims=-1))\n\n\nsource\n\n\ntorch_masked_to_num\n\n torch_masked_to_num (o, mask, num=0, inplace=False)\n\n\nsource\n\n\ntorch_nan_to_num\n\n torch_nan_to_num (o, num=0, inplace=False)\n\n\nx = torch.rand(2, 4, 6)\nx[:, :3][x[:, :3] &lt; .5] = np.nan\nnan_values = torch.isnan(x).sum()\ny = torch_nan_to_num(x[:, :3], inplace=False)\ntest_eq(torch.isnan(y).sum(), 0)\ntest_eq(torch.isnan(x).sum(), nan_values)\ntorch_nan_to_num(x[:, :3], inplace=True)\ntest_eq(torch.isnan(x).sum(), 0)\n\n\nx = torch.rand(2, 4, 6)\nmask = x[:, :3] &gt; .5\nx[:, :3] = torch_masked_to_num(x[:, :3], mask, num=0, inplace=False)\ntest_eq(x[:, :3][mask].sum(), 0)\n\n\nx = torch.rand(2, 4, 6)\nmask = x[:, :3] &gt; .5\ntorch_masked_to_num(x[:, :3], mask, num=0, inplace=True)\ntest_eq(x[:, :3][mask].sum(), 0)\n\n\nsource\n\n\nmpl_trend\n\n mpl_trend (x, y, deg=1)\n\n\nx = np.sort(np.random.randint(0, 100, 100)/10)\ny = np.random.rand(100) + np.linspace(0, 10, 100)\ntrend = mpl_trend(x, y)\nplt.scatter(x, y)\nplt.plot(x, trend, 'r')\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\narray2digits\n\n array2digits (o, n_digits=None, normalize=True)\n\n\nsource\n\n\nint2digits\n\n int2digits (o, n_digits=None, normalize=True)\n\n\no = -9645\ntest_eq(int2digits(o, 6), np.array([ 0,  0, -.9, -.6, -.4, -.5]))\n\na = np.random.randint(-1000, 1000, 10)\ntest_eq(array2digits(a,5).shape, (10,5))\n\n\nsource\n\n\nsincos_encoding\n\n sincos_encoding (seq_len, device=None, to_np=False)\n\n\nsin, cos = sincos_encoding(100)\nplt.plot(sin.cpu().numpy())\nplt.plot(cos.cpu().numpy())\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nlinear_encoding\n\n linear_encoding (seq_len, device=None, to_np=False, lin_range=(-1, 1))\n\n\nlin = linear_encoding(100)\nplt.plot(lin.cpu().numpy())\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nencode_positions\n\n encode_positions (pos_arr, min_val=None, max_val=None, linear=False,\n                   lin_range=(-1, 1))\n\nEncodes an array with positions using a linear or sincos methods\n\nn_samples = 10\nlength = 500\n_a = []\nfor i in range(n_samples):\n    a = np.arange(-4000, 4000, 10)\n    mask = np.random.rand(len(a)) &gt; .5\n    a = a[mask]\n    a = np.concatenate([a, np.array([np.nan] * (length - len(a)))])\n    _a.append(a.reshape(-1,1))\na = np.concatenate(_a, -1).transpose(1,0)\nsin, cos = encode_positions(a, linear=False)\ntest_eq(a.shape, (n_samples, length))\ntest_eq(sin.shape, (n_samples, length))\ntest_eq(cos.shape, (n_samples, length))\nplt.plot(sin.T)\nplt.plot(cos.T)\nplt.xlim(0, 500)\nplt.show()\n\n\n\n\n\n\n\n\n\nn_samples = 10\nlength = 500\n_a = []\nfor i in range(n_samples):\n    a = np.arange(-4000, 4000, 10)\n    mask = np.random.rand(len(a)) &gt; .5\n    a = a[mask]\n    a = np.concatenate([a, np.array([np.nan] * (length - len(a)))])\n    _a.append(a.reshape(-1,1))\na = np.concatenate(_a, -1).transpose(1,0)\nlin = encode_positions(a, linear=True)\ntest_eq(a.shape, (n_samples, length))\ntest_eq(lin.shape, (n_samples, length))\nplt.plot(lin.T)\nplt.xlim(0, 500)\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nsort_generator\n\n sort_generator (generator, bs)\n\n\ngenerator = (i for i in np.random.permutation(np.arange(1000000)).tolist())\nl = list(sort_generator(generator, 512))\ntest_eq(l[:512], sorted(l[:512]))\n\n\nsource\n\n\nget_subset_dict\n\n get_subset_dict (d, keys)\n\n\nkeys = string.ascii_lowercase\nvalues = np.arange(len(keys))\nd = {k:v for k,v in zip(keys,values)}\ntest_eq(get_subset_dict(d, ['a', 'k', 'j', 'e']), {'a': 0, 'k': 10, 'j': 9, 'e': 4})\n\n\nsource\n\n\nremove_dir\n\n remove_dir (directory, verbose=True)\n\n\nsource\n\n\ncreate_dir\n\n create_dir (directory, verbose=True)\n\n\npath = \"wandb3/wandb2/wandb\"\ncreate_dir(path)\nassert Path(path).exists()\n\npaths = [\"wandb3/wandb2/wandb\", \"wandb3/wandb2\", \"wandb\"]\nremove_dir(paths)\nfor p in paths:\n    assert not Path(p).exists()\n\npath = \"wandb3\"\nassert Path(path).exists()\nremove_dir(path)\nassert not Path(path).exists()\n\nwandb3/wandb2/wandb directory created.\nwandb3/wandb2/wandb directory removed.\nwandb3/wandb2 directory removed.\nwandb directory doesn't exist.\nwandb3 directory removed.\n\n\n\ncreate_dir('./test')\n\ntest directory created.\n\n\n\na = 5\ndef fn(b): return a + b\n\nWriting ./test/mod_dev.py\n\n\n\nfname = \"./test/mod_dev.py\"\nwhile True:\n    if fname[0] in \"/ .\": fname = fname.split(fname[0], 1)[1]\n    else: break\nif '/' in fname and fname.rsplit('/', 1)[0] not in sys.path: sys.path.append(fname.rsplit('/', 1)[0])\nmod = import_file_as_module(fname)\ntest_eq(mod.fn(3), 8)\nsys.path = sys.path[:-1]\nremove_dir('./test/')\n\ntest directory removed.\n\n\n\nsource\n\n\nnamed_partial\n\n named_partial (name, func, *args, **kwargs)\n\nCreate a partial function with a name\n\ndef add_1(x, add=1): return x+add\ntest_eq(add_1(1), 2)\nadd_2 = partial(add_1, add=2)\ntest_eq(add_2(2), 4)\ntest_ne(str(add_2), \"add_2\")\nadd_2 = named_partial('add_2', add_1, add=2)\ntest_eq(add_2(2), 4)\ntest_eq(str(add_2), \"add_2\")\n\nclass _A():\n    def __init__(self, add=1): self.add = add\n    def __call__(self, x): return x + self.add\n\ntest_eq(_A()(1), 2)\n_A2 = partial(_A, add=2)\ntest_eq(_A2()(1), 3)\ntest_ne(str(_A2), '_A2')\n_A2 = named_partial('_A2', _A, add=2)\ntest_eq(_A2()(1), 3)\ntest_eq(str(_A2), '_A2')\n\n\nsource\n\n\ndict2attrdict\n\n dict2attrdict (d:dict)\n\nConverts a (nested) dict to an AttrDict.\n\n\n\n\nType\nDetails\n\n\n\n\nd\ndict\na dict\n\n\n\n\nsource\n\n\nattrdict2dict\n\n attrdict2dict (d:dict)\n\nConverts a (nested) AttrDict dict to a dict.\n\n\n\n\nType\nDetails\n\n\n\n\nd\ndict\na dict\n\n\n\n\n# Test attrdict2dict\nd = AttrDict({'a': 1, 'b': AttrDict({'c': 2, 'd': 3})})\ntest_eq(attrdict2dict(d), {'a': 1, 'b': {'c': 2, 'd': 3}})\n# Test dict2attrdict\nd = {'a': 1, 'b': {'c': 2, 'd': 3}}\ntest_eq(dict2attrdict(d), AttrDict({'a': 1, 'b': AttrDict({'c': 2, 'd': 3})}))\n\n\nsource\n\n\nget_config\n\n get_config (file_path)\n\nGets a config from a yaml file.\n\nsource\n\n\nyaml2dict\n\n yaml2dict (file_path, attrdict=True)\n\nConverts a yaml file to a dict (optionally AttrDict).\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfile_path\n\n\na path to a yaml file\n\n\nattrdict\nbool\nTrue\nif True, convert output to AttrDict\n\n\n\n\nsource\n\n\ndict2yaml\n\n dict2yaml (d, file_path, sort_keys=False)\n\nConverts a dict to a yaml file.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd\n\n\na dict\n\n\nfile_path\n\n\na path to a yaml file\n\n\nsort_keys\nbool\nFalse\nif True, sort the keys\n\n\n\n\nprogram: wandb_scripts/train_script.py          # (required) Path to training script.\nmethod: bayes                                   # (required) Specify the search strategy: grid, random or bayes\nparameters:                                     # (required) Specify parameters bounds to search.\n   bs:\n      values: [32, 64, 128]\n   depth:\n      values: [3, 6, 9, 12]\n   fc_dropout:\n      distribution: uniform\n      min: 0.\n      max: 0.5\n   lr_max:\n      values: [0.001, 0.003, 0.01, 0.03, 0.1]\n   n_epoch:\n      values: [10, 15, 20]\n   nb_filters:\n      values: [32, 64, 128]\nname: LSST_sweep_01\nmetric:\n   name: accuracy                              # This must match one of the metrics in the training script\n   goal: maximize\nearly_terminate:\n   type: hyperband\n   min_iter: 3\nproject: LSST_wandb_hpo\n\nWriting sweep_config.yaml\n\n\n\nfname = \"sweep_config.yaml\"\nsweep_config = yaml2dict(fname)\nprint(sweep_config)\ntest_eq(sweep_config.method, 'bayes')\ntest_eq(sweep_config['metric'], {'name': 'accuracy', 'goal': 'maximize'})\nos.remove(fname)\n\n{'program': 'wandb_scripts/train_script.py', 'method': 'bayes', 'parameters': {'bs': {'values': [32, 64, 128]}, 'depth': {'values': [3, 6, 9, 12]}, 'fc_dropout': {'distribution': 'uniform', 'min': 0.0, 'max': 0.5}, 'lr_max': {'values': [0.001, 0.003, 0.01, 0.03, 0.1]}, 'n_epoch': {'values': [10, 15, 20]}, 'nb_filters': {'values': [32, 64, 128]}}, 'name': 'LSST_sweep_01', 'metric': {'name': 'accuracy', 'goal': 'maximize'}, 'early_terminate': {'type': 'hyperband', 'min_iter': 3}, 'project': 'LSST_wandb_hpo'}\n\n\n\nsource\n\n\nget_cat_cols\n\n get_cat_cols (df)\n\n\nsource\n\n\nget_cont_cols\n\n get_cont_cols (df)\n\n\nsource\n\n\nstr2index\n\n str2index (o)\n\n\nsource\n\n\nstr2list\n\n str2list (o)\n\n\nsource\n\n\nmap_array\n\n map_array (arr, dim=1)\n\n\nsource\n\n\nget_mapping\n\n get_mapping (arr, dim=1, return_counts=False)\n\n\na = np.asarray(alphabet[np.random.randint(0,15,30)]).reshape(10,3)\nb = np.asarray(ALPHABET[np.random.randint(6,10,30)]).reshape(10,3)\nx = concat(a,b,dim=1)\nmaps, counts = get_mapping(x, dim=1, return_counts=True)\nx, maps, counts\n\n(array([['d', 'k', 'l', 'I', 'I', 'G'],\n        ['g', 'i', 'l', 'I', 'J', 'I'],\n        ['e', 'l', 'n', 'G', 'H', 'I'],\n        ['e', 'l', 'a', 'I', 'H', 'G'],\n        ['k', 'l', 'b', 'I', 'I', 'J'],\n        ['c', 'f', 'k', 'I', 'H', 'I'],\n        ['e', 'j', 'f', 'I', 'H', 'J'],\n        ['n', 'd', 'g', 'G', 'J', 'J'],\n        ['d', 'f', 'a', 'I', 'H', 'H'],\n        ['i', 'c', 'm', 'J', 'G', 'G']], dtype='&lt;U1'),\n [(#7) ['c','d','e','g','i','k','n'],\n  (#7) ['c','d','f','i','j','k','l'],\n  (#8) ['a','b','f','g','k','l','m','n'],\n  (#3) ['G','I','J'],\n  (#4) ['G','H','I','J'],\n  (#4) ['G','H','I','J']],\n [7, 7, 8, 3, 4, 4])\n\n\n\nx = np.asarray(alphabet[np.random.randint(0,15,30)]).reshape(10,3)\nx, map_array(x), map_array(x, 1)\n\n(array([['i', 'm', 'd'],\n        ['h', 'm', 'g'],\n        ['i', 'g', 'd'],\n        ['k', 'm', 'n'],\n        ['n', 'j', 'l'],\n        ['n', 'l', 'i'],\n        ['f', 'c', 'k'],\n        ['i', 'm', 'a'],\n        ['l', 'i', 'f'],\n        ['k', 'o', 'g']], dtype='&lt;U1'),\n array([[2, 5, 1],\n        [1, 5, 3],\n        [2, 1, 1],\n        [3, 5, 7],\n        [5, 3, 6],\n        [5, 4, 4],\n        [0, 0, 5],\n        [2, 5, 0],\n        [4, 2, 2],\n        [3, 6, 3]]),\n array([[2, 5, 1],\n        [1, 5, 3],\n        [2, 1, 1],\n        [3, 5, 7],\n        [5, 3, 6],\n        [5, 4, 4],\n        [0, 0, 5],\n        [2, 5, 0],\n        [4, 2, 2],\n        [3, 6, 3]]))\n\n\n\nsource\n\n\nlog_tfm\n\n log_tfm (o, inplace=False)\n\nLog transforms an array-like object with positive and/or negative values\n\narr = np.asarray([-1000, -100, -10, -1, 0, 1, 10, 100, 1000]).astype(float)\nplt.plot(arr, log_tfm(arr, False))\nplt.show()\n\n\n\n\n\n\n\n\n\nt = tensor([-1000, -100, -10, -1, 0, 1, 10, 100, 1000]).float()\nplt.plot(t, log_tfm(t, False))\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nto_sincos_time\n\n to_sincos_time (arr, max_value)\n\n\narr = np.sort(np.random.rand(100) * 5)\narr_sin, arr_cos = to_sincos_time(arr, 5)\nplt.scatter(arr, arr_sin)\nplt.scatter(arr, arr_cos)\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nplot_feature_dist\n\n plot_feature_dist (X, percentiles=[0, 0.1, 0.5, 1, 5, 10, 25, 50, 75, 90,\n                    95, 99, 99.5, 99.9, 100])\n\n\narr = np.random.rand(10, 3, 100)\nplot_feature_dist(arr, percentiles=[0,0.1,0.5,1,5,10,25,50,75,90,95,99,99.5,99.9,100])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nrolling_moving_average\n\n rolling_moving_average (o, window=2)\n\n\na = np.arange(60).reshape(2,3,10).astype(float)\nt = torch.arange(60).reshape(2,3,10).float()\ntest_close(rolling_moving_average(a, window=3), rolling_moving_average(t, window=3).numpy())\nprint(t)\nprint(rolling_moving_average(t, window=3))\n\ntensor([[[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],\n         [10., 11., 12., 13., 14., 15., 16., 17., 18., 19.],\n         [20., 21., 22., 23., 24., 25., 26., 27., 28., 29.]],\n\n        [[30., 31., 32., 33., 34., 35., 36., 37., 38., 39.],\n         [40., 41., 42., 43., 44., 45., 46., 47., 48., 49.],\n         [50., 51., 52., 53., 54., 55., 56., 57., 58., 59.]]])\ntensor([[[ 0.0000,  0.5000,  1.0000,  2.0000,  3.0000,  4.0000,  5.0000,\n           6.0000,  7.0000,  8.0000],\n         [10.0000, 10.5000, 11.0000, 12.0000, 13.0000, 14.0000, 15.0000,\n          16.0000, 17.0000, 18.0000],\n         [20.0000, 20.5000, 21.0000, 22.0000, 23.0000, 24.0000, 25.0000,\n          26.0000, 27.0000, 28.0000]],\n\n        [[30.0000, 30.5000, 31.0000, 32.0000, 33.0000, 34.0000, 35.0000,\n          36.0000, 37.0000, 38.0000],\n         [40.0000, 40.5000, 41.0000, 42.0000, 43.0000, 44.0000, 45.0000,\n          46.0000, 47.0000, 48.0000],\n         [50.0000, 50.5000, 51.0000, 52.0000, 53.0000, 54.0000, 55.0000,\n          56.0000, 57.0000, 58.0000]]])\n\n\n\nsource\n\n\nfbfill_sequence\n\n fbfill_sequence (o)\n\nForward and backward fills an array-like object alongside sequence dimension\n\nsource\n\n\nbfill_sequence\n\n bfill_sequence (o)\n\nBackward fills an array-like object alongside sequence dimension\n\nsource\n\n\nffill_sequence\n\n ffill_sequence (o)\n\nForward fills an array-like object alongside sequence dimension\n\na = np.arange(80).reshape(2, 4, 10).astype(float)\nmask = np.random.rand(*a.shape)\na[mask &gt; .8] = np.nan\nt = torch.from_numpy(a)\nt\n\ntensor([[[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8., nan],\n         [10., 11., nan, nan, 14., 15., nan, 17., nan, 19.],\n         [20., 21., 22., 23., nan, 25., 26., 27., 28., 29.],\n         [30., 31., 32., 33., nan, 35., 36., 37., 38., 39.]],\n\n        [[40., 41., 42., 43., 44., 45., 46., 47., nan, 49.],\n         [nan, 51., nan, 53., 54., 55., nan, 57., 58., 59.],\n         [60., 61., 62., 63., 64., nan, nan, 67., 68., 69.],\n         [70., nan, 72., 73., 74., 75., 76., nan, 78., 79.]]],\n       dtype=torch.float64)\n\n\n\n# forward fill\nfilled_a = ffill_sequence(a)\nprint(filled_a)\nm = np.isnan(filled_a)\ntest_eq(filled_a[~m], ffill_sequence(t).numpy()[~m])\n\n[[[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  8.]\n  [10. 11. 11. 11. 14. 15. 15. 17. 17. 19.]\n  [20. 21. 22. 23. 23. 25. 26. 27. 28. 29.]\n  [30. 31. 32. 33. 33. 35. 36. 37. 38. 39.]]\n\n [[40. 41. 42. 43. 44. 45. 46. 47. 47. 49.]\n  [nan 51. 51. 53. 54. 55. 55. 57. 58. 59.]\n  [60. 61. 62. 63. 64. 64. 64. 67. 68. 69.]\n  [70. 70. 72. 73. 74. 75. 76. 76. 78. 79.]]]\n\n\n\n# backward fill\nfilled_a = bfill_sequence(a)\nprint(filled_a)\nm = np.isnan(filled_a)\ntest_eq(filled_a[~m], bfill_sequence(t).numpy()[~m])\n\n[[[ 0.  1.  2.  3.  4.  5.  6.  7.  8. nan]\n  [10. 11. 14. 14. 14. 15. 17. 17. 19. 19.]\n  [20. 21. 22. 23. 25. 25. 26. 27. 28. 29.]\n  [30. 31. 32. 33. 35. 35. 36. 37. 38. 39.]]\n\n [[40. 41. 42. 43. 44. 45. 46. 47. 49. 49.]\n  [51. 51. 53. 53. 54. 55. 57. 57. 58. 59.]\n  [60. 61. 62. 63. 64. 67. 67. 67. 68. 69.]\n  [70. 72. 72. 73. 74. 75. 76. 78. 78. 79.]]]\n\n\n\n# forward & backward fill\nfilled_a = fbfill_sequence(a)\nprint(filled_a)\nm = np.isnan(filled_a)\ntest_eq(filled_a[~m], fbfill_sequence(t).numpy()[~m])\n\n[[[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  8.]\n  [10. 11. 11. 11. 14. 15. 15. 17. 17. 19.]\n  [20. 21. 22. 23. 23. 25. 26. 27. 28. 29.]\n  [30. 31. 32. 33. 33. 35. 36. 37. 38. 39.]]\n\n [[40. 41. 42. 43. 44. 45. 46. 47. 47. 49.]\n  [51. 51. 51. 53. 54. 55. 55. 57. 58. 59.]\n  [60. 61. 62. 63. 64. 64. 64. 67. 68. 69.]\n  [70. 70. 72. 73. 74. 75. 76. 76. 78. 79.]]]\n\n\n\nsource\n\n\ndummify\n\n dummify (o:Union[numpy.ndarray,torch.Tensor], by_var:bool=True,\n          inplace:bool=False, skip:Optional[list]=None, random_state=None)\n\nShuffles an array-like object along all dimensions or dimension 1 (variables) if by_var is True.\n\narr = np.random.rand(2,3,10)\narr_original = arr.copy()\ndummy_arr = dummify(arr)\ntest_ne(arr_original, dummy_arr)\ntest_eq(arr_original, arr)\ndummify(arr, inplace=True)\ntest_ne(arr_original, arr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nt = torch.rand(2,3,10)\nt_original = t.clone()\ndummy_t = dummify(t)\ntest_ne(t_original, dummy_t)\ntest_eq(t_original, t)\ndummify(t, inplace=True)\ntest_ne(t_original, t)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nshuffle_along_axis\n\n shuffle_along_axis (o, axis=-1, random_state=None)\n\n\nX = np.arange(60).reshape(2,3,10) + 10\nX_shuffled = shuffle_along_axis(X,(0, -1), random_state=23)\ntest_eq(X_shuffled, np.array([[[13, 15, 41, 14, 40, 49, 18, 42, 47, 46],\n                               [28, 56, 53, 50, 52, 25, 24, 57, 51, 59],\n                               [34, 30, 38, 35, 69, 66, 63, 67, 61, 62]],\n\n                              [[19, 10, 11, 16, 43, 12, 17, 48, 45, 44],\n                               [23, 20, 26, 22, 21, 27, 58, 29, 54, 55],\n                               [36, 31, 39, 60, 33, 68, 37, 32, 65, 64]]]))\n\n\nsource\n\n\nanalyze_array\n\n analyze_array (o, bins=100, density=False, feature_names=None,\n                clip_outliers_plot=False, quantile_range=(25.0, 75.0),\n                percentiles=[1, 25, 50, 75, 99], text_len=12, figsize=(10,\n                6))\n\n\nsource\n\n\nanalyze_feature\n\n analyze_feature (feature, bins=100, density=False, feature_name=None,\n                  clip_outliers_plot=False, quantile_range=(25.0, 75.0),\n                  percentiles=[1, 25, 50, 75, 99], text_len=12,\n                  figsize=(10, 6))\n\n\nx = np.random.normal(size=(1000))\nanalyze_array(x)\n\n array shape: (1000,)\n       dtype: float64\n  nan values: 0.0%\n         max: 3.581094060980321\n           1: -2.1615590829115185\n          25: -0.5910961139851849\n          50: -0.002247946765973052\n          75: 0.6259274030927355\n          99: 2.3412961380708084\n         min: -2.9413736207935037\n outlier min: -2.416631389602066\n outlier max: 2.4514626787096163\n    outliers: 1.3%\n        mean: 0.0252125277963861\n         std: 0.946955486669799\n normal dist: True\n\n\n\n\n\n\n\n\n\n\nx1 = np.random.normal(size=(1000,2))\nx2 = np.random.normal(3, 5, size=(1000,2))\nx = x1 + x2\nanalyze_array(x)\n\n array shape: (1000, 2)\n\n  0  feature: 0\n\n       dtype: float64\n  nan values: 0.0%\n         max: 20.323075761234193\n           1: -8.260661592413742\n          25: -0.6268118569038604\n          50: 2.7491159998190335\n          75: 6.1659732833324234\n          99: 15.387037197243288\n         min: -13.122296090020368\n outlier min: -10.815989567258287\n outlier max: 16.35515099368685\n    outliers: 0.9%\n        mean: 2.9347218553275445\n         std: 5.134940196769919\n normal dist: True\n\n\n\n\n\n\n\n\n\n\n  1  feature: 1\n\n       dtype: float64\n  nan values: 0.0%\n         max: 19.86661808715871\n           1: -8.727124941895372\n          25: -0.45908489661153007\n          50: 2.875134866985423\n          75: 6.288434737224429\n          99: 14.424046274543118\n         min: -10.963913297285615\n outlier min: -10.58036434736547\n outlier max: 16.409714187978366\n    outliers: 0.6%\n        mean: 2.9552584127690014\n         std: 4.99683092772426\n normal dist: True\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nget_relpath\n\n get_relpath (path)\n\n\nsource\n\n\nto_root_path\n\n to_root_path (path)\n\nConverts a path to an absolute path from the root directory of the repository.\n\nsource\n\n\nget_root\n\n get_root ()\n\nReturns the root directory of the git repository.\n\nsource\n\n\nsplit_in_chunks\n\n split_in_chunks (o, chunksize, start=0, shuffle=False, drop_last=False)\n\n\na = np.arange(5, 15)\ntest_eq(split_in_chunks(a, 3, drop_last=False), [array([5, 6, 7]), array([ 8,  9, 10]), array([11, 12, 13]), array([14])])\ntest_eq(split_in_chunks(a, 3, drop_last=True), [array([5, 6, 7]), array([ 8,  9, 10]), array([11, 12, 13])])\ntest_eq(split_in_chunks(a, 3, start=2, drop_last=True), [array([7, 8, 9]), array([10, 11, 12])])\n\n\nsource\n\n\nload_object\n\n load_object (file_path)\n\n\nsource\n\n\nsave_object\n\n save_object (o, file_path, verbose=True)\n\n\nsplit = np.arange(100)\nsave_object(split, file_path='data/test')\nsplit2 = load_object('data/test.pkl')\ntest_eq(split, split2)\n\ndata directory already exists.\nndarray saved as data/test.pkl\n\n\n\nsplits = L([[[0,1,2,3,4], [5,6,7,8,9]],[[10,11,12,13,14], [15,16,17,18,19]]])\nsave_object(splits, file_path=Path('data/test'))\nsplits2 = load_object('data/test')\ntest_eq(splits, splits2)\n\ndata directory already exists.\nL saved as data/test.pkl\n\n\n\nsource\n\n\nget_idxs_to_keep\n\n get_idxs_to_keep (o, cond, crit='all', invert=False, axis=(1, 2),\n                   keepdims=False)\n\n\na = np.random.rand(100, 2, 10)\na[a &gt; .95] = np.nan\nidxs_to_keep = get_idxs_to_keep(a, np.isfinite)\nif idxs_to_keep.size&gt;0:\n    test_eq(np.isnan(a[idxs_to_keep]).sum(), 0)\n\n\nsource\n\n\nzerofy\n\n zerofy (a, stride, keep=False)\n\nCreate copies of an array setting individual/ group values to zero\n\nstride = 3\na = np.arange(2*5).reshape(2,5) + 1\n\nzerofy(a, stride, keep=False)\n\narray([[[ 0.,  0.,  3.,  4.,  5.],\n        [ 6.,  7.,  8.,  9., 10.]],\n\n       [[ 1.,  2.,  0.,  0.,  0.],\n        [ 6.,  7.,  8.,  9., 10.]],\n\n       [[ 1.,  2.,  3.,  4.,  5.],\n        [ 0.,  0.,  8.,  9., 10.]],\n\n       [[ 1.,  2.,  3.,  4.,  5.],\n        [ 6.,  7.,  0.,  0.,  0.]]])\n\n\n\nsource\n\n\nfeat2list\n\n feat2list (o)\n\n\na = 'a'\ntest_eq(feat2list(a), ['a'])\na = ['a', 'b']\ntest_eq(feat2list(a), ['a', 'b'])\na = None\ntest_eq(feat2list(a), [])\n\n\nsource\n\n\nsmallest_dtype\n\n smallest_dtype (num, use_unsigned=False)\n\nFind the smallest dtype that can safely hold num\n\ntest_eq(smallest_dtype(3654), 'int16')\ntest_eq(smallest_dtype(2048.), 'float16')\ntest_eq(smallest_dtype(365454), 'int32')\ntest_eq(smallest_dtype(365454.), 'float32')\ntest_eq(smallest_dtype(3654545134897), 'int64')\n\n\nsource\n\n\nplot_forecast\n\n plot_forecast (X_true, y_true, y_pred, sel_vars=None, idx=None,\n                figsize=(8, 4), n_samples=1)\n\n\nsource\n\n\nstr2callable\n\n str2callable (object_path:str=None)\n\nTransform a string into a callable object without importing it in the script.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nobject_path\nstr\nNone\nThe string representing the object path.\n\n\n\n\n# test showing you don't need to import the object in the script. The library needs to be installed though.\ntry:\n    pyts\nexcept Exception as e:\n    print(0, e)\ntry:\n    pyts.image\nexcept Exception as e:\n    print(1, e)\ntry:\n    gasf = eval(\"pyts.image.GramianAngularField(method='summation')\")\n    print(f\"2 success: {gasf}\")\nexcept Exception as e:\n    print(2, e)\ntry:\n    gasf = str2callable(\"pyts.image.GramianAngularField(method='summation')\")\n    print(f\"3 success: {gasf}\")\nexcept Exception as e:\n    print(3, e)\n\n0 name 'pyts' is not defined\n1 name 'pyts' is not defined\n2 name 'pyts' is not defined\n3 success: GramianAngularField()",
    "crumbs": [
      "Utilities"
    ]
  },
  {
    "objectID": "data.mixed.html",
    "href": "data.mixed.html",
    "title": "Mixed data",
    "section": "",
    "text": "DataLoader than can take data from multiple dataloaders with different types of data\n\n\nsource\n\nMixedDataLoaders\n\n MixedDataLoaders (*loaders, path:str|pathlib.Path='.', device=None)\n\nBasic wrapper around several DataLoaders.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nloaders\nVAR_POSITIONAL\n\nDataLoader objects to wrap\n\n\npath\nstr | pathlib.Path\n.\nPath to store export objects\n\n\ndevice\nNoneType\nNone\nDevice to put DataLoaders\n\n\n\n\nsource\n\n\nMixedDataLoader\n\n MixedDataLoader (*loaders, path='.', shuffle=False, device=None, bs=None)\n\nAccepts any number of DataLoader and a device\n\nsource\n\n\nget_mixed_dls\n\n get_mixed_dls (*dls, device=None, shuffle_train=None, shuffle_valid=None,\n                **kwargs)\n\n\nfrom tsai.data.tabular import *\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\n# df['salary'] = np.random.rand(len(df)) # uncomment to simulate a cont dependent variable\ntarget = 'salary'\nsplits = RandomSplitter()(range_of(df))\n\ncat_names = ['workclass', 'education', 'marital-status']\ncont_names = ['age', 'fnlwgt']\ndls1 = get_tabular_dls(df, cat_names=cat_names, cont_names=cont_names, y_names=target, splits=splits, bs=512)\ndls1.show_batch()\n\ncat_names = None #['occupation', 'relationship', 'race']\ncont_names = ['education-num']\ndls2 = get_tabular_dls(df, cat_names=cat_names, cont_names=cont_names, y_names=target, splits=splits, bs=128)\ndls2.show_batch()\n\n\n\n\n\nworkclass\neducation\nmarital-status\nage\nfnlwgt\nsalary\n\n\n\n\n0\nPrivate\nBachelors\nMarried-civ-spouse\n38.0\n95335.998904\n&gt;=50k\n\n\n1\nPrivate\nHS-grad\nNever-married\n23.0\n292023.001113\n&lt;50k\n\n\n2\nSelf-emp-not-inc\nHS-grad\nNever-married\n37.0\n154641.001507\n&lt;50k\n\n\n3\nPrivate\nHS-grad\nDivorced\n35.0\n82621.994134\n&lt;50k\n\n\n4\nLocal-gov\nBachelors\nNever-married\n33.0\n161942.000197\n&lt;50k\n\n\n5\nSelf-emp-inc\nHS-grad\nMarried-civ-spouse\n65.0\n81412.997852\n&lt;50k\n\n\n6\nPrivate\nHS-grad\nMarried-civ-spouse\n43.0\n122749.002328\n&lt;50k\n\n\n7\nPrivate\nSome-college\nMarried-civ-spouse\n35.0\n163391.999564\n&lt;50k\n\n\n8\nPrivate\nHS-grad\nMarried-civ-spouse\n35.0\n214890.999959\n&lt;50k\n\n\n9\nPrivate\nBachelors\nNever-married\n22.0\n140000.999474\n&lt;50k\n\n\n\n\n\n\n\n\n\neducation-num_na\neducation-num\nsalary\n\n\n\n\n0\nFalse\n14.0\n&lt;50k\n\n\n1\nFalse\n9.0\n&lt;50k\n\n\n2\nFalse\n10.0\n&lt;50k\n\n\n3\nTrue\n10.0\n&lt;50k\n\n\n4\nFalse\n9.0\n&lt;50k\n\n\n5\nFalse\n10.0\n&lt;50k\n\n\n6\nFalse\n9.0\n&lt;50k\n\n\n7\nFalse\n13.0\n&lt;50k\n\n\n8\nFalse\n9.0\n&lt;50k\n\n\n9\nFalse\n9.0\n&gt;=50k\n\n\n\n\n\n\ndls = get_mixed_dls(dls1, dls2, bs=8)\nfirst(dls.train)\nfirst(dls.valid)\ntorch.save(dls,'export/mixed_dls.pth')\ndel dls\ndls = torch.load('export/mixed_dls.pth', weights_only=False)\ndls.train.show_batch()\n\n\n\n\n\nworkclass\neducation\nmarital-status\nage\nfnlwgt\nsalary\n\n\n\n\n0\nPrivate\nSome-college\nMarried-civ-spouse\n23.0\n38706.999913\n&gt;=50k\n\n\n1\nPrivate\nBachelors\nNever-married\n43.0\n351576.003599\n&gt;=50k\n\n\n2\nLocal-gov\n10th\nMarried-civ-spouse\n42.0\n180984.999698\n&gt;=50k\n\n\n3\nLocal-gov\nBachelors\nNever-married\n34.0\n183800.999868\n&lt;50k\n\n\n4\nPrivate\nHS-grad\nMarried-civ-spouse\n39.0\n230329.000550\n&lt;50k\n\n\n5\nPrivate\n10th\nMarried-civ-spouse\n51.0\n41473.998101\n&lt;50k\n\n\n6\nPrivate\nHS-grad\nMarried-civ-spouse\n41.0\n90021.001512\n&lt;50k\n\n\n7\nPrivate\nAssoc-acdm\nNever-married\n30.0\n251825.001788\n&lt;50k\n\n\n\n\n\n\n\n\n\neducation-num_na\neducation-num\nsalary\n\n\n\n\n0\nFalse\n12.0\n&lt;50k\n\n\n1\nFalse\n9.0\n&lt;50k\n\n\n2\nFalse\n13.0\n&lt;50k\n\n\n3\nFalse\n10.0\n&gt;=50k\n\n\n4\nFalse\n15.0\n&gt;=50k\n\n\n5\nFalse\n13.0\n&lt;50k\n\n\n6\nFalse\n10.0\n&lt;50k\n\n\n7\nFalse\n13.0\n&gt;=50k\n\n\n\n\n\n\nfrom tsai.data.validation import TimeSplitter\nfrom tsai.data.core import TSRegression, get_ts_dls\n\n\nX = np.repeat(np.repeat(np.arange(16)[:, None, None], 2, 1), 5, 2).astype(float)\ny = np.concatenate([np.arange(len(X)//2)]*2)\nalphabet = np.array(list(string.ascii_lowercase))\n# y = alphabet[y]\nsplits = TimeSplitter(.5, show_plot=False)(range_of(X))\ntfms = [None, TSRegression()]\ndls1 = get_ts_dls(X, y, splits=splits, tfms=tfms, bs=4)\nfor xb, yb in iter(dls1.train):\n    print(xb.data, yb)\n\ntensor([[[1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1.]],\n\n        [[3., 3., 3., 3., 3.],\n         [3., 3., 3., 3., 3.]],\n\n        [[2., 2., 2., 2., 2.],\n         [2., 2., 2., 2., 2.]],\n\n        [[5., 5., 5., 5., 5.],\n         [5., 5., 5., 5., 5.]]], device='mps:0') tensor([1., 3., 2., 5.], device='mps:0')\ntensor([[[6., 6., 6., 6., 6.],\n         [6., 6., 6., 6., 6.]],\n\n        [[0., 0., 0., 0., 0.],\n         [0., 0., 0., 0., 0.]],\n\n        [[7., 7., 7., 7., 7.],\n         [7., 7., 7., 7., 7.]],\n\n        [[4., 4., 4., 4., 4.],\n         [4., 4., 4., 4., 4.]]], device='mps:0') tensor([6., 0., 7., 4.], device='mps:0')\n\n\n\ndata = np.repeat(np.arange(16)[:, None], 3, 1)*np.array([1, 10, 100])\ndf = pd.DataFrame(data, columns=['cat1', 'cat2', 'cont'])\ndf['cont'] = df['cont'].astype(float)\ndf['target'] = y\ndisplay(df)\ncat_names = ['cat1', 'cat2']\ncont_names = ['cont']\ntarget = 'target'\ndls2 = get_tabular_dls(df, procs=[Categorify, FillMissing, #Normalize\n                                 ], cat_names=cat_names, cont_names=cont_names, y_names=target, splits=splits, bs=4)\nfor b in iter(dls2.train):\n    print(b[0], b[1], b[2])\n\n\n\n\n\n\n\n\ncat1\ncat2\ncont\ntarget\n\n\n\n\n0\n0\n0\n0.0\n0\n\n\n1\n1\n10\n100.0\n1\n\n\n2\n2\n20\n200.0\n2\n\n\n3\n3\n30\n300.0\n3\n\n\n4\n4\n40\n400.0\n4\n\n\n5\n5\n50\n500.0\n5\n\n\n6\n6\n60\n600.0\n6\n\n\n7\n7\n70\n700.0\n7\n\n\n8\n8\n80\n800.0\n0\n\n\n9\n9\n90\n900.0\n1\n\n\n10\n10\n100\n1000.0\n2\n\n\n11\n11\n110\n1100.0\n3\n\n\n12\n12\n120\n1200.0\n4\n\n\n13\n13\n130\n1300.0\n5\n\n\n14\n14\n140\n1400.0\n6\n\n\n15\n15\n150\n1500.0\n7\n\n\n\n\n\n\n\ntensor([[8, 8],\n        [6, 6],\n        [2, 2],\n        [4, 4]], device='mps:0') tensor([[700.],\n        [500.],\n        [100.],\n        [300.]], device='mps:0') tensor([[7],\n        [5],\n        [1],\n        [3]], device='mps:0', dtype=torch.int8)\ntensor([[6, 6],\n        [3, 3],\n        [1, 1],\n        [6, 6]], device='mps:0') tensor([[500.],\n        [200.],\n        [  0.],\n        [500.]], device='mps:0') tensor([[5],\n        [2],\n        [0],\n        [5]], device='mps:0', dtype=torch.int8)\n\n\n\nbs = 8\ndls = get_mixed_dls(dls1, dls2, bs=bs)\ndl = dls.train\nxb, yb = dl.one_batch()\ntest_eq(len(xb), 2)\ntest_eq(len(xb[0]), bs)\ntest_eq(len(xb[1]), 2)\ntest_eq(len(xb[1][0]), bs)\ntest_eq(len(xb[1][1]), bs)\ntest_eq(xb[0].data[:, 0, 0].long(), xb[1][0][:, 0] - 1) # categorical data and ts are in synch\ntest_eq(xb[0].data[:, 0, 0], (xb[1][1]/100).flatten()) # continuous data and ts are in synch\ntest_eq(tensor(dl.input_idxs), yb.long().cpu())\ndl = dls.valid\nxb, yb = dl.one_batch()\ntest_eq(tensor(y[dl.input_idxs]), yb.long().cpu())\n\n\nbs = 4\ndls = get_mixed_dls(dls1, dls2, bs=bs)\nfor xb, yb in iter(dls.train):\n    print(xb[0].data, xb[1], yb)\n\ntensor([[[1., 1., 1., 1., 1.],\n         [1., 1., 1., 1., 1.]],\n\n        [[2., 2., 2., 2., 2.],\n         [2., 2., 2., 2., 2.]],\n\n        [[4., 4., 4., 4., 4.],\n         [4., 4., 4., 4., 4.]],\n\n        [[6., 6., 6., 6., 6.],\n         [6., 6., 6., 6., 6.]]], device='mps:0') (tensor([[2, 2],\n        [3, 3],\n        [5, 5],\n        [7, 7]], device='mps:0'), tensor([[100.],\n        [200.],\n        [400.],\n        [600.]], device='mps:0')) tensor([1., 2., 4., 6.], device='mps:0')\ntensor([[[0., 0., 0., 0., 0.],\n         [0., 0., 0., 0., 0.]],\n\n        [[3., 3., 3., 3., 3.],\n         [3., 3., 3., 3., 3.]],\n\n        [[5., 5., 5., 5., 5.],\n         [5., 5., 5., 5., 5.]],\n\n        [[7., 7., 7., 7., 7.],\n         [7., 7., 7., 7., 7.]]], device='mps:0') (tensor([[1, 1],\n        [4, 4],\n        [6, 6],\n        [8, 8]], device='mps:0'), tensor([[  0.],\n        [300.],\n        [500.],\n        [700.]], device='mps:0')) tensor([0., 3., 5., 7.], device='mps:0')",
    "crumbs": [
      "Data",
      "Mixed data"
    ]
  },
  {
    "objectID": "models.tcn.html",
    "href": "models.tcn.html",
    "title": "TCN",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza (oguiza@timeseriesAI.co) based on:\n\nBai, S., Kolter, J. Z., & Koltun, V. (2018). An empirical evaluation of generic convolutional and recurrent networks for sequence modeling. arXiv preprint arXiv:1803.01271.\nOfficial TCN PyTorch implementation: https://github.com/locuslab/TCN\n\n\nsource\n\nTCN\n\n TCN (c_in, c_out, layers=[25, 25, 25, 25, 25, 25, 25, 25], ks=7,\n      conv_dropout=0.0, fc_dropout=0.0)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nTemporalConvNet\n\n TemporalConvNet (c_in, layers, ks=2, dropout=0.0)\n\n\nsource\n\n\nTemporalBlock\n\n TemporalBlock (ni, nf, ks, stride, dilation, padding, dropout=0.0)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nnvars = 3\nseq_len = 128\nc_out = 2\nxb = torch.rand(bs, nvars, seq_len)\nmodel = TCN(nvars, c_out, fc_dropout=.5)\ntest_eq(model(xb).shape, (bs, c_out))\nmodel = TCN(nvars, c_out, conv_dropout=.2)\ntest_eq(model(xb).shape, (bs, c_out))\nmodel = TCN(nvars, c_out)\ntest_eq(model(xb).shape, (bs, c_out))\nmodel\n\nTCN(\n  (tcn): Sequential(\n    (0): TemporalBlock(\n      (conv1): Conv1d(3, 25, kernel_size=(7,), stride=(1,), padding=(6,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(6,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(3, 25, kernel_size=(7,), stride=(1,), padding=(6,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(6,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (downsample): Conv1d(3, 25, kernel_size=(1,), stride=(1,))\n      (relu): ReLU()\n    )\n    (1): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(12,), dilation=(2,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(12,), dilation=(2,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(12,), dilation=(2,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(12,), dilation=(2,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n    (2): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(24,), dilation=(4,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(24,), dilation=(4,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(24,), dilation=(4,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(24,), dilation=(4,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n    (3): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(48,), dilation=(8,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(48,), dilation=(8,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(48,), dilation=(8,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(48,), dilation=(8,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n    (4): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(96,), dilation=(16,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(96,), dilation=(16,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(96,), dilation=(16,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(96,), dilation=(16,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n    (5): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(192,), dilation=(32,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(192,), dilation=(32,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(192,), dilation=(32,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(192,), dilation=(32,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n    (6): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(384,), dilation=(64,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(384,), dilation=(64,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(384,), dilation=(64,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(384,), dilation=(64,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n    (7): TemporalBlock(\n      (conv1): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(768,), dilation=(128,))\n      (chomp1): Chomp1d()\n      (relu1): ReLU()\n      (dropout1): Dropout(p=0.0, inplace=False)\n      (conv2): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(768,), dilation=(128,))\n      (chomp2): Chomp1d()\n      (relu2): ReLU()\n      (dropout2): Dropout(p=0.0, inplace=False)\n      (net): Sequential(\n        (0): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(768,), dilation=(128,))\n        (1): Chomp1d()\n        (2): ReLU()\n        (3): Dropout(p=0.0, inplace=False)\n        (4): Conv1d(25, 25, kernel_size=(7,), stride=(1,), padding=(768,), dilation=(128,))\n        (5): Chomp1d()\n        (6): ReLU()\n        (7): Dropout(p=0.0, inplace=False)\n      )\n      (relu): ReLU()\n    )\n  )\n  (gap): GAP1d(\n    (gap): AdaptiveAvgPool1d(output_size=1)\n    (flatten): Flatten(full=False)\n  )\n  (linear): Linear(in_features=25, out_features=2, bias=True)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "TCN"
    ]
  },
  {
    "objectID": "models.gatedtabtransformer.html",
    "href": "models.gatedtabtransformer.html",
    "title": "GatedTabTransformer",
    "section": "",
    "text": "This implementation is based on:\n\nCholakov, R., & Kolev, T. (2022). The GatedTabTransformer. An enhanced deep learning architecture for tabular modeling. arXiv preprint arXiv:2201.00199. arXiv preprint https://arxiv.org/abs/2201.00199\nHuang, X., Khetan, A., Cvitkovic, M., & Karnin, Z. (2020). TabTransformer: Tabular Data Modeling Using Contextual Embeddings. arXiv preprint https://arxiv.org/pdf/2012.06678\n\nOfficial repo: https://github.com/radi-cho/GatedTabTransformer\n\nsource\n\nGatedTabTransformer\n\n GatedTabTransformer (classes, cont_names, c_out, column_embed=True,\n                      add_shared_embed=False, shared_embed_div=8,\n                      embed_dropout=0.1, drop_whole_embed=False,\n                      d_model=32, n_layers=6, n_heads=8, d_k=None,\n                      d_v=None, d_ff=None, res_attention=True,\n                      attention_act='gelu', res_dropout=0.1,\n                      norm_cont=True, mlp_d_model=32, mlp_d_ffn=64,\n                      mlp_layers=4)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nfrom fastcore.test import test_eq\nfrom fastcore.basics import first\nfrom fastai.data.external import untar_data, URLs\nfrom fastai.tabular.data import TabularDataLoaders\nfrom fastai.tabular.core import Categorify, FillMissing\nfrom fastai.data.transforms import Normalize\nimport pandas as pd\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\ndls = TabularDataLoaders.from_csv(path/'adult.csv', path=path, y_names=\"salary\",\n    cat_names = ['workclass', 'education', 'marital-status', 'occupation', 'relationship', 'race'],\n    cont_names = ['age', 'fnlwgt', 'education-num'],\n    procs = [Categorify, FillMissing, Normalize])\nx_cat, x_cont, yb = first(dls.train)\nmodel = GatedTabTransformer(dls.classes, dls.cont_names, dls.c)\ntest_eq(model(x_cat, x_cont).shape, (dls.train.bs, dls.c))",
    "crumbs": [
      "Models",
      "Tabular models",
      "GatedTabTransformer"
    ]
  },
  {
    "objectID": "data.validation.html",
    "href": "data.validation.html",
    "title": "Spliting data",
    "section": "",
    "text": "Functions required to perform cross-validation and transform unique time series sequence into multiple samples ready to be used by a time series model.\n\n\nsource\n\nRandomSplitter\n\n RandomSplitter (valid_pct=0.2, seed=None)\n\nCreate function that splits items between train/val with valid_pct randomly.\n\nsource\n\n\nbalance_idx\n\n balance_idx (o, shuffle=False, strategy='oversample', random_state=None,\n              verbose=False)\n\n\nsource\n\n\nleakage_finder\n\n leakage_finder (*splits, verbose=True)\n\nYou can pass splits as a tuple, or train, valid, …\n\nsource\n\n\ncheck_splits_overlap\n\n check_splits_overlap (splits)\n\n\nsource\n\n\ncheck_overlap\n\n check_overlap (a, b, c=None)\n\nChecks if there’s overlap between array-like objects\n\na = np.arange(10)\nb = np.arange(10, 20)\ntest_eq(check_overlap(a, b), False)\na = np.arange(10)\nb = np.arange(9, 20)\ntest_eq(check_overlap(a, b), [9])\na = np.arange(10)\nb = np.arange(10, 20)\nc = np.arange(20, 30)\ntest_eq(check_overlap(a, b, c), False)\na = np.arange(10)\nb = np.arange(10, 20)\nc = np.arange(10, 30)\ntest_eq(check_overlap(a, b, c), ([], [], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]))\n\n\ny = np.concatenate([[i] * np.random.randint(10, 100) for i in range(5)])\ntrain_split = np.random.choice(len(y), int(len(y) * .8), False)\nc, v = np.unique(y[train_split], return_counts=True)\nprint(f\"{'imbalanced:':25} {c} {v}\")\n\noversampled_train_split = train_split[balance_idx(y[train_split], strategy=\"oversample\")]\nosc, osv = np.unique(y[oversampled_train_split], return_counts=True)\nprint(f\"{'balanced (oversample):':25} {osc} {osv}\")\ntest_eq(osv, [max(v)] * len(v))\n\nundersampled_train_split = train_split[balance_idx(y[train_split], strategy=\"undersample\")]\nusc, usv = np.unique(y[undersampled_train_split], return_counts=True)\nprint(f\"{'balanced (undersample):':25} {usc} {usv}\")\ntest_eq(usv, [min(v)] * len(v))\n\nimbalanced:               [0 1 2 3 4] [24 43 64 41  8]\nbalanced (oversample):    [0 1 2 3 4] [64 64 64 64 64]\nbalanced (undersample):   [0 1 2 3 4] [8 8 8 8 8]\n\n\n\nl = L(list(concat(np.zeros(5), np.ones(10)).astype(int)))\nbalanced_idx = balance_idx(l)\ntest_eq(np.mean(l[balanced_idx]), 0.5)\ntest_eq(isinstance(balanced_idx, L), True)\n\nl = list(concat(np.zeros(5), np.ones(10)).astype(int))\nbalanced_idx = balance_idx(l)\ntest_eq(np.mean(L(l)[balanced_idx]), 0.5)\ntest_eq(isinstance(balanced_idx, L), True)\n\na = concat(np.zeros(5), np.ones(10)).astype(int)\nbalanced_idx = balance_idx(a)\ntest_eq(np.mean(a[balanced_idx]), 0.5)\ntest_eq(isinstance(balanced_idx, L), True)\n\nt = concat(torch.zeros(5), torch.ones(10))\nbalanced_idx = balance_idx(t, shuffle=True)\ntest_eq(t[balanced_idx].mean(), 0.5)\ntest_eq(isinstance(balanced_idx, L), True)\n\n\na, b = np.arange(100_000), np.arange(100_000, 200_000)\n\n\nsoft_labels = True\nfilter_pseudolabels = .5\nbalanced_pseudolabels = True\n\npseudolabels = torch.rand(1000, 3)\npseudolabels = torch.softmax(pseudolabels, -1) if soft_labels else torch.argmax(pseudolabels, -1)\nhpl = torch.argmax(pseudolabels, -1) if soft_labels else pseudolabels\n\nif filter_pseudolabels and pseudolabels.ndim &gt; 1:\n    error = 1 - pseudolabels.max(-1).values\n    filt_pl_idx = np.arange(len(error))[error &lt; filter_pseudolabels]\n    filt_pl = pseudolabels[error &lt; filter_pseudolabels]\n    assert len(filt_pl) &gt; 0, 'no filtered pseudolabels'\n    filt_hpl = torch.argmax(filt_pl, -1)\nelse:\n    filt_pl_idx = np.arange(len(pseudolabels))\n    filt_pl = filt_hpl = pseudolabels\n\n\npl_split = filt_pl_idx[balance_idx(filt_hpl)] if balanced_pseudolabels else filt_pl_idx\ntest_eq(hpl[pl_split].float().mean(), np.mean(np.unique(hpl)))\n\n\nsource\n\n\nTrainValidTestSplitter\n\n TrainValidTestSplitter (n_splits:int=1, valid_size:Union[float,int]=0.2,\n                         test_size:Union[float,int]=0.0,\n                         train_only:bool=False, stratify:bool=True,\n                         balance:bool=False, strategy:str='oversample',\n                         shuffle:bool=True,\n                         random_state:Optional[int]=None,\n                         verbose:bool=False, **kwargs)\n\nSplit items into random train, valid (and test optional) subsets.\n\nsource\n\n\nplot_splits\n\n plot_splits (splits)\n\n\nsource\n\n\nget_splits\n\n get_splits (o, n_splits:int=1, valid_size:float=0.2, test_size:float=0.0,\n             train_only:bool=False,\n             train_size:Union[NoneType,float,int]=None,\n             balance:bool=False, strategy:str='oversample',\n             shuffle:bool=True, stratify:bool=True,\n             check_splits:bool=True, random_state:Optional[int]=None,\n             show_plot:bool=True, verbose:bool=False)\n\nArguments: o : object to which splits will be applied, usually target. n_splits : number of folds. Must be an int &gt;= 1. valid_size : size of validation set. Only used if n_splits = 1. If n_splits &gt; 1 valid_size = (1. - test_size) / n_splits. test_size : size of test set. Default = 0. train_only : if True valid set == train set. This may be useful for debugging purposes. train_size : size of the train set used. Default = None (the remainder after assigning both valid and test). Useful for to get learning curves with different train sizes or get a small batch to debug a neural net. balance : whether to balance data so that train always contain the same number of items per class. strategy : strategy to balance data (“undersample” or “oversample”). Default = “oversample”. shuffle : whether to shuffle data before splitting into batches. Note that the samples within each split will be shuffle. stratify : whether to create folds preserving the percentage of samples for each class. check_splits : whether to perform leakage and completion checks. random_state : when shuffle is True, random_state affects the ordering of the indices. Pass an int for reproducible output. show_plot : plot the split distribution\n\nn_splits                = 5\nvalid_size              = 0.2\ntest_size               = 0.2\ntrain_only              = False  # set to True for debugging (valid = train)\ntrain_size              = 5000\nstratify                = True\nbalance                 = False\nshuffle                 = True\npredefined_splits       = None\nshow_plot               = True\n\n\ncheck_splits = True\nrandom_state = 23\n\ny = np.random.randint(0, 3, 10000) + 100\n\nsplits = get_splits(y, n_splits=n_splits, valid_size=valid_size, test_size=test_size, shuffle=shuffle, balance=balance, stratify=stratify,\n                    train_only=train_only, train_size=train_size, check_splits=check_splits, random_state=random_state, show_plot=show_plot, verbose=True)\nsplits\n\n\n\n\n\n\n\n\n(((#5000) [3490,2428,4475,8317,2802,6834,2954,7671,3383,9554...],\n  (#1600) [1680,6677,5879,4428,5511,8312,372,5127,7012,3021...],\n  (#2000) [1263,6498,1602,1838,1073,5304,1210,1037,8789,6175...]),\n ((#5000) [3442,4237,470,3901,3808,3793,6286,8546,6254,9530...],\n  (#1600) [9160,5451,3628,143,2054,7225,7124,8057,1405,5089...],\n  (#2000) [1263,6498,1602,1838,1073,5304,1210,1037,8789,6175...]),\n ((#5000) [9850,7451,7338,9742,3258,1527,4450,5678,2932,1693...],\n  (#1600) [6186,5970,376,7848,3786,1663,7193,3647,3277,553...],\n  (#2000) [1263,6498,1602,1838,1073,5304,1210,1037,8789,6175...]),\n ((#5000) [1853,7308,7375,3851,1852,3820,2601,3868,8718,7190...],\n  (#1600) [4182,6419,6265,4837,168,9627,2500,9951,1610,7547...],\n  (#2000) [1263,6498,1602,1838,1073,5304,1210,1037,8789,6175...]),\n ((#5000) [7878,6392,453,4817,4676,5738,6482,4033,8114,7337...],\n  (#1600) [7682,6416,2877,9164,1583,342,2916,4806,8776,2046...],\n  (#2000) [1263,6498,1602,1838,1073,5304,1210,1037,8789,6175...]))\n\n\n\ntrain_size=256\ny = np.random.randint(0, 3, 1000) + 100\nsplits = get_splits(y, train_size=train_size, train_only=True)\ntest_eq(splits[0], splits[1])\ntest_eq(len(splits[0]), train_size)\nsplits\n\nvalid == train\n\n\n\n\n\n\n\n\n\n((#256) [550,813,388,595,948,198,354,749,175,812...],\n (#256) [550,813,388,595,948,198,354,749,175,812...])\n\n\n\nsource\n\n\nget_walk_forward_splits\n\n get_walk_forward_splits (o, n_splits=1, train_size=None, valid_size=0.2,\n                          test_size=0.0, anchored=False, gap=0.0,\n                          test_after_valid=True, random_state=None,\n                          show_plot=True)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\no\n\n\n3D object with shape [samples x features x steps] containing the time series we need to split\n\n\nn_splits\nint\n1\n# of splits\n\n\ntrain_size\nNoneType\nNone\noptional: training set size as an int or a float. None when using and anchored strategy.\n\n\nvalid_size\nfloat\n0.2\nvalidation set size as an int or a float\n\n\ntest_size\nfloat\n0.0\ntest set size as an int or a float\n\n\nanchored\nbool\nFalse\nstarting point for train set remains the same for all splits\n\n\ngap\nfloat\n0.0\n# of samples to exclude from the end of each train set before the validation set. Entered as an int or a float\n\n\ntest_after_valid\nbool\nTrue\nflag to indicate if validation and test will be samples randomly or sequentially\n\n\nrandom_state\nNoneType\nNone\ninteger that can be used to generate reproducible results\n\n\nshow_plot\nbool\nTrue\nplots the splits created\n\n\n\n\no = np.random.rand(10_000, 3,  50) # shape: [samples x features x steps]\n\nsplits = get_walk_forward_splits(\n    o,\n    n_splits=4,\n    train_size=.6,\n    valid_size=0.1,\n    test_size=0.1,\n    anchored = True,\n    gap = 100,\n    test_after_valid = True,\n    random_state = None,\n    show_plot=True,\n)\n\nsplits = get_walk_forward_splits(\n    o,\n    n_splits=3,\n    train_size=0.3,\n    valid_size=0.1,\n    test_size=0.1,\n    anchored = False,\n    gap = 0.,\n    test_after_valid = False,\n    random_state = None,\n    show_plot=True,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nTSSplitter\n\n TSSplitter (valid_size=0.2, test_size=0.0, fcst_horizon=0,\n             show_plot=True)\n\nCreate function that splits items between train/val with valid_size without shuffling data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nvalid_size\nfloat\n0.2\nint or float indicating the validation set size\n\n\ntest_size\nfloat\n0.0\nint or float indicating the test set size\n\n\nfcst_horizon\nint\n0\nint that indicates the number of time steps removed at the end of train (and validation)\n\n\nshow_plot\nbool\nTrue\nflag that indicates if a plot showing the splits will be created\n\n\n\n\ny = np.arange(1000) + 100\ntest_eq(TimeSplitter(valid_size=0.2)(y)[1], L(np.arange(800, 1000).tolist()))\ntest_eq(TimeSplitter(valid_size=0.2)(y)[0], TimeSplitter(valid_size=200)(y)[0])\nTimeSplitter(valid_size=0.2, show_plot=True)(y)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n((#800) [0,1,2,3,4,5,6,7,8,9...],\n (#200) [800,801,802,803,804,805,806,807,808,809...])\n\n\n\nn_splits                = 5\nvalid_size              = 0.2\ntest_size               = 0\ntrain_only              = False  # set to True for debugging (valid = train)\ntrain_size              = None\nstratify                = True\nbalance                 = True\nshuffle                 = True\npredefined_splits       = None\nshow_plot               = True\n\n\ncheck_splits = True\nrandom_state = 23\n\nsplits = get_splits(y, n_splits=n_splits, valid_size=valid_size, test_size=test_size, shuffle=shuffle, balance=balance, stratify=stratify,\n                    train_only=train_only, train_size=train_size, check_splits=check_splits, random_state=random_state, show_plot=show_plot, verbose=True)\nsplit = splits[0] if n_splits == 1 else splits[0][0]\ny[split].mean(), split\n\nstratify set to False as n_splits=5 cannot be greater than the min number of members in each class (1).\n\n\n\n\n\n\n\n\n\n\nlist([splits[0], splits[1], splits[2], splits[3], splits[4]])\n\n[((#800) [314,194,782,789,502,917,137,415,904,181...],\n  (#200) [362,151,934,378,95,597,500,117,980,844...]),\n ((#800) [312,198,777,788,515,910,145,413,898,186...],\n  (#200) [352,133,955,396,64,596,442,79,991,882...]),\n ((#800) [311,197,783,791,507,922,145,416,908,184...],\n  (#200) [338,125,912,361,54,594,486,88,994,859...]),\n ((#800) [296,181,782,789,493,917,130,401,905,165...],\n  (#200) [405,199,953,444,113,610,515,137,997,881...]),\n ((#800) [320,190,782,788,506,906,141,412,893,178...],\n  (#200) [336,149,942,358,49,582,472,70,990,907...])]\n\n\n\nn_splits = 5\nvalid_size = 0.\ntest_size = 0.\nshuffle = True\nstratify = True\ntrain_only = True\ntrain_size = None\ncheck_splits = True\nrandom_state = 1\nshow_plot = True\n\nsplits = get_splits(y, n_splits=n_splits, valid_size=valid_size, test_size=test_size, shuffle=shuffle, stratify=stratify,\n                    train_only=train_only, train_size=train_size, check_splits=check_splits, random_state=random_state, show_plot=show_plot, verbose=True)\nfor split in splits:\n    test_eq(len(split[0]), len(y))\n    test_eq(np.sort(split[0]), np.arange(len(y)))\n\nstratify set to False as n_splits=5 cannot be greater than the min number of members in each class (1).\nvalid == train\n\n\n\n\n\n\n\n\n\n\nn_splits = 5\ny = np.random.randint(0, 2, 1000)\n\nsplits = get_splits(y, n_splits=n_splits, shuffle=False, check_splits=True)\ntest_eq(np.concatenate((L(zip(*splits))[1])), np.arange(len(y)))\n\nsplits = get_splits(y, n_splits=n_splits, shuffle=True, check_splits=True)\ntest_eq(np.sort(np.concatenate((L(zip(*splits))[1]))), np.arange(len(y)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn_splits = 2\ny = np.random.randint(0, 2, 1000)\n\nsplits = get_splits(y, n_splits=n_splits, test_size=0.2, shuffle=False)\nfor i in range(n_splits): leakage_finder(*splits[i])\ntest_eq(len(splits), n_splits)\ntest_eq(len(splits[0]), 3)\ns = []\n[s.extend(split) for split in splits[0]]\ntest_eq(np.sort(s), np.arange(len(y)))\ns = []\n[s.extend(split) for split in splits[1]]\ntest_eq(np.sort(s), np.arange(len(y)))\n\n\n\n\n\n\n\n\n\ny = np.random.randint(0, 2, 1000)\nsplits1 = get_splits(y, valid_size=.25, test_size=0, random_state=23, stratify=True, shuffle=True)\nsplits2 = get_splits(y, valid_size=.25, test_size=0, random_state=23, stratify=True, shuffle=True)\nsplits3 = get_splits(y, valid_size=.25, test_size=0, random_state=None, stratify=True, shuffle=True)\nsplits4 = get_splits(y, valid_size=.25, test_size=0, random_state=None, stratify=True, shuffle=True)\ntest_eq(splits1[0], splits2[0])\ntest_ne(splits3[0], splits4[0])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ny = np.random.randint(0, 2, 100)\nsplits = get_splits(y, valid_size=.25, test_size=0, random_state=23, stratify=True, shuffle=True)\ntest_eq(len(splits), 2)\n\n\n\n\n\n\n\n\n\ny = np.random.randint(0, 2, 100)\nsplits = get_splits(y, valid_size=.25, test_size=0, random_state=23, stratify=True)\ntest_eq(len(splits), 2)\n\n\n\n\n\n\n\n\n\ny = np.random.randint(0, 2, 100)\nsplits = get_splits(y, valid_size=.25, test_size=20, random_state=23, stratify=True)\ntest_eq(len(splits), 3)\nleakage_finder(*splits)\n\n\n\n\n\n\n\n\n\nsplits = TrainValidTestSplitter(valid_size=.25, test_size=20, random_state=23, stratify=True)(np.random.randint(0, 2, 100))\ntest_eq(len(splits[1]), 25)\ntest_eq(len(splits[2]), 20)\n\n\no = np.random.randint(0, 2, 1000)\nfor p in [1, .75, .5, .25, .125]:\n    splits = get_splits(o, train_size=p)\n    test_eq(len(splits[0]), len(o) * .8 * p)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ny = L([0] * 50 + [1] * 25 + [2] * 15 + [3] * 10)\nsplits = get_splits(y, valid_size=.2, test_size=.2)\ntest_eq(np.mean(y[splits[0]])==np.mean(y[splits[1]])==np.mean(y[splits[2]]), True)\nsplits\n\n\n\n\n\n\n\n\n((#60) [58,95,53,44,28,69,9,12,22,88...],\n (#20) [89,71,60,4,19,37,75,13,46,30...],\n (#20) [76,68,74,29,16,97,14,21,90,82...])\n\n\n\ny = L([0] * 50 + [1] * 25 + [2] * 15 + [3] * 10)\nsplits = get_splits(y, n_splits=1, valid_size=.2, test_size=.2, shuffle=False)\n# test_eq(splits[0] + splits[1] + splits[2], np.arange(100))\nsplits\n\n\n\n\n\n\n\n\n((#60) [0,1,2,3,4,5,6,7,8,9...],\n (#20) [60,61,62,63,64,65,66,67,68,69...],\n (#20) [80,81,82,83,84,85,86,87,88,89...])\n\n\n\nsplits = get_splits(np.random.randint(0,5,100), valid_size=0.213, test_size=17)\ntest_eq(len(splits[1]), 21)\ntest_eq(len(splits[2]), 17)\n\n\n\n\n\n\n\n\n\nsplits = get_splits(np.random.randint(0,5,100), valid_size=0.213, test_size=17, train_size=.2)\nsplits\n\n\n\n\n\n\n\n\n((#12) [37,38,62,60,16,22,95,44,94,98...],\n (#21) [88,93,5,31,57,23,90,18,15,40...],\n (#17) [4,86,47,33,59,52,99,48,70,3...])\n\n\n\nsource\n\n\ncombine_split_data\n\n combine_split_data (xs, ys=None)\n\nxs is a list with X_train, X_valid, …. ys is None or a list with y_train, y_valid, ….\n\nsource\n\n\nget_predefined_splits\n\n get_predefined_splits (*xs)\n\nxs is a list with X_train, X_valid, …\n\nsource\n\n\nget_splits_len\n\n get_splits_len (splits)\n\n\nX_train, y_train, X_valid, y_valid = np.random.rand(3,3,4), np.random.randint(0,2,3), np.random.rand(2,3,4), np.random.randint(0,2,2)\nX, y, splits = combine_split_data([X_train, X_valid], [y_train, y_valid])\ntest_eq(X_train, X[splits[0]])\ntest_eq(X_valid, X[splits[1]])\ntest_type(X_train, X)\ntest_type(y_train, y)\n\n\nX_train, y_train, X_valid, y_valid = np.random.rand(3,4), np.random.randint(0,2,3), np.random.rand(2,4), np.random.randint(0,2,2)\nX, y, splits = combine_split_data([X_train, X_valid], [y_train, y_valid])\ntest_eq(X_train[:, None], X[splits[0]])\ntest_eq(X_valid[:, None], X[splits[1]])\ntest_type(X_train, X)\ntest_type(y_train, y)\n\n\n\nForecasting\n\nsource\n\nget_df_usable_idxs\n\n get_df_usable_idxs (df, fcst_history, fcst_horizon, stride=1,\n                     unique_id_cols=None, return_np_indices=False)\n\nCalculates the indices that can be used from a df when using a sliding window\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing a sorted time series\n\n\nfcst_history\n\n\n# historical steps used as input (size of the sliding window for the input)\n\n\nfcst_horizon\n\n\n# steps forecasted into the future (size of the sliding window for the target)\n\n\nstride\nint\n1\nint or tuple of 2 int containing the strides of the sliding windows (input and target)\n\n\nunique_id_cols\nNoneType\nNone\nstr indicating the column/s with the unique identifier/s for each entity\n\n\nreturn_np_indices\nbool\nFalse\nbool indicating what type of indices are returned. Default to False (dataframe indices)\n\n\n\n\nsource\n\n\nget_usable_idxs\n\n get_usable_idxs (df, fcst_history, fcst_horizon, stride=1)\n\n\nsource\n\n\ncalculate_fcst_stats\n\n calculate_fcst_stats (df, fcst_history, fcst_horizon, splits,\n                       x_vars=None, y_vars=None, subset_size=None)\n\nCalculates the training stats required in a forecasting task\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing a sorted time series for a single entity or subject\n\n\nfcst_history\n\n\n# historical steps used as input.\n\n\nfcst_horizon\n\n\n# steps forecasted into the future.\n\n\nsplits\n\n\nsplits that will be used to train the model. splits[0] is the train split:\n\n\nx_vars\nNoneType\nNone\nfeatures used as input\n\n\ny_vars\nNoneType\nNone\nfeatures used as output\n\n\nsubset_size\nNoneType\nNone\nint or float to determne the number of train samples used to calculate the mean and std\n\n\n\n\nsource\n\n\nget_forecasting_splits\n\n get_forecasting_splits (df, fcst_history, fcst_horizon, stride=1,\n                         valid_size=0.0, test_size=0.2,\n                         valid_cutoff_datetime=None,\n                         test_cutoff_datetime=None, datetime_col=None,\n                         use_index=False, unique_id_cols=None,\n                         show_plot=True)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing a sorted time series\n\n\nfcst_history\n\n\n# historical steps used as input (size of the sliding window for the input)\n\n\nfcst_horizon\n\n\n# steps forecasted into the future (size of the sliding window for the target)\n\n\nstride\nint\n1\nint or tuple of 2 int containing the strides of the sliding windows (input and target)\n\n\nvalid_size\nfloat\n0.0\nint or float indicating the size of the training set (based on datetimes)\n\n\ntest_size\nfloat\n0.2\nint or float indicating the size of the test set (based on datetimes)\n\n\nvalid_cutoff_datetime\nNoneType\nNone\nfirst prediction datetime of validation dataset\n\n\ntest_cutoff_datetime\nNoneType\nNone\nfirst prediction datetime of test dataset\n\n\ndatetime_col\nNoneType\nNone\nstr indicating the column with the datetime values\n\n\nuse_index\nbool\nFalse\nflag to indicate if the datetime is in the index\n\n\nunique_id_cols\nNoneType\nNone\nstr indicating the column/s with the unique identifier/s for each entity\n\n\nshow_plot\nbool\nTrue\nflag to indicate if splits should be plotted\n\n\n\n\ndf1_len = 100\ndf2_len = 80\n\ndatetime_col = 'datetime'\ndf1 = pd.DataFrame(np.arange(df1_len), columns=['value'])\ndf1['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df1_len, freq='1D')\ndf1['type'] = 1\n\ndf = df1\ndisplay(df)\n\n# settings\nfcst_history          = 10\nfcst_horizon          = 1\nstride                = 1\nunique_id_cols        = 'type'\ndatetime_col          = 'datetime'\nuse_index             = False\nvalid_size            = 0.1  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\ntest_size             = 0.2  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\nvalid_cutoff_datetime = '1749-08-21' # first prediction datetime of validation dataset\ntest_cutoff_datetime  = '1749-12-24' # first prediction datetime of test dataset\nvalid_cutoff_datetime = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\ntest_cutoff_datetime  = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\n\n\nsplits = get_forecasting_splits(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, stride=stride,\n                                unique_id_cols=unique_id_cols, datetime_col=datetime_col, use_index=use_index,\n                                valid_size=valid_size, test_size=test_size,\n                                valid_cutoff_datetime=valid_cutoff_datetime, test_cutoff_datetime=test_cutoff_datetime)\n\nprint(f\"splits size   : {[len(s) for s in splits]} ({sum([len(s) for s in splits])}: {[round(len(s)/sum([len(s) for s in splits]), 2) for s in splits]})\")\n\n# settings\nfcst_history          = 10\nfcst_horizon          = 5\nstride                = 5\nunique_id_cols        = 'type'\ndatetime_col          = 'datetime'\nuse_index             = False\nvalid_size            = 0.1  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\ntest_size             = 0.2  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\nvalid_cutoff_datetime = '1749-08-21' # first prediction datetime of validation dataset\ntest_cutoff_datetime  = '1749-12-24' # first prediction datetime of test dataset\nvalid_cutoff_datetime = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\ntest_cutoff_datetime  = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\n\n\nsplits = get_forecasting_splits(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, stride=stride,\n                                unique_id_cols=unique_id_cols, datetime_col=datetime_col, use_index=use_index,\n                                valid_size=valid_size, test_size=test_size,\n                                valid_cutoff_datetime=valid_cutoff_datetime, test_cutoff_datetime=test_cutoff_datetime)\n\nprint(f\"splits size   : {[len(s) for s in splits]} ({sum([len(s) for s in splits])}: {[round(len(s)/sum([len(s) for s in splits]), 2) for s in splits]})\")\n\n\n\n\n\n\n\n\nvalue\ndatetime\ntype\n\n\n\n\n0\n0\n1749-03-31\n1\n\n\n1\n1\n1749-04-01\n1\n\n\n2\n2\n1749-04-02\n1\n\n\n3\n3\n1749-04-03\n1\n\n\n4\n4\n1749-04-04\n1\n\n\n...\n...\n...\n...\n\n\n95\n95\n1749-07-04\n1\n\n\n96\n96\n1749-07-05\n1\n\n\n97\n97\n1749-07-06\n1\n\n\n98\n98\n1749-07-07\n1\n\n\n99\n99\n1749-07-08\n1\n\n\n\n\n100 rows × 3 columns\n\n\n\n\n\n\n\n\n\n\nsplits size   : [63, 9, 18] (90: [0.7, 0.1, 0.2])\n\n\n\n\n\n\n\n\n\nsplits size   : [12, 2, 4] (18: [0.67, 0.11, 0.22])\n\n\n\ndf1_len = 100\ndf2_len = 80\n\ndatetime_col = 'datetime'\ndf1 = pd.DataFrame(np.arange(df1_len), columns=['value'])\ndf1['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df1_len, freq='1D')\ndf1['type'] = 1\ndf1_index = df1.set_index(\"datetime\")\n\ndf = df1_index\ndisplay(df)\n\n# settings\nfcst_history          = 10\nfcst_horizon          = 1\nstride                = 1\nunique_id_cols        = 'type'\ndatetime_col          = 'datetime'\nuse_index             = True\nvalid_size            = 0.1  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\ntest_size             = 0.2  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\nvalid_cutoff_datetime = '1749-08-21' # first prediction datetime of validation dataset\ntest_cutoff_datetime  = '1749-12-24' # first prediction datetime of test dataset\nvalid_cutoff_datetime = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\ntest_cutoff_datetime  = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\n\n\nsplits = get_forecasting_splits(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, stride=stride,\n                                unique_id_cols=unique_id_cols, datetime_col=datetime_col, use_index=use_index,\n                                valid_size=valid_size, test_size=test_size,\n                                valid_cutoff_datetime=valid_cutoff_datetime, test_cutoff_datetime=test_cutoff_datetime)\n\nprint(f\"splits size   : {[len(s) for s in splits]} ({sum([len(s) for s in splits])}: {[round(len(s)/sum([len(s) for s in splits]), 2) for s in splits]})\")\n\n# settings\nfcst_history          = 10\nfcst_horizon          = 5\nstride                = 5\nunique_id_cols        = 'type'\ndatetime_col          = 'datetime'\nuse_index             = True\nvalid_size            = 0.1  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\ntest_size             = 0.2  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\nvalid_cutoff_datetime = '1749-08-21' # first prediction datetime of validation dataset\ntest_cutoff_datetime  = '1749-12-24' # first prediction datetime of test dataset\nvalid_cutoff_datetime = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\ntest_cutoff_datetime  = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\n\n\nsplits = get_forecasting_splits(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, stride=stride,\n                                unique_id_cols=unique_id_cols, datetime_col=datetime_col, use_index=use_index,\n                                valid_size=valid_size, test_size=test_size,\n                                valid_cutoff_datetime=valid_cutoff_datetime, test_cutoff_datetime=test_cutoff_datetime)\n\nprint(f\"splits size   : {[len(s) for s in splits]} ({sum([len(s) for s in splits])}: {[round(len(s)/sum([len(s) for s in splits]), 2) for s in splits]})\")\n\n\n\n\n\n\n\n\nvalue\ntype\n\n\ndatetime\n\n\n\n\n\n\n1749-03-31\n0\n1\n\n\n1749-04-01\n1\n1\n\n\n1749-04-02\n2\n1\n\n\n1749-04-03\n3\n1\n\n\n1749-04-04\n4\n1\n\n\n...\n...\n...\n\n\n1749-07-04\n95\n1\n\n\n1749-07-05\n96\n1\n\n\n1749-07-06\n97\n1\n\n\n1749-07-07\n98\n1\n\n\n1749-07-08\n99\n1\n\n\n\n\n100 rows × 2 columns\n\n\n\n\n\n\n\n\n\n\nsplits size   : [63, 9, 18] (90: [0.7, 0.1, 0.2])\n\n\n\n\n\n\n\n\n\nsplits size   : [12, 2, 4] (18: [0.67, 0.11, 0.22])\n\n\n\ndf1_len = 100\ndf2_len = 80\n\ndatetime_col = 'datetime'\ndf1 = pd.DataFrame(np.arange(df1_len), columns=['value'])\ndf1['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df1_len, freq='1D')\ndf1['type'] = 1\ndf1_index = df1.set_index(\"datetime\")\ndf2 = pd.DataFrame(np.arange(df2_len) * 10, columns=['value'])\ndf2['datetime'] = pd.date_range(pd.to_datetime('1749-04-15'), periods=df2_len, freq='1D')\ndf2['type'] = 2\ndf_comb = pd.concat([df1, df2]).reset_index(drop=True).reset_index(drop=True)\n\n\ndf = df_comb\ndisplay(df)\n\n# settings\nfcst_history          = 10\nfcst_horizon          = 3\nstride                = 1\nunique_id_cols        = 'type'\ndatetime_col          = 'datetime'\nuse_index             = False\nvalid_size            = 0.1  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\ntest_size             = 0.2  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\nvalid_cutoff_datetime = '1749-08-21' # first prediction datetime of validation dataset\ntest_cutoff_datetime  = '1749-12-24' # first prediction datetime of test dataset\nvalid_cutoff_datetime = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\ntest_cutoff_datetime  = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\n\n\nsplits = get_forecasting_splits(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, stride=stride,\n                                unique_id_cols=unique_id_cols, datetime_col=datetime_col, use_index=use_index,\n                                valid_size=valid_size, test_size=test_size,\n                                valid_cutoff_datetime=valid_cutoff_datetime, test_cutoff_datetime=test_cutoff_datetime)\n\nprint(f\"splits size   : {[len(s) for s in splits]} ({sum([len(s) for s in splits])}: {[round(len(s)/sum([len(s) for s in splits]), 2) for s in splits]})\")\n\n\n\n\n\n\n\n\nvalue\ndatetime\ntype\n\n\n\n\n0\n0\n1749-03-31\n1\n\n\n1\n1\n1749-04-01\n1\n\n\n2\n2\n1749-04-02\n1\n\n\n3\n3\n1749-04-03\n1\n\n\n4\n4\n1749-04-04\n1\n\n\n...\n...\n...\n...\n\n\n175\n750\n1749-06-29\n2\n\n\n176\n760\n1749-06-30\n2\n\n\n177\n770\n1749-07-01\n2\n\n\n178\n780\n1749-07-02\n2\n\n\n179\n790\n1749-07-03\n2\n\n\n\n\n180 rows × 3 columns\n\n\n\n\n\n\n\n\n\n\nsplits size   : [101, 16, 31] (148: [0.68, 0.11, 0.21])\n\n\n\ndf1_len = 100\ndf2_len = 80\n\ndatetime_col = 'datetime'\ndf1 = pd.DataFrame(np.arange(df1_len), columns=['value'])\ndf1['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df1_len, freq='1D')\ndf1['type'] = 1\ndf1_index = df1.set_index(\"datetime\")\ndf2 = pd.DataFrame(np.arange(df2_len) * 10, columns=['value'])\ndf2['datetime'] = pd.date_range(pd.to_datetime('1749-04-15'), periods=df2_len, freq='1D')\ndf2['type'] = 2\ndf_comb = pd.concat([df1, df2]).reset_index(drop=True).reset_index(drop=True)\ndf_comb_index = df_comb.set_index(\"datetime\")\ndf_comb_index.index.name = None\n\n\ndf = df_comb_index\ndisplay(df)\n\n# settings\nfcst_history          = 15\nfcst_horizon          = 5\nstride                = 1\nunique_id_cols        = 'type'\ndatetime_col          = 'datetime'\nuse_index             = True\nvalid_size            = 0.1  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\ntest_size             = 0.2  # a percent (float) or a number of samples (int) - .1 means 10% of the dates\nvalid_cutoff_datetime = '1749-08-21' # first prediction datetime of validation dataset\ntest_cutoff_datetime  = '1749-12-24' # first prediction datetime of test dataset\nvalid_cutoff_datetime = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\ntest_cutoff_datetime  = None # datetime compatible with the datetime_col containing the starting date for the validation dataset\n\n\nsplits = get_forecasting_splits(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, stride=stride,\n                                unique_id_cols=unique_id_cols, datetime_col=datetime_col, use_index=use_index,\n                                valid_size=valid_size, test_size=test_size,\n                                valid_cutoff_datetime=valid_cutoff_datetime, test_cutoff_datetime=test_cutoff_datetime)\n\nprint(f\"splits size   : {[len(s) for s in splits]} ({sum([len(s) for s in splits])}: {[round(len(s)/sum([len(s) for s in splits]), 2) for s in splits]})\")\n\n\n\n\n\n\n\n\nvalue\ntype\n\n\n\n\n1749-03-31\n0\n1\n\n\n1749-04-01\n1\n1\n\n\n1749-04-02\n2\n1\n\n\n1749-04-03\n3\n1\n\n\n1749-04-04\n4\n1\n\n\n...\n...\n...\n\n\n1749-06-29\n750\n2\n\n\n1749-06-30\n760\n2\n\n\n1749-07-01\n770\n2\n\n\n1749-07-02\n780\n2\n\n\n1749-07-03\n790\n2\n\n\n\n\n180 rows × 2 columns\n\n\n\n\n\n\n\n\n\n\nsplits size   : [83, 14, 29] (126: [0.66, 0.11, 0.23])\n\n\n\nsource\n\n\nget_long_term_forecasting_splits\n\n get_long_term_forecasting_splits (df, fcst_history, fcst_horizon,\n                                   dsid=None, show_plot=True)\n\nReturns the train, valid and test splits for long-range time series datasets\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing a sorted time series for a single entity or subject\n\n\nfcst_history\n\n\n# historical steps used as input.\n\n\nfcst_horizon\n\n\n# steps forecasted into the future.\n\n\ndsid\nNoneType\nNone\ndataset name\n\n\nshow_plot\nbool\nTrue\nplot the splits",
    "crumbs": [
      "Data",
      "Spliting data"
    ]
  },
  {
    "objectID": "index.html#description",
    "href": "index.html#description",
    "title": "tsai",
    "section": "Description",
    "text": "Description\n\nState-of-the-art Deep Learning library for Time Series and Sequences.\n\ntsai is an open-source deep learning package built on top of Pytorch & fastai focused on state-of-the-art techniques for time series tasks like classification, regression, forecasting, imputation…\ntsai is currently under active development by timeseriesAI.",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#whats-new",
    "href": "index.html#whats-new",
    "title": "tsai",
    "section": "What’s new:",
    "text": "What’s new:\nDuring the last few releases, here are some of the most significant additions to tsai:\n\nNew models: PatchTST (Accepted by ICLR 2023), RNN with Attention (RNNAttention, LSTMAttention, GRUAttention), TabFusionTransformer, …\nNew datasets: we have increased the number of datasets you can download using tsai:\n\n128 univariate classification datasets\n30 multivariate classification datasets\n15 regression datasets\n62 forecasting datasets\n9 long term forecasting datasets\n\nNew tutorials: PatchTST. Based on some of your requests, we are planning to release additional tutorials on data preparation and forecasting.\nNew functionality: sklearn-type pipeline transforms, walk-foward cross validation, reduced RAM requirements, and a lot of new functionality to perform more accurate time series forecasts.\nPytorch 2.0 support.",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "tsai",
    "section": "Installation",
    "text": "Installation\n\nPip install\nYou can install the latest stable version from pip using:\npip install tsai\nIf you plan to develop tsai yourself, or want to be on the cutting edge, you can use an editable install. First install PyTorch, and then:\ngit clone https://github.com/timeseriesAI/tsai\npip install -e \"tsai[dev]\"\nNote: starting with tsai 0.3.0 tsai will only install hard dependencies. Other soft dependencies (which are only required for selected tasks) will not be installed by default (this is the recommended approach. If you require any of the dependencies that is not installed, tsai will ask you to install it when necessary). If you still want to install tsai with all its dependencies you can do it by running:\npip install tsai[extras]\n\n\nConda install\nYou can also install tsai using conda (note that if you replace conda with mamba the install process will be much faster and more reliable):\nconda install -c timeseriesai tsai",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "tsai",
    "section": "Documentation",
    "text": "Documentation\nHere’s the link to the documentation.",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#available-models",
    "href": "index.html#available-models",
    "title": "tsai",
    "section": "Available models:",
    "text": "Available models:\nHere’s a list with some of the state-of-the-art models available in tsai:\n\nLSTM (Hochreiter, 1997) (paper)\nGRU (Cho, 2014) (paper)\nMLP - Multilayer Perceptron (Wang, 2016) (paper)\nFCN - Fully Convolutional Network (Wang, 2016) (paper)\nResNet - Residual Network (Wang, 2016) (paper)\nLSTM-FCN (Karim, 2017) (paper)\nGRU-FCN (Elsayed, 2018) (paper)\nmWDN - Multilevel wavelet decomposition network (Wang, 2018) (paper)\nTCN - Temporal Convolutional Network (Bai, 2018) (paper)\nMLSTM-FCN - Multivariate LSTM-FCN (Karim, 2019) (paper)\nInceptionTime (Fawaz, 2019) (paper)\nRocket (Dempster, 2019) (paper)\nXceptionTime (Rahimian, 2019) (paper)\nResCNN - 1D-ResCNN (Zou , 2019) (paper)\nTabModel - modified from fastai’s TabularModel\nOmniScale - Omni-Scale 1D-CNN (Tang, 2020) (paper)\nTST - Time Series Transformer (Zerveas, 2020) (paper)\nTabTransformer (Huang, 2020) (paper)\nTSiT Adapted from ViT (Dosovitskiy, 2020) (paper)\nMiniRocket (Dempster, 2021) (paper)\nXCM - An Explainable Convolutional Neural Network (Fauvel, 2021) (paper)\ngMLP - Gated Multilayer Perceptron (Liu, 2021) (paper)\nTSPerceiver - Adapted from Perceiver IO (Jaegle, 2021) (paper)\nGatedTabTransformer (Cholakov, 2022) (paper)\nTSSequencerPlus - Adapted from Sequencer (Tatsunami, 2022) (paper)\nPatchTST - (Nie, 2022) (paper)\n\nplus other custom models like: TransformerModel, LSTMAttention, GRUAttention, …",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#how-to-start-using-tsai",
    "href": "index.html#how-to-start-using-tsai",
    "title": "tsai",
    "section": "How to start using tsai?",
    "text": "How to start using tsai?\nTo get to know the tsai package, we’d suggest you start with this notebook in Google Colab: 01_Intro_to_Time_Series_Classification It provides an overview of a time series classification task.\nWe have also develop many other tutorial notebooks.\nTo use tsai in your own notebooks, the only thing you need to do after you have installed the package is to run this:\nfrom tsai.all import *",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "tsai",
    "section": "Examples",
    "text": "Examples\nThese are just a few examples of how you can use tsai:\n\nBinary, univariate classification\nTraining:\nfrom tsai.basics import *\n\nX, y, splits = get_classification_data('ECG200', split_data=False)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize()\nclf = TSClassifier(X, y, splits=splits, path='models', arch=\"InceptionTimePlus\", tfms=tfms, batch_tfms=batch_tfms, metrics=accuracy, cbs=ShowGraph())\nclf.fit_one_cycle(100, 3e-4)\nclf.export(\"clf.pkl\") \nInference:\nfrom tsai.inference import load_learner\n\nclf = load_learner(\"models/clf.pkl\")\nprobas, target, preds = clf.get_X_preds(X[splits[1]], y[splits[1]])\n\n\nMulti-class, multivariate classification\nTraining:\nfrom tsai.basics import *\n\nX, y, splits = get_classification_data('LSST', split_data=False)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize(by_sample=True)\nmv_clf = TSClassifier(X, y, splits=splits, path='models', arch=\"InceptionTimePlus\", tfms=tfms, batch_tfms=batch_tfms, metrics=accuracy, cbs=ShowGraph())\nmv_clf.fit_one_cycle(10, 1e-2)\nmv_clf.export(\"mv_clf.pkl\")\nInference:\nfrom tsai.inference import load_learner\n\nmv_clf = load_learner(\"models/mv_clf.pkl\")\nprobas, target, preds = mv_clf.get_X_preds(X[splits[1]], y[splits[1]])\n\n\nMultivariate Regression\nTraining:\nfrom tsai.basics import *\n\nX, y, splits = get_regression_data('AppliancesEnergy', split_data=False)\ntfms = [None, TSRegression()]\nbatch_tfms = TSStandardize(by_sample=True)\nreg = TSRegressor(X, y, splits=splits, path='models', arch=\"TSTPlus\", tfms=tfms, batch_tfms=batch_tfms, metrics=rmse, cbs=ShowGraph(), verbose=True)\nreg.fit_one_cycle(100, 3e-4)\nreg.export(\"reg.pkl\")\nInference:\nfrom tsai.inference import load_learner\n\nreg = load_learner(\"models/reg.pkl\")\nraw_preds, target, preds = reg.get_X_preds(X[splits[1]], y[splits[1]])\nThe ROCKETs (RocketClassifier, RocketRegressor, MiniRocketClassifier, MiniRocketRegressor, MiniRocketVotingClassifier or MiniRocketVotingRegressor) are somewhat different models. They are not actually deep learning models (although they use convolutions) and are used in a different way.\n⚠️ You’ll also need to install sktime to be able to use them. You can install it separately:\npip install sktime\nor use:\npip install tsai[extras]\nTraining:\nfrom sklearn.metrics import mean_squared_error, make_scorer\nfrom tsai.data.external import get_Monash_regression_data\nfrom tsai.models.MINIROCKET import MiniRocketRegressor\n\nX_train, y_train, *_ = get_Monash_regression_data('AppliancesEnergy')\nrmse_scorer = make_scorer(mean_squared_error, greater_is_better=False)\nreg = MiniRocketRegressor(scoring=rmse_scorer)\nreg.fit(X_train, y_train)\nreg.save('MiniRocketRegressor')\nInference:\nfrom sklearn.metrics import mean_squared_error\nfrom tsai.data.external import get_Monash_regression_data\nfrom tsai.models.MINIROCKET import load_minirocket\n\n*_, X_test, y_test = get_Monash_regression_data('AppliancesEnergy')\nreg = load_minirocket('MiniRocketRegressor')\ny_pred = reg.predict(X_test)\nmean_squared_error(y_test, y_pred, squared=False)\n\n\nForecasting\nYou can use tsai for forecast in the following scenarios:\n\nunivariate or multivariate time series input\nunivariate or multivariate time series output\nsingle or multi-step ahead\n\nYou’ll need to: * prepare X (time series input) and the target y (see documentation) * select PatchTST or one of tsai’s models ending in Plus (TSTPlus, InceptionTimePlus, TSiTPlus, etc). The model will auto-configure a head to yield an output with the same shape as the target input y.\n\nSingle step\nTraining:\nfrom tsai.basics import *\n\nts = get_forecasting_time_series(\"Sunspots\").values\nX, y = SlidingWindow(60, horizon=1)(ts)\nsplits = TimeSplitter(235)(y) \ntfms = [None, TSForecasting()]\nbatch_tfms = TSStandardize()\nfcst = TSForecaster(X, y, splits=splits, path='models', tfms=tfms, batch_tfms=batch_tfms, bs=512, arch=\"TSTPlus\", metrics=mae, cbs=ShowGraph())\nfcst.fit_one_cycle(50, 1e-3)\nfcst.export(\"fcst.pkl\")\nInference:\nfrom tsai.inference import load_learner\n\nfcst = load_learner(\"models/fcst.pkl\", cpu=False)\nraw_preds, target, preds = fcst.get_X_preds(X[splits[1]], y[splits[1]])\nraw_preds.shape\n# torch.Size([235, 1])\n\n\nMulti-step\nThis example show how to build a 3-step ahead univariate forecast.\nTraining:\nfrom tsai.basics import *\n\nts = get_forecasting_time_series(\"Sunspots\").values\nX, y = SlidingWindow(60, horizon=3)(ts)\nsplits = TimeSplitter(235, fcst_horizon=3)(y) \ntfms = [None, TSForecasting()]\nbatch_tfms = TSStandardize()\nfcst = TSForecaster(X, y, splits=splits, path='models', tfms=tfms, batch_tfms=batch_tfms, bs=512, arch=\"TSTPlus\", metrics=mae, cbs=ShowGraph())\nfcst.fit_one_cycle(50, 1e-3)\nfcst.export(\"fcst.pkl\")\nInference:\nfrom tsai.inference import load_learner\nfcst = load_learner(\"models/fcst.pkl\", cpu=False)\nraw_preds, target, preds = fcst.get_X_preds(X[splits[1]], y[splits[1]])\nraw_preds.shape\n# torch.Size([235, 3])",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#input-data-format",
    "href": "index.html#input-data-format",
    "title": "tsai",
    "section": "Input data format",
    "text": "Input data format\nThe input format for all time series models and image models in tsai is the same. An np.ndarray (or array-like object like zarr, etc) with 3 dimensions:\n[# samples x # variables x sequence length]\nThe input format for tabular models in tsai (like TabModel, TabTransformer and TabFusionTransformer) is a pandas dataframe. See example.",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#how-to-contribute-to-tsai",
    "href": "index.html#how-to-contribute-to-tsai",
    "title": "tsai",
    "section": "How to contribute to tsai?",
    "text": "How to contribute to tsai?\nWe welcome contributions of all kinds. Development of enhancements, bug fixes, documentation, tutorial notebooks, …\nWe have created a guide to help you start contributing to tsai. You can read it here.",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#enterprise-support-and-consulting-services",
    "href": "index.html#enterprise-support-and-consulting-services",
    "title": "tsai",
    "section": "Enterprise support and consulting services:",
    "text": "Enterprise support and consulting services:\nWant to make the most out of timeseriesAI/tsai in a professional setting? Let us help. Send us an email to learn more: info@timeseriesai.co",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "index.html#citing-tsai",
    "href": "index.html#citing-tsai",
    "title": "tsai",
    "section": "Citing tsai",
    "text": "Citing tsai\nIf you use tsai in your research please use the following BibTeX entry:\n@Misc{tsai,\n    author =       {Ignacio Oguiza},\n    title =        {tsai - A state-of-the-art deep learning library for time series and sequential data},\n    howpublished = {Github},\n    year =         {2023},\n    url =          {https://github.com/timeseriesAI/tsai}\n}",
    "crumbs": [
      "tsai"
    ]
  },
  {
    "objectID": "models.transformermodel.html",
    "href": "models.transformermodel.html",
    "title": "TransformerModel",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\nTransformerModel\n\n TransformerModel (c_in, c_out, d_model=64, n_head=1, d_ffn=128,\n                   dropout=0.1, activation='relu', n_layers=1)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nnvars = 3\nseq_len = 96\nc_out = 2\nxb = torch.rand(bs, nvars, seq_len)\n\n\nmodel = TransformerModel(nvars, c_out, d_model=64, n_head=1, d_ffn=128, dropout=0.1, activation='gelu', n_layers=3)\ntest_eq(model(xb).shape, [bs, c_out])\nprint(count_parameters(model))\nmodel\n\n100930\n\n\nTransformerModel(\n  (permute): Permute(dims=2, 0, 1)\n  (inlinear): Linear(in_features=3, out_features=64, bias=True)\n  (relu): ReLU()\n  (transformer_encoder): TransformerEncoder(\n    (layers): ModuleList(\n      (0): TransformerEncoderLayer(\n        (self_attn): MultiheadAttention(\n          (out_proj): NonDynamicallyQuantizableLinear(in_features=64, out_features=64, bias=True)\n        )\n        (linear1): Linear(in_features=64, out_features=128, bias=True)\n        (dropout): Dropout(p=0.1, inplace=False)\n        (linear2): Linear(in_features=128, out_features=64, bias=True)\n        (norm1): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n        (norm2): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n        (dropout1): Dropout(p=0.1, inplace=False)\n        (dropout2): Dropout(p=0.1, inplace=False)\n      )\n      (1): TransformerEncoderLayer(\n        (self_attn): MultiheadAttention(\n          (out_proj): NonDynamicallyQuantizableLinear(in_features=64, out_features=64, bias=True)\n        )\n        (linear1): Linear(in_features=64, out_features=128, bias=True)\n        (dropout): Dropout(p=0.1, inplace=False)\n        (linear2): Linear(in_features=128, out_features=64, bias=True)\n        (norm1): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n        (norm2): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n        (dropout1): Dropout(p=0.1, inplace=False)\n        (dropout2): Dropout(p=0.1, inplace=False)\n      )\n      (2): TransformerEncoderLayer(\n        (self_attn): MultiheadAttention(\n          (out_proj): NonDynamicallyQuantizableLinear(in_features=64, out_features=64, bias=True)\n        )\n        (linear1): Linear(in_features=64, out_features=128, bias=True)\n        (dropout): Dropout(p=0.1, inplace=False)\n        (linear2): Linear(in_features=128, out_features=64, bias=True)\n        (norm1): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n        (norm2): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n        (dropout1): Dropout(p=0.1, inplace=False)\n        (dropout2): Dropout(p=0.1, inplace=False)\n      )\n    )\n    (norm): LayerNorm((64,), eps=1e-05, elementwise_affine=True)\n  )\n  (transpose): Transpose(1, 0)\n  (max): Max(dim=1, keepdim=False)\n  (outlinear): Linear(in_features=64, out_features=2, bias=True)\n)",
    "crumbs": [
      "Models",
      "Transformers",
      "TransformerModel"
    ]
  },
  {
    "objectID": "data.preparation.html",
    "href": "data.preparation.html",
    "title": "Data preparation",
    "section": "",
    "text": "Functions required to prepare X (and y) from a pandas dataframe.\n\n\nsource\n\napply_sliding_window\n\n apply_sliding_window (data, window_len:int|list, horizon:int|list=0,\n                       x_vars:int|list=None, y_vars:int|list=None)\n\nApplies a sliding window on an array-like input to generate a 3d X (and optionally y)\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\n\n\nand array-like object with the input data\n\n\nwindow_len\nint | list\n\nsliding window length. When using a list, use negative numbers and 0.\n\n\nhorizon\nint | list\n0\nhorizon\n\n\nx_vars\nint | list\nNone\nindices of the independent variables\n\n\ny_vars\nint | list\nNone\nindices of the dependent variables (target). [] means no y will be created. None means all variables.\n\n\n\n\nsource\n\n\nprepare_sel_vars_and_steps\n\n prepare_sel_vars_and_steps (sel_vars=None, sel_steps=None, idxs=False)\n\n\nsource\n\n\nprepare_idxs\n\n prepare_idxs (o, shape=None)\n\n\ndata = np.arange(20).reshape(-1,1).repeat(3, 1) * np.array([1, 10, 100])\ndf = pd.DataFrame(data, columns=['feat_1', 'feat_2', 'feat_3'])\ndf.head()\n\n\n\n\n\n\n\n\nfeat_1\nfeat_2\nfeat_3\n\n\n\n\n0\n0\n0\n0\n\n\n1\n1\n10\n100\n\n\n2\n2\n20\n200\n\n\n3\n3\n30\n300\n\n\n4\n4\n40\n400\n\n\n\n\n\n\n\n\nwindow_len = 8\nhorizon = 1\nx_vars = None\ny_vars = None\nX, y = apply_sliding_window(data, window_len, horizon=horizon, x_vars=x_vars, y_vars=y_vars)\nprint(np.shares_memory(X, data))\nprint(np.shares_memory(y, data))\nprint(X.shape, y.shape)\ntest_eq(X.shape, (len(df) - (window_len - 1 + horizon), df.shape[1], window_len))\ntest_eq(y.shape, (len(df) - (window_len - 1 + horizon), df.shape[1]))\nX[0], y[0]\n\nTrue\nTrue\n(12, 3, 8) (12, 3)\n\n\n(array([[  0,   1,   2,   3,   4,   5,   6,   7],\n        [  0,  10,  20,  30,  40,  50,  60,  70],\n        [  0, 100, 200, 300, 400, 500, 600, 700]]),\n array([  8,  80, 800]))\n\n\n\nwindow_len = 8\nhorizon = 1\nx_vars = None\ny_vars = 0\nX, y = apply_sliding_window(df, window_len, horizon=horizon, x_vars=x_vars, y_vars=y_vars)\nprint(np.shares_memory(X, df))\nprint(np.shares_memory(y, df))\nprint(X.shape, y.shape)\ntest_eq(X.shape, (len(df) - (window_len - 1 + horizon), df.shape[1], window_len))\ntest_eq(y.shape, (len(df) - (window_len - 1 + horizon),))\nX[0], y[0]\n\nTrue\nTrue\n(12, 3, 8) (12,)\n\n\n(array([[  0,   1,   2,   3,   4,   5,   6,   7],\n        [  0,  10,  20,  30,  40,  50,  60,  70],\n        [  0, 100, 200, 300, 400, 500, 600, 700]]),\n 8)\n\n\n\nwindow_len = 8\nhorizon = [1, 2]\nx_vars = 0\ny_vars = [1, 2]\nX, y = apply_sliding_window(df, window_len, horizon=horizon, x_vars=x_vars, y_vars=y_vars)\nprint(np.shares_memory(X, df))\nprint(np.shares_memory(y, df))\nprint(X.shape, y.shape)\ntest_eq(X.shape, (len(df) - (window_len - 1 + max(horizon)), 1, window_len))\ntest_eq(y.shape, (len(df) - (window_len - 1 + max(horizon)), len(y_vars), len(horizon)))\nX[0], y[0]\n\nTrue\nFalse\n(11, 1, 8) (11, 2, 2)\n\n\n(array([[0, 1, 2, 3, 4, 5, 6, 7]]),\n array([[ 80,  90],\n        [800, 900]]))\n\n\n\nwindow_len = [-4, -2, -1, 0]\nhorizon = [1, 2, 4]\nx_vars = 0\ny_vars = [1, 2]\nX, y = apply_sliding_window(df, window_len, horizon=horizon, x_vars=x_vars, y_vars=y_vars)\nprint(np.shares_memory(X, df))\nprint(np.shares_memory(y, df))\nprint(X.shape, y.shape)\ntest_eq(X.shape, (12, 1, 4))\ntest_eq(y.shape, (12, 2, 3))\nX[0], y[0]\n\nFalse\nFalse\n(12, 1, 4) (12, 2, 3)\n\n\n(array([[0, 2, 3, 4]]),\n array([[ 50,  60,  80],\n        [500, 600, 800]]))\n\n\n\nsource\n\n\ndf2Xy\n\n df2Xy (df, sample_col=None, feat_col=None, data_cols=None,\n        target_col=None, steps_in_rows=False, to3d=True, splits=None,\n        sort_by=None, ascending=True, y_func=None, return_names=False)\n\nThis function allows you to transform a pandas dataframe into X and y numpy arrays that can be used to create a TSDataset. sample_col: column that uniquely identifies each sample. feat_col: used for multivariate datasets. It indicates which is the column that indicates the feature by row. data_col: indicates ths column/s where the data is located. If None, it means all columns (except the sample_col, feat_col, and target_col) target_col: indicates the column/s where the target is. steps_in_rows: flag to indicate if each step is in a different row or in a different column (default). to3d: turns X to 3d (including univariate time series) sort_by: this is used to pass any colum/s that are needed to sort the steps in the sequence. If you pass a sample_col and/ or feat_col these will be automatically used before the sort_by column/s, and you don’t need to add them to the sort_by column/s list. y_func: function used to calculate y for each sample (and target_col) return_names: flag to return the names of the columns from where X was generated\n\nsource\n\n\nsplit_Xy\n\n split_Xy (X, y=None, splits=None)\n\n\ndf = pd.DataFrame()\ndf['sample_id'] = np.array([1,1,1,2,2,2,3,3,3])\ndf['var1'] = df['sample_id'] * 10 + df.index.values\ndf['var2'] = df['sample_id'] * 100 + df.index.values\ndf\n\n\n\n\n\n\n\n\nsample_id\nvar1\nvar2\n\n\n\n\n0\n1\n10\n100\n\n\n1\n1\n11\n101\n\n\n2\n1\n12\n102\n\n\n3\n2\n23\n203\n\n\n4\n2\n24\n204\n\n\n5\n2\n25\n205\n\n\n6\n3\n36\n306\n\n\n7\n3\n37\n307\n\n\n8\n3\n38\n308\n\n\n\n\n\n\n\n\nX_df, y_df = df2Xy(df, sample_col='sample_id', steps_in_rows=True)\ntest_eq(X_df[0], np.array([[10, 11, 12], [100, 101, 102]]))\n\n\nn_samples = 1_000\nn_rows = 10_000\n\nsample_ids = np.arange(n_samples).repeat(n_rows//n_samples).reshape(-1,1)\nfeat_ids = np.tile(np.arange(n_rows // n_samples), n_samples).reshape(-1,1)\ncont = np.random.randn(n_rows, 6)\nind_cat = np.random.randint(0, 3, (n_rows, 1))\ntarget = np.array([0,1,2])[ind_cat]\nind_cat2 = np.random.randint(0, 3, (n_rows, 1))\ntarget2 = np.array([100,200,300])[ind_cat2]\ndata = np.concatenate([sample_ids, feat_ids, cont, target, target], -1)\ncolumns = ['sample_id', 'feat_id'] + (np.arange(6) + 1).astype(str).tolist() + ['target'] + ['target2']\ndf = pd.DataFrame(data, columns=columns)\nidx = random_choice(np.arange(len(df)), len(df), False)\nnew_dtypes = {'sample_id':np.int32, 'feat_id':np.int32, '1':np.float32, '2':np.float32, '3':np.float32, '4':np.float32, '5':np.float32, '6':np.float32}\ndf = df.astype(dtype=new_dtypes)\ndf = df.loc[idx].reset_index(drop=True)\ndf\n\n\n\n\n\n\n\n\nsample_id\nfeat_id\n1\n2\n3\n4\n5\n6\ntarget\ntarget2\n\n\n\n\n0\n625\n2\n-1.390549\n0.770179\n-0.848480\n0.853631\n-0.309984\n0.874338\n2.0\n2.0\n\n\n1\n526\n4\n1.152397\n2.064397\n-0.392603\n-0.275797\n-0.047526\n-2.248814\n2.0\n2.0\n\n\n2\n397\n6\n-1.052930\n0.631396\n-0.758800\n-0.606483\n-2.776054\n-0.457755\n1.0\n1.0\n\n\n3\n528\n8\n-0.178637\n-1.253319\n-1.154014\n0.913876\n1.051010\n-0.635762\n1.0\n1.0\n\n\n4\n249\n2\n0.612595\n0.888297\n0.065024\n1.621935\n-0.180479\n0.309977\n1.0\n1.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n9995\n272\n1\n-0.432325\n1.645262\n1.502872\n-1.144859\n0.919653\n0.414304\n0.0\n0.0\n\n\n9996\n920\n5\n-0.724702\n-1.471832\n1.209086\n1.206532\n0.555676\n0.352726\n2.0\n2.0\n\n\n9997\n662\n6\n1.122043\n-0.379357\n-0.344517\n-1.545091\n0.187894\n1.062510\n2.0\n2.0\n\n\n9998\n71\n7\n-0.053582\n-0.854992\n-1.118632\n-1.967820\n-0.344804\n0.128105\n0.0\n0.0\n\n\n9999\n407\n4\n-1.565716\n-0.947183\n-0.401944\n-1.309024\n-0.237755\n-0.743251\n2.0\n2.0\n\n\n\n\n10000 rows × 10 columns\n\n\n\n\nfrom scipy.stats import mode\n\n\ndef y_func(o): return mode(o, axis=1, keepdims=True).mode\nX, y = df2xy(df, sample_col='sample_id', feat_col='feat_id', target_col=['target', 'target2'], sort_by=['sample_id', 'feat_id'], y_func=y_func)\ntest_eq(X.shape, (1000, 10, 6))\ntest_eq(y.shape, (1000, 2))\nrand_idx = np.random.randint(0, np.max(df.sample_id))\nsorted_df = df.sort_values(by=['sample_id', 'feat_id'], kind='stable').reset_index(drop=True)\ntest_eq(X[rand_idx], sorted_df[sorted_df.sample_id == rand_idx][['1', '2', '3', '4', '5', '6']].values)\ntest_eq(np.squeeze(mode(sorted_df[sorted_df.sample_id == rand_idx][['target', 'target2']].values).mode), y[rand_idx])\n\n\n# Univariate\nfrom io import StringIO\n\n\nTESTDATA = StringIO(\"\"\"sample_id;value_0;value_1;target\n    rob;2;3;0\n    alice;6;7;1\n    eve;11;12;2\n    \"\"\")\n\ndf = pd.read_csv(TESTDATA, sep=\";\")\ndisplay(df)\nX, y = df2Xy(df, sample_col='sample_id', target_col='target', data_cols=['value_0', 'value_1'], sort_by='sample_id')\ntest_eq(X.shape, (3, 1, 2))\ntest_eq(y.shape, (3,))\nX, y\n\n\n\n\n\n\n\n\nsample_id\nvalue_0\nvalue_1\ntarget\n\n\n\n\n0\nrob\n2\n3\n0\n\n\n1\nalice\n6\n7\n1\n\n\n2\neve\n11\n12\n2\n\n\n\n\n\n\n\n(array([[[ 6,  7]],\n \n        [[11, 12]],\n \n        [[ 2,  3]]]),\n array([1, 2, 0]))\n\n\n\n# Univariate\nTESTDATA = StringIO(\"\"\"sample_id;timestep;values;target\n    rob;1;2;0\n    alice;1;6;1\n    eve;1;11;2\n    \n    rob;2;3;0\n    alice;2;7;1\n    eve;2;12;2\n    \"\"\")\n\ndf = pd.read_csv(TESTDATA, sep=\";\")\ndisplay(df)\ndef y_func(o): return mode(o, axis=1).mode\nX, y = df2xy(df, sample_col='sample_id', target_col='target', data_cols=['values'], sort_by='timestep', to3d=True, y_func=y_func)\ntest_eq(X.shape, (3, 1, 2))\ntest_eq(y.shape, (3, ))\nprint(X, y)\n\n\n\n\n\n\n\n\nsample_id\ntimestep\nvalues\ntarget\n\n\n\n\n0\nrob\n1\n2\n0\n\n\n1\nalice\n1\n6\n1\n\n\n2\neve\n1\n11\n2\n\n\n3\nrob\n2\n3\n0\n\n\n4\nalice\n2\n7\n1\n\n\n5\neve\n2\n12\n2\n\n\n\n\n\n\n\n[[[ 6  7]]\n\n [[11 12]]\n\n [[ 2  3]]] [1 2 0]\n\n\n\n# Multivariate\nTESTDATA = StringIO(\"\"\"sample_id;trait;value_0;value_1;target\n    rob;green;2;3;0\n    rob;yellow;3;4;0\n    rob;blue;4;5;0\n    rob;red;5;6;0\n    alice;green;6;7;1\n    alice;yellow;7;8;1\n    alice;blue;8;9;1\n    alice;red;9;10;1\n    eve;yellow;11;12;2\n    eve;green;10;11;2\n    eve;blue;12;12;2\n    eve;red;13;14;2\n    \"\"\")\n\ndf = pd.read_csv(TESTDATA, sep=\";\")\nidx = random_choice(len(df), len(df), False)\ndf = df.iloc[idx]\ndisplay(df)\ndef y_func(o): return mode(o, axis=1).mode\nX, y = df2xy(df, sample_col='sample_id', feat_col='trait', target_col='target', data_cols=['value_0', 'value_1'], y_func=y_func)\nprint(X, y)\ntest_eq(X.shape, (3, 4, 2))\ntest_eq(y.shape, (3,))\n\n\n\n\n\n\n\n\nsample_id\ntrait\nvalue_0\nvalue_1\ntarget\n\n\n\n\n9\neve\ngreen\n10\n11\n2\n\n\n10\neve\nblue\n12\n12\n2\n\n\n3\nrob\nred\n5\n6\n0\n\n\n0\nrob\ngreen\n2\n3\n0\n\n\n6\nalice\nblue\n8\n9\n1\n\n\n2\nrob\nblue\n4\n5\n0\n\n\n1\nrob\nyellow\n3\n4\n0\n\n\n4\nalice\ngreen\n6\n7\n1\n\n\n7\nalice\nred\n9\n10\n1\n\n\n8\neve\nyellow\n11\n12\n2\n\n\n11\neve\nred\n13\n14\n2\n\n\n5\nalice\nyellow\n7\n8\n1\n\n\n\n\n\n\n\n[[[ 8  9]\n  [ 6  7]\n  [ 9 10]\n  [ 7  8]]\n\n [[12 12]\n  [10 11]\n  [13 14]\n  [11 12]]\n\n [[ 4  5]\n  [ 2  3]\n  [ 5  6]\n  [ 3  4]]] [1 2 0]\n\n\n\n# Multivariate, multi-label\nTESTDATA = StringIO(\"\"\"sample_id;trait;value_0;value_1;target1;target2\n    rob;green;2;3;0;0\n    rob;yellow;3;4;0;0\n    rob;blue;4;5;0;0\n    rob;red;5;6;0;0\n    alice;green;6;7;1;0\n    alice;yellow;7;8;1;0\n    alice;blue;8;9;1;0\n    alice;red;9;10;1;0\n    eve;yellow;11;12;2;1\n    eve;green;10;11;2;1\n    eve;blue;12;12;2;1\n    eve;red;13;14;2;1\n    \"\"\")\n\ndf = pd.read_csv(TESTDATA, sep=\";\")\ndisplay(df)\ndef y_func(o): return mode(o, axis=1, keepdims=True).mode\nX, y = df2xy(df, sample_col='sample_id', feat_col='trait', target_col=['target1', 'target2'], data_cols=['value_0', 'value_1'], y_func=y_func)\ntest_eq(X.shape, (3, 4, 2))\ntest_eq(y.shape, (3, 2))\nprint(X, y)\n\n\n\n\n\n\n\n\nsample_id\ntrait\nvalue_0\nvalue_1\ntarget1\ntarget2\n\n\n\n\n0\nrob\ngreen\n2\n3\n0\n0\n\n\n1\nrob\nyellow\n3\n4\n0\n0\n\n\n2\nrob\nblue\n4\n5\n0\n0\n\n\n3\nrob\nred\n5\n6\n0\n0\n\n\n4\nalice\ngreen\n6\n7\n1\n0\n\n\n5\nalice\nyellow\n7\n8\n1\n0\n\n\n6\nalice\nblue\n8\n9\n1\n0\n\n\n7\nalice\nred\n9\n10\n1\n0\n\n\n8\neve\nyellow\n11\n12\n2\n1\n\n\n9\neve\ngreen\n10\n11\n2\n1\n\n\n10\neve\nblue\n12\n12\n2\n1\n\n\n11\neve\nred\n13\n14\n2\n1\n\n\n\n\n\n\n\n[[[ 8  9]\n  [ 6  7]\n  [ 9 10]\n  [ 7  8]]\n\n [[12 12]\n  [10 11]\n  [13 14]\n  [11 12]]\n\n [[ 4  5]\n  [ 2  3]\n  [ 5  6]\n  [ 3  4]]] [[1 0]\n [2 1]\n [0 0]]\n\n\n\n# Multivariate, unlabeled\nTESTDATA = StringIO(\"\"\"sample_id;trait;value_0;value_1;target\n    rob;green;2;3;0\n    rob;yellow;3;4;0\n    rob;blue;4;5;0\n    rob;red;5;6;0\n    alice;green;6;7;1\n    alice;yellow;7;8;1\n    alice;blue;8;9;1\n    alice;red;9;10;1\n    eve;yellow;11;12;2\n    eve;green;10;11;2\n    eve;blue;12;12;2\n    eve;red;13;14;2\n    \"\"\")\n\ndf = pd.read_csv(TESTDATA, sep=\";\")\nidx = random_choice(len(df), len(df), False)\ndf = df.iloc[idx]\ndisplay(df)\ndef y_func(o): return mode(o, axis=1, keepdims=True).mode\nX, y = df2xy(df, sample_col='sample_id', feat_col='trait', data_cols=['value_0', 'value_1'], y_func=y_func)\nprint(X, y)\ntest_eq(X.shape, (3, 4, 2))\ntest_eq(y, None)\n\n\n\n\n\n\n\n\nsample_id\ntrait\nvalue_0\nvalue_1\ntarget\n\n\n\n\n11\neve\nred\n13\n14\n2\n\n\n3\nrob\nred\n5\n6\n0\n\n\n9\neve\ngreen\n10\n11\n2\n\n\n10\neve\nblue\n12\n12\n2\n\n\n6\nalice\nblue\n8\n9\n1\n\n\n1\nrob\nyellow\n3\n4\n0\n\n\n4\nalice\ngreen\n6\n7\n1\n\n\n2\nrob\nblue\n4\n5\n0\n\n\n0\nrob\ngreen\n2\n3\n0\n\n\n8\neve\nyellow\n11\n12\n2\n\n\n7\nalice\nred\n9\n10\n1\n\n\n5\nalice\nyellow\n7\n8\n1\n\n\n\n\n\n\n\n[[[ 8  9]\n  [ 6  7]\n  [ 9 10]\n  [ 7  8]]\n\n [[12 12]\n  [10 11]\n  [13 14]\n  [11 12]]\n\n [[ 4  5]\n  [ 2  3]\n  [ 5  6]\n  [ 3  4]]] None\n\n\n\nTESTDATA = StringIO(\"\"\"sample_id;trait;timestep;values;target\n    rob;green;1;2;0\n    rob;yellow;1;3;0\n    rob;blue;1;4;0\n    rob;red;1;5;0\n    alice;green;1;6;1\n    alice;yellow;1;7;1\n    alice;blue;1;8;1\n    alice;red;1;9;1\n    eve;yellow;1;11;2\n    eve;green;1;10;2\n    eve;blue;1;12;2\n    eve;red;1;13;2\n    \n    rob;green;2;3;0\n    rob;yellow;2;4;0\n    rob;blue;2;5;0\n    rob;red;2;6;0\n    alice;green;2;7;1\n    alice;yellow;2;8;1\n    alice;blue;2;9;1\n    alice;red;2;10;1\n    eve;yellow;2;12;2\n    eve;green;2;11;2\n    eve;blue;2;13;2\n    eve;red;2;14;2\n    \"\"\")\n\ndf = pd.read_csv(TESTDATA, sep=\";\")\ndisplay(df)\ndef y_func(o): return mode(o, axis=1).mode\nX, y = df2xy(df, sample_col='sample_id', feat_col='trait', sort_by='timestep', target_col='target', data_cols=['values'], y_func=y_func)\nprint(X, y)\ntest_eq(X.shape, (3, 4, 2))\ntest_eq(y.shape, (3, ))\n\n\n\n\n\n\n\n\nsample_id\ntrait\ntimestep\nvalues\ntarget\n\n\n\n\n0\nrob\ngreen\n1\n2\n0\n\n\n1\nrob\nyellow\n1\n3\n0\n\n\n2\nrob\nblue\n1\n4\n0\n\n\n3\nrob\nred\n1\n5\n0\n\n\n4\nalice\ngreen\n1\n6\n1\n\n\n5\nalice\nyellow\n1\n7\n1\n\n\n6\nalice\nblue\n1\n8\n1\n\n\n7\nalice\nred\n1\n9\n1\n\n\n8\neve\nyellow\n1\n11\n2\n\n\n9\neve\ngreen\n1\n10\n2\n\n\n10\neve\nblue\n1\n12\n2\n\n\n11\neve\nred\n1\n13\n2\n\n\n12\nrob\ngreen\n2\n3\n0\n\n\n13\nrob\nyellow\n2\n4\n0\n\n\n14\nrob\nblue\n2\n5\n0\n\n\n15\nrob\nred\n2\n6\n0\n\n\n16\nalice\ngreen\n2\n7\n1\n\n\n17\nalice\nyellow\n2\n8\n1\n\n\n18\nalice\nblue\n2\n9\n1\n\n\n19\nalice\nred\n2\n10\n1\n\n\n20\neve\nyellow\n2\n12\n2\n\n\n21\neve\ngreen\n2\n11\n2\n\n\n22\neve\nblue\n2\n13\n2\n\n\n23\neve\nred\n2\n14\n2\n\n\n\n\n\n\n\n[[[ 8  9]\n  [ 6  7]\n  [ 9 10]\n  [ 7  8]]\n\n [[12 13]\n  [10 11]\n  [13 14]\n  [11 12]]\n\n [[ 4  5]\n  [ 2  3]\n  [ 5  6]\n  [ 3  4]]] [1 2 0]\n\n\n\nsource\n\n\ndf2np3d\n\n df2np3d (df, groupby, data_cols=None)\n\nTransforms a df (with the same number of rows per group in groupby) to a 3d ndarray\n\nuser = np.array([1,2]).repeat(4).reshape(-1,1)\nval = np.random.rand(8, 3)\ndata = np.concatenate([user, val], axis=-1)\ndf = pd.DataFrame(data, columns=['user', 'x1', 'x2', 'x3'])\ntest_eq(df2np3d(df, ['user'], ['x1', 'x2', 'x3']).shape, (2, 3, 4))\n\n\nsource\n\n\nadd_missing_value_cols\n\n add_missing_value_cols (df, cols=None, dtype=&lt;class 'float'&gt;,\n                         fill_value=None)\n\n\ndata = np.random.randn(10, 2)\nmask = data &gt; .8\ndata[mask] = np.nan\ndf = pd.DataFrame(data, columns=['A', 'B'])\ndf = add_missing_value_cols(df, cols=None, dtype=float)\ntest_eq(df['A'].isnull().sum(), df['missing_A'].sum())\ntest_eq(df['B'].isnull().sum(), df['missing_B'].sum())\ndf\n\n\n\n\n\n\n\n\nA\nB\nmissing_A\nmissing_B\n\n\n\n\n0\n0.476712\n-0.880797\n0.0\n0.0\n\n\n1\nNaN\n-1.517210\n1.0\n0.0\n\n\n2\n-1.348997\n-0.878441\n0.0\n0.0\n\n\n3\nNaN\n0.290756\n1.0\n0.0\n\n\n4\n0.569218\n-1.415777\n0.0\n0.0\n\n\n5\n0.591641\n-2.133860\n0.0\n0.0\n\n\n6\nNaN\nNaN\n1.0\n1.0\n\n\n7\nNaN\n-0.119397\n1.0\n0.0\n\n\n8\n-0.727988\n0.057254\n0.0\n0.0\n\n\n9\n-0.631352\n-0.219028\n0.0\n0.0\n\n\n\n\n\n\n\n\nsource\n\n\nadd_missing_timestamps\n\n add_missing_timestamps (df, datetime_col=None, use_index=False,\n                         unique_id_cols=None, groupby=None,\n                         fill_value=nan, range_by_group=True,\n                         start_date=None, end_date=None, freq=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\npandas DataFrame\n\n\ndatetime_col\nNoneType\nNone\ncolumn that contains the datetime data (without duplicates within groups)\n\n\nuse_index\nbool\nFalse\nindicates if the index contains the datetime data\n\n\nunique_id_cols\nNoneType\nNone\ncolumn used to identify unique_ids\n\n\ngroupby\nNoneType\nNone\nsame as unique_id_cols. Will be deprecated. Kept for compatiblity.\n\n\nfill_value\nfloat\nnan\nvalues that will be insert where missing dates exist. Default:np.nan\n\n\nrange_by_group\nbool\nTrue\nif True, dates will be filled between min and max dates for each group. Otherwise, between the min and max dates in the df.\n\n\nstart_date\nNoneType\nNone\nstart date to fill in missing dates (same for all unique_ids)\n\n\nend_date\nNoneType\nNone\nend date to fill in missing dates (same for all unique_ids)\n\n\nfreq\nNoneType\nNone\nfrequency used to fill in the missing datetime\n\n\n\n\n# Filling dates between min and max dates\ndates = pd.date_range('2021-05-01', '2021-05-07').values\ndata = np.zeros((len(dates), 3))\ndata[:, 0] = dates\ndata[:, 1] = np.random.rand(len(dates))\ndata[:, 2] = np.random.rand(len(dates))\ncols = ['date', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([1,3]).reset_index(drop=True)\ndate_df_with_missing_dates\n\n\n\n\n\n\n\n\ndate\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01\n0.537248\n0.670897\n\n\n1\n2021-05-03\n0.299912\n0.421039\n\n\n2\n2021-05-05\n0.648372\n0.204641\n\n\n3\n2021-05-06\n0.017475\n0.022183\n\n\n4\n2021-05-07\n0.965919\n0.470055\n\n\n\n\n\n\n\n\n# No groups\nexpected_output_df = date_df.copy()\nexpected_output_df.loc[[1,3], ['feature1', 'feature2']] = np.nan\ndisplay(expected_output_df)\noutput_df = add_missing_timestamps(date_df_with_missing_dates.copy(), \n                                   'date', \n                                   unique_id_cols=None, \n                                   fill_value=np.nan, \n                                   range_by_group=False)\ntest_eq(output_df, expected_output_df)\n\n\n\n\n\n\n\n\ndate\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01\n0.537248\n0.670897\n\n\n1\n2021-05-02\nNaN\nNaN\n\n\n2\n2021-05-03\n0.299912\n0.421039\n\n\n3\n2021-05-04\nNaN\nNaN\n\n\n4\n2021-05-05\n0.648372\n0.204641\n\n\n5\n2021-05-06\n0.017475\n0.022183\n\n\n6\n2021-05-07\n0.965919\n0.470055\n\n\n\n\n\n\n\n\n# Filling dates between min and max dates for each value in groupby column\ndates = pd.date_range('2021-05-01', '2021-05-07').values\ndates = np.concatenate((dates, dates))\ndata = np.zeros((len(dates), 4))\ndata[:, 0] = dates\ndata[:, 1] = np.array([0]*(len(dates)//2)+[1]*(len(dates)//2))\ndata[:, 2] = np.random.rand(len(dates))\ndata[:, 3] = np.random.rand(len(dates))\ncols = ['date', 'id', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'id': int, 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([0,1,3,8,11,13]).reset_index(drop=True)\ndate_df_with_missing_dates\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-03\n0\n0.059398\n0.255853\n\n\n1\n2021-05-05\n0\n0.235536\n0.455261\n\n\n2\n2021-05-06\n0\n0.724423\n0.280910\n\n\n3\n2021-05-07\n0\n0.303682\n0.853959\n\n\n4\n2021-05-01\n1\n0.022424\n0.408510\n\n\n5\n2021-05-03\n1\n0.508190\n0.603880\n\n\n6\n2021-05-04\n1\n0.330924\n0.108156\n\n\n7\n2021-05-06\n1\n0.601481\n0.020182\n\n\n\n\n\n\n\n\n# groupby='id', range_by_group=True\nexpected_output_df = date_df.drop([0,1,13]).reset_index(drop=True)  \nexpected_output_df.loc[[1,6,9], ['feature1', 'feature2']] = np.nan\ndisplay(expected_output_df)\noutput_df = add_missing_timestamps(date_df_with_missing_dates.copy(), \n                                   'date', \n                                   unique_id_cols='id', \n                                   fill_value=np.nan, \n                                   range_by_group=True)\ntest_eq(expected_output_df, output_df)\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-03\n0\n0.059398\n0.255853\n\n\n1\n2021-05-04\n0\nNaN\nNaN\n\n\n2\n2021-05-05\n0\n0.235536\n0.455261\n\n\n3\n2021-05-06\n0\n0.724423\n0.280910\n\n\n4\n2021-05-07\n0\n0.303682\n0.853959\n\n\n5\n2021-05-01\n1\n0.022424\n0.408510\n\n\n6\n2021-05-02\n1\nNaN\nNaN\n\n\n7\n2021-05-03\n1\n0.508190\n0.603880\n\n\n8\n2021-05-04\n1\n0.330924\n0.108156\n\n\n9\n2021-05-05\n1\nNaN\nNaN\n\n\n10\n2021-05-06\n1\n0.601481\n0.020182\n\n\n\n\n\n\n\n\n# groupby='id', range_by_group=False\nexpected_output_df = date_df.copy() \nexpected_output_df.loc[[0,1,3,8,11,13], ['feature1', 'feature2']] = np.nan\ndisplay(expected_output_df)\noutput_df = add_missing_timestamps(date_df_with_missing_dates.copy(), \n                                   'date', \n                                   unique_id_cols='id', \n                                   fill_value=np.nan, \n                                   range_by_group=False)\ntest_eq(expected_output_df, output_df)\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01\n0\nNaN\nNaN\n\n\n1\n2021-05-02\n0\nNaN\nNaN\n\n\n2\n2021-05-03\n0\n0.059398\n0.255853\n\n\n3\n2021-05-04\n0\nNaN\nNaN\n\n\n4\n2021-05-05\n0\n0.235536\n0.455261\n\n\n5\n2021-05-06\n0\n0.724423\n0.280910\n\n\n6\n2021-05-07\n0\n0.303682\n0.853959\n\n\n7\n2021-05-01\n1\n0.022424\n0.408510\n\n\n8\n2021-05-02\n1\nNaN\nNaN\n\n\n9\n2021-05-03\n1\n0.508190\n0.603880\n\n\n10\n2021-05-04\n1\n0.330924\n0.108156\n\n\n11\n2021-05-05\n1\nNaN\nNaN\n\n\n12\n2021-05-06\n1\n0.601481\n0.020182\n\n\n13\n2021-05-07\n1\nNaN\nNaN\n\n\n\n\n\n\n\n\n# Filling dates between min and max timestamps\ndates = pd.date_range('2021-05-01 000:00', '2021-05-01 20:00', freq='4H').values\ndata = np.zeros((len(dates), 3))\ndata[:, 0] = dates\ndata[:, 1] = np.random.rand(len(dates))\ndata[:, 2] = np.random.rand(len(dates))\ncols = ['date', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([1,3]).reset_index(drop=True)\ndate_df_with_missing_dates\n\n\n\n\n\n\n\n\ndate\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 00:00:00\n0.774846\n0.624488\n\n\n1\n2021-05-01 08:00:00\n0.683837\n0.441230\n\n\n2\n2021-05-01 16:00:00\n0.142269\n0.279095\n\n\n3\n2021-05-01 20:00:00\n0.953686\n0.205123\n\n\n\n\n\n\n\n\n# No groups\nexpected_output_df = date_df.copy()\nexpected_output_df.loc[[1,3], ['feature1', 'feature2']] = np.nan\ndisplay(expected_output_df)\noutput_df = add_missing_timestamps(date_df_with_missing_dates.copy(), 'date', groupby=None, fill_value=np.nan, range_by_group=False, freq='4H')\ntest_eq(output_df, expected_output_df)\n\n\n\n\n\n\n\n\ndate\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 00:00:00\n0.774846\n0.624488\n\n\n1\n2021-05-01 04:00:00\nNaN\nNaN\n\n\n2\n2021-05-01 08:00:00\n0.683837\n0.441230\n\n\n3\n2021-05-01 12:00:00\nNaN\nNaN\n\n\n4\n2021-05-01 16:00:00\n0.142269\n0.279095\n\n\n5\n2021-05-01 20:00:00\n0.953686\n0.205123\n\n\n\n\n\n\n\n\n# Filling missing values between min and max timestamps for each value in groupby column\n\ndates = pd.date_range('2021-05-01 000:00', '2021-05-01 20:00', freq='4H').values\ndates = np.concatenate((dates, dates))\ndata = np.zeros((len(dates), 4))\ndata[:, 0] = dates\ndata[:, 1] = np.array([0]*(len(dates)//2)+[1]*(len(dates)//2))\ndata[:, 2] = np.random.rand(len(dates))\ndata[:, 3] = np.random.rand(len(dates))\ncols = ['date', 'id', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'id': int, 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([0,1,3,8,9,11]).reset_index(drop=True)\ndate_df_with_missing_dates\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 08:00:00\n0\n0.438784\n0.084472\n\n\n1\n2021-05-01 16:00:00\n0\n0.059613\n0.445215\n\n\n2\n2021-05-01 20:00:00\n0\n0.511807\n0.001034\n\n\n3\n2021-05-01 00:00:00\n1\n0.970115\n0.280121\n\n\n4\n2021-05-01 04:00:00\n1\n0.775051\n0.436359\n\n\n5\n2021-05-01 16:00:00\n1\n0.469987\n0.457442\n\n\n\n\n\n\n\n\n# groupby='id', range_by_group=True\nexpected_output_df = date_df.drop([0,1,11]).reset_index(drop=True)  \nexpected_output_df.loc[[1,6,7], ['feature1', 'feature2']] = np.nan\ndisplay(expected_output_df)\noutput_df = add_missing_timestamps(date_df_with_missing_dates.copy(),\n                                   'date', \n                                   groupby='id', \n                                   fill_value=np.nan, \n                                   range_by_group=True, \n                                   freq='4H')\ntest_eq(expected_output_df, output_df)\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 08:00:00\n0\n0.438784\n0.084472\n\n\n1\n2021-05-01 12:00:00\n0\nNaN\nNaN\n\n\n2\n2021-05-01 16:00:00\n0\n0.059613\n0.445215\n\n\n3\n2021-05-01 20:00:00\n0\n0.511807\n0.001034\n\n\n4\n2021-05-01 00:00:00\n1\n0.970115\n0.280121\n\n\n5\n2021-05-01 04:00:00\n1\n0.775051\n0.436359\n\n\n6\n2021-05-01 08:00:00\n1\nNaN\nNaN\n\n\n7\n2021-05-01 12:00:00\n1\nNaN\nNaN\n\n\n8\n2021-05-01 16:00:00\n1\n0.469987\n0.457442\n\n\n\n\n\n\n\n\n# groupby='id', range_by_group=False\nexpected_output_df = date_df.copy() \nexpected_output_df.loc[[0,1,3,8,9,11], ['feature1', 'feature2']] = np.nan\ndisplay(expected_output_df)\noutput_df = add_missing_timestamps(date_df_with_missing_dates.copy(), \n                                   'date', \n                                   groupby='id', \n                                   fill_value=np.nan, \n                                   range_by_group=False, \n                                   freq='4H')\ntest_eq(expected_output_df, output_df)\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 00:00:00\n0\nNaN\nNaN\n\n\n1\n2021-05-01 04:00:00\n0\nNaN\nNaN\n\n\n2\n2021-05-01 08:00:00\n0\n0.438784\n0.084472\n\n\n3\n2021-05-01 12:00:00\n0\nNaN\nNaN\n\n\n4\n2021-05-01 16:00:00\n0\n0.059613\n0.445215\n\n\n5\n2021-05-01 20:00:00\n0\n0.511807\n0.001034\n\n\n6\n2021-05-01 00:00:00\n1\n0.970115\n0.280121\n\n\n7\n2021-05-01 04:00:00\n1\n0.775051\n0.436359\n\n\n8\n2021-05-01 08:00:00\n1\nNaN\nNaN\n\n\n9\n2021-05-01 12:00:00\n1\nNaN\nNaN\n\n\n10\n2021-05-01 16:00:00\n1\n0.469987\n0.457442\n\n\n11\n2021-05-01 20:00:00\n1\nNaN\nNaN\n\n\n\n\n\n\n\n\n# No groups, with duplicate dates ==&gt; FAILS\ndates = pd.date_range('2021-05-01 000:00', '2021-05-01 20:00', freq='4H').values\ndata = np.zeros((len(dates), 3))\ndata[:, 0] = dates\ndata[:, 1] = np.random.rand(len(dates))\ndata[:, 2] = np.random.rand(len(dates))\ncols = ['date', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([1,3]).reset_index(drop=True)\ndate_df_with_missing_dates.loc[3, 'date'] = date_df_with_missing_dates.loc[2, 'date']\ndisplay(date_df_with_missing_dates)\ntest_fail(add_missing_timestamps, args=[date_df_with_missing_dates, 'date'], kwargs=dict(groupby=None, fill_value=np.nan, range_by_group=False, freq='4H'), )\n\n\n\n\n\n\n\n\ndate\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 00:00:00\n0.755092\n0.002068\n\n\n1\n2021-05-01 08:00:00\n0.570693\n0.087019\n\n\n2\n2021-05-01 16:00:00\n0.228869\n0.856618\n\n\n3\n2021-05-01 16:00:00\n0.349506\n0.428253\n\n\n\n\n\n\n\n\n# groupby='id', range_by_group=True, with duplicate dates ==&gt; FAILS\n\ndates = pd.date_range('2021-05-01 000:00', '2021-05-01 20:00', freq='4H').values\ndates = np.concatenate((dates, dates))\ndata = np.zeros((len(dates), 4))\ndata[:, 0] = dates\ndata[:, 1] = np.array([0]*(len(dates)//2)+[1]*(len(dates)//2))\ndata[:, 2] = np.random.rand(len(dates))\ndata[:, 3] = np.random.rand(len(dates))\ncols = ['date', 'id', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'id': int, 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([0,1,8,9,11]).reset_index(drop=True)\ndate_df_with_missing_dates.loc[3, 'date'] = date_df_with_missing_dates.loc[2, 'date']\ndisplay(date_df_with_missing_dates)\ntest_fail(add_missing_timestamps, args=[date_df_with_missing_dates, 'date'], kwargs=dict(groupby='id', fill_value=np.nan, range_by_group=True, freq='4H'), \n          contains='cannot handle a non-unique multi-index!')\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 08:00:00\n0\n0.040345\n0.312874\n\n\n1\n2021-05-01 12:00:00\n0\n0.713424\n0.597211\n\n\n2\n2021-05-01 16:00:00\n0\n0.468382\n0.652314\n\n\n3\n2021-05-01 16:00:00\n0\n0.396691\n0.605664\n\n\n4\n2021-05-01 00:00:00\n1\n0.804646\n0.964115\n\n\n5\n2021-05-01 04:00:00\n1\n0.089925\n0.072410\n\n\n6\n2021-05-01 16:00:00\n1\n0.830786\n0.560658\n\n\n\n\n\n\n\n\n# groupby='id', range_by_group=FALSE, with duplicate dates ==&gt; FAILS\n\ndates = pd.date_range('2021-05-01 000:00', '2021-05-01 20:00', freq='4H').values\ndates = np.concatenate((dates, dates))\ndata = np.zeros((len(dates), 4))\ndata[:, 0] = dates\ndata[:, 1] = np.array([0]*(len(dates)//2)+[1]*(len(dates)//2))\ndata[:, 2] = np.random.rand(len(dates))\ndata[:, 3] = np.random.rand(len(dates))\ncols = ['date', 'id', 'feature1', 'feature2']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'id': int, 'feature1': float, 'feature2': float})\ndate_df_with_missing_dates = date_df.drop([0,1,8,9,11]).reset_index(drop=True)\ndate_df_with_missing_dates.loc[3, 'date'] = date_df_with_missing_dates.loc[2, 'date']\ndisplay(date_df_with_missing_dates)\ntest_fail(add_missing_timestamps, args=[date_df_with_missing_dates, 'date'], kwargs=dict(groupby='id', fill_value=np.nan, range_by_group=False, freq='4H'), \n          contains='cannot handle a non-unique multi-index!')\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\n\n\n\n\n0\n2021-05-01 08:00:00\n0\n0.448508\n0.953596\n\n\n1\n2021-05-01 12:00:00\n0\n0.868802\n0.526845\n\n\n2\n2021-05-01 16:00:00\n0\n0.223070\n0.304842\n\n\n3\n2021-05-01 16:00:00\n0\n0.645661\n0.270956\n\n\n4\n2021-05-01 00:00:00\n1\n0.017250\n0.787757\n\n\n5\n2021-05-01 04:00:00\n1\n0.783341\n0.608269\n\n\n6\n2021-05-01 16:00:00\n1\n0.426247\n0.926149\n\n\n\n\n\n\n\n\nsource\n\n\ntime_encoding\n\n time_encoding (series, freq, max_val=None)\n\n*Transforms a pandas series of dtype datetime64 (of any freq) or DatetimeIndex into 2 float arrays\nAvailable options: microsecond, millisecond, second, minute, hour, day = day_of_month = dayofmonth, day_of_week = weekday = dayofweek, day_of_year = dayofyear, week = week_of_year = weekofyear, month and year*\n\nfor freq in ['microsecond', 'second', 'minute', 'hour', 'day', 'dayofweek', 'dayofyear', 'month']:\n    tdf = pd.DataFrame(pd.date_range('2021-03-01', dt.datetime.today()), columns=['date'])\n    a,b = time_encoding(tdf.date, freq=freq)\n    plt.plot(a)\n    plt.plot(b)\n    plt.title(freq)\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor freq in ['microsecond', 'second', 'minute', 'hour', 'day', 'dayofweek', 'dayofyear', 'month']:\n    dateindex = pd.date_range('2021-03-01', dt.datetime.today())\n    a,b = time_encoding(dateindex, freq=freq)\n    plt.plot(a)\n    plt.plot(b)\n    plt.title(freq)\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndow_sin, dow_cos = time_encoding(date_df['date'], 'dayofweek')\nplt.plot(dow_sin)\nplt.plot(dow_cos)\nplt.title('DayOfWeek')\nplt.show()\ndate_df['dow_sin'] = dow_sin\ndate_df['dow_cos'] = dow_cos\ndate_df\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature2\ndow_sin\ndow_cos\n\n\n\n\n0\n2021-05-01 00:00:00\n0\n0.773597\n0.465634\n-0.974928\n-0.222521\n\n\n1\n2021-05-01 04:00:00\n0\n0.265526\n0.963753\n-0.974928\n-0.222521\n\n\n2\n2021-05-01 08:00:00\n0\n0.448508\n0.953596\n-0.974928\n-0.222521\n\n\n3\n2021-05-01 12:00:00\n0\n0.868802\n0.526845\n-0.974928\n-0.222521\n\n\n4\n2021-05-01 16:00:00\n0\n0.223070\n0.304842\n-0.974928\n-0.222521\n\n\n5\n2021-05-01 20:00:00\n0\n0.645661\n0.270956\n-0.974928\n-0.222521\n\n\n6\n2021-05-01 00:00:00\n1\n0.017250\n0.787757\n-0.974928\n-0.222521\n\n\n7\n2021-05-01 04:00:00\n1\n0.783341\n0.608269\n-0.974928\n-0.222521\n\n\n8\n2021-05-01 08:00:00\n1\n0.629875\n0.170726\n-0.974928\n-0.222521\n\n\n9\n2021-05-01 12:00:00\n1\n0.302927\n0.682136\n-0.974928\n-0.222521\n\n\n10\n2021-05-01 16:00:00\n1\n0.426247\n0.926149\n-0.974928\n-0.222521\n\n\n11\n2021-05-01 20:00:00\n1\n0.830624\n0.543715\n-0.974928\n-0.222521\n\n\n\n\n\n\n\n\nsource\n\n\nget_gaps\n\n get_gaps (o:torch.Tensor, forward:bool=True, backward:bool=True,\n           nearest:bool=True, normalize:bool=True)\n\nNumber of sequence steps from previous, to next and/or to nearest real value along the last dimension of 3D arrays or tensors\n\nsource\n\n\nnearest_gaps\n\n nearest_gaps (o, normalize=True)\n\nNumber of sequence steps to nearest real value along the last dimension of 3D arrays or tensors\n\nsource\n\n\nbackward_gaps\n\n backward_gaps (o, normalize=True)\n\nNumber of sequence steps to next real value along the last dimension of 3D arrays or tensors\n\nsource\n\n\nforward_gaps\n\n forward_gaps (o, normalize=True)\n\nNumber of sequence steps since previous real value along the last dimension of 3D arrays or tensors\n\nt = torch.rand(1, 2, 8)\narr = t.numpy()\nt[t &lt;.6] = np.nan\ntest_ge(nearest_gaps(t).min().item(), 0)\ntest_ge(nearest_gaps(arr).min(), 0)\ntest_le(nearest_gaps(t).min().item(), 1)\ntest_le(nearest_gaps(arr).min(), 1)\ntest_eq(torch.isnan(forward_gaps(t)).sum(), 0)\ntest_eq(np.isnan(forward_gaps(arr)).sum(), 0)\nag = get_gaps(t)\ntest_eq(ag.shape, (1,6,8))\ntest_eq(torch.isnan(ag).sum(), 0)\n\n\nsource\n\n\nadd_delta_timestamp_cols\n\n add_delta_timestamp_cols (df, cols=None, groupby=None, forward=True,\n                           backward=True, nearest=True, normalize=True)\n\n\n# Add delta timestamp features for the no groups setting\ndates = pd.date_range('2021-05-01', '2021-05-07').values\ndata = np.zeros((len(dates), 2))\ndata[:, 0] = dates\ndata[:, 1] = np.random.rand(len(dates))\n\ncols = ['date', 'feature1']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'feature1': float})\ndate_df.loc[[1,3,4],'feature1'] = np.nan\ndate_df\n\n\n\n\n\n\n\n\ndate\nfeature1\n\n\n\n\n0\n2021-05-01\n0.132532\n\n\n1\n2021-05-02\nNaN\n\n\n2\n2021-05-03\n0.403176\n\n\n3\n2021-05-04\nNaN\n\n\n4\n2021-05-05\nNaN\n\n\n5\n2021-05-06\n0.179554\n\n\n6\n2021-05-07\n0.446536\n\n\n\n\n\n\n\n\n# No groups\nexpected_output_df = date_df.copy()\nexpected_output_df['feature1_dt_fwd'] = np.array([1,1,2,1,2,3,1])\nexpected_output_df['feature1_dt_bwd'] = np.array([2,1,3,2,1,1,1])\nexpected_output_df['feature1_dt_nearest'] = np.array([1,1,2,1,1,1,1])\n\ndisplay(expected_output_df)\noutput_df = add_delta_timestamp_cols(date_df, cols='feature1', normalize=False)\ntest_eq(expected_output_df, output_df)\n\n\n\n\n\n\n\n\ndate\nfeature1\nfeature1_dt_fwd\nfeature1_dt_bwd\nfeature1_dt_nearest\n\n\n\n\n0\n2021-05-01\n0.132532\n1\n2\n1\n\n\n1\n2021-05-02\nNaN\n1\n1\n1\n\n\n2\n2021-05-03\n0.403176\n2\n3\n2\n\n\n3\n2021-05-04\nNaN\n1\n2\n1\n\n\n4\n2021-05-05\nNaN\n2\n1\n1\n\n\n5\n2021-05-06\n0.179554\n3\n1\n1\n\n\n6\n2021-05-07\n0.446536\n1\n1\n1\n\n\n\n\n\n\n\n\n# Add delta timestamp features within a group\ndates = pd.date_range('2021-05-01', '2021-05-07').values\ndates = np.concatenate((dates, dates))\ndata = np.zeros((len(dates), 3))\ndata[:, 0] = dates\ndata[:, 1] = np.array([0]*(len(dates)//2)+[1]*(len(dates)//2))\ndata[:, 2] = np.random.rand(len(dates))\n\ncols = ['date', 'id', 'feature1']\ndate_df = pd.DataFrame(data, columns=cols).astype({'date': 'datetime64[ns]', 'id': int, 'feature1': float})\ndate_df.loc[[1,3,4,8,9,11],'feature1'] = np.nan\ndate_df\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\n\n\n\n\n0\n2021-05-01\n0\n0.405327\n\n\n1\n2021-05-02\n0\nNaN\n\n\n2\n2021-05-03\n0\n0.055934\n\n\n3\n2021-05-04\n0\nNaN\n\n\n4\n2021-05-05\n0\nNaN\n\n\n5\n2021-05-06\n0\n0.698408\n\n\n6\n2021-05-07\n0\n0.064831\n\n\n7\n2021-05-01\n1\n0.407541\n\n\n8\n2021-05-02\n1\nNaN\n\n\n9\n2021-05-03\n1\nNaN\n\n\n10\n2021-05-04\n1\n0.113590\n\n\n11\n2021-05-05\n1\nNaN\n\n\n12\n2021-05-06\n1\n0.548088\n\n\n13\n2021-05-07\n1\n0.348813\n\n\n\n\n\n\n\n\n# groupby='id'\nexpected_output_df = date_df.copy()\nexpected_output_df['feature1_dt_fwd'] = np.array([1,1,2,1,2,3,1,1,1,2,3,1,2,1])\nexpected_output_df['feature1_dt_bwd'] = np.array([2,1,3,2,1,1,1,3,2,1,2,1,1,1])\nexpected_output_df['feature1_dt_nearest'] = np.array([1,1,2,1,1,1,1,1,1,1,2,1,1,1])\n\ndisplay(expected_output_df)\noutput_df = add_delta_timestamp_cols(date_df, cols='feature1', groupby='id', normalize=False)\ntest_eq(expected_output_df, output_df)\n\n\n\n\n\n\n\n\ndate\nid\nfeature1\nfeature1_dt_fwd\nfeature1_dt_bwd\nfeature1_dt_nearest\n\n\n\n\n0\n2021-05-01\n0\n0.405327\n1\n2\n1\n\n\n1\n2021-05-02\n0\nNaN\n1\n1\n1\n\n\n2\n2021-05-03\n0\n0.055934\n2\n3\n2\n\n\n3\n2021-05-04\n0\nNaN\n1\n2\n1\n\n\n4\n2021-05-05\n0\nNaN\n2\n1\n1\n\n\n5\n2021-05-06\n0\n0.698408\n3\n1\n1\n\n\n6\n2021-05-07\n0\n0.064831\n1\n1\n1\n\n\n7\n2021-05-01\n1\n0.407541\n1\n3\n1\n\n\n8\n2021-05-02\n1\nNaN\n1\n2\n1\n\n\n9\n2021-05-03\n1\nNaN\n2\n1\n1\n\n\n10\n2021-05-04\n1\n0.113590\n3\n2\n2\n\n\n11\n2021-05-05\n1\nNaN\n1\n1\n1\n\n\n12\n2021-05-06\n1\n0.548088\n2\n1\n1\n\n\n13\n2021-05-07\n1\n0.348813\n1\n1\n1\n\n\n\n\n\n\n\nSlidingWindow and SlidingWindowPanel are 2 useful functions that will allow you to create an array with segments of a pandas dataframe based on multiple criteria.\n\nsource\n\n\nSlidingWindow\n\n SlidingWindow (window_len:int, stride:Optional[int]=1, start:int=0,\n                pad_remainder:bool=False, padding:str='post',\n                padding_value:float=nan, add_padding_feature:bool=True,\n                get_x:Union[NoneType,int,list]=None,\n                get_y:Union[NoneType,int,list]=None,\n                y_func:Optional[&lt;built-infunctioncallable&gt;]=None,\n                output_processor:Optional[&lt;built-\n                infunctioncallable&gt;]=None, copy:bool=False,\n                horizon:Union[int,list]=1, seq_first:bool=True,\n                sort_by:Optional[list]=None, ascending:bool=True,\n                check_leakage:bool=True)\n\n*Applies a sliding window to a 1d or 2d input (np.ndarray, torch.Tensor or pd.DataFrame)\nInput:\n    You can use np.ndarray, pd.DataFrame or torch.Tensor as input\n\n    shape: (seq_len, ) or (seq_len, n_vars) if seq_first=True else (n_vars, seq_len)*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nwindow_len\nint\n\nlength of lookback window\n\n\nstride\nOptional\n1\nn datapoints the window is moved ahead along the sequence. Default: 1. If None, stride=window_len (no overlap)\n\n\nstart\nint\n0\ndetermines the step where the first window is applied: 0 (default) or a given step (int). Previous steps will be discarded.\n\n\npad_remainder\nbool\nFalse\nallows to pad remainder subsequences when the sliding window is applied and get_y == [] (unlabeled data).\n\n\npadding\nstr\npost\n‘pre’ or ‘post’ (optional, defaults to ‘pre’): pad either before or after each sequence. If pad_remainder == False, it indicates the starting point to create the sequence (‘pre’ from the end, and ‘post’ from the beginning)\n\n\npadding_value\nfloat\nnan\nvalue (float) that will be used for padding. Default: np.nan\n\n\nadd_padding_feature\nbool\nTrue\nadd an additional feature indicating whether each timestep is padded (1) or not (0).\n\n\nget_x\nUnion\nNone\nindices of columns that contain the independent variable (xs). If None, all data will be used as x.\n\n\nget_y\nUnion\nNone\nindices of columns that contain the target (ys). If None, all data will be used as y. [] means no y data is created (unlabeled data).\n\n\ny_func\nOptional\nNone\noptional function to calculate the ys based on the get_y col/s and each y sub-window. y_func must be a function applied to axis=1!\n\n\noutput_processor\nOptional\nNone\noptional function to process the final output (X (and y if available)). This is useful when some values need to be removed.The function should take X and y (even if it’s None) as arguments.\n\n\ncopy\nbool\nFalse\ncopy the original object to avoid changes in it.\n\n\nhorizon\nUnion\n1\nnumber of future datapoints to predict (y). If get_y is [] horizon will be set to 0.\n\n\nseq_first\nbool\nTrue\nTrue if input shape (seq_len, n_vars), False if input shape (n_vars, seq_len)\n\n\nsort_by\nOptional\nNone\ncolumn/s used for sorting the array in ascending order\n\n\nascending\nbool\nTrue\nused in sorting\n\n\ncheck_leakage\nbool\nTrue\nchecks if there’s leakage in the output between X and y\n\n\n\n\nwl = 5\nstride = 5\n\nt = np.repeat(np.arange(13).reshape(-1,1), 3, axis=-1)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, stride=stride, pad_remainder=True, get_y=[])(t)\nX\n\ninput shape: (13, 3)\n\n\narray([[[ 0.,  1.,  2.,  3.,  4.],\n        [ 0.,  1.,  2.,  3.,  4.],\n        [ 0.,  1.,  2.,  3.,  4.],\n        [ 0.,  0.,  0.,  0.,  0.]],\n\n       [[ 5.,  6.,  7.,  8.,  9.],\n        [ 5.,  6.,  7.,  8.,  9.],\n        [ 5.,  6.,  7.,  8.,  9.],\n        [ 0.,  0.,  0.,  0.,  0.]],\n\n       [[10., 11., 12., nan, nan],\n        [10., 11., 12., nan, nan],\n        [10., 11., 12., nan, nan],\n        [ 0.,  0.,  0.,  1.,  1.]]])\n\n\n\nwl = 5\nt = np.arange(10)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl)(t)\ntest_eq(X.shape[1:], (1, wl))\nitemify(X,)\n\ninput shape: (10,)\n\n\n(#5) [(array([[0, 1, 2, 3, 4]]),),(array([[1, 2, 3, 4, 5]]),),(array([[2, 3, 4, 5, 6]]),),(array([[3, 4, 5, 6, 7]]),),(array([[4, 5, 6, 7, 8]]),)]\n\n\n\nwl = 5\nh = 1\n\nt = np.arange(10)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, stride=1, horizon=h)(t)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: (10,)\n[(array([[0, 1, 2, 3, 4]]), 5), (array([[1, 2, 3, 4, 5]]), 6), (array([[2, 3, 4, 5, 6]]), 7), (array([[3, 4, 5, 6, 7]]), 8), (array([[4, 5, 6, 7, 8]]), 9)]\n\n\n\nwl = 5\nh = 2 # 2 or more\n\nt = np.arange(10)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, horizon=h)(t)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, (2, ))\n\ninput shape: (10,)\n[(array([[0, 1, 2, 3, 4]]), array([5, 6])), (array([[1, 2, 3, 4, 5]]), array([6, 7])), (array([[2, 3, 4, 5, 6]]), array([7, 8])), (array([[3, 4, 5, 6, 7]]), array([8, 9]))]\n\n\n\nwl = 5\nh = 2 # 2 or more\n\nt = np.arange(10).reshape(1, -1)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, stride=1, horizon=h, get_y=None, seq_first=False)(t)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, (2, ))\n\ninput shape: (1, 10)\n[(array([[0, 1, 2, 3, 4]]), array([5, 6])), (array([[1, 2, 3, 4, 5]]), array([6, 7])), (array([[2, 3, 4, 5, 6]]), array([7, 8])), (array([[3, 4, 5, 6, 7]]), array([8, 9]))]\n\n\n\nwl = 5\nh = 2 # 2 or more\n\nt = np.arange(10).reshape(1, -1)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, stride=1, horizon=h, seq_first=False)(t)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\n\ninput shape: (1, 10)\n[(array([[0, 1, 2, 3, 4]]), array([5, 6])), (array([[1, 2, 3, 4, 5]]), array([6, 7])), (array([[2, 3, 4, 5, 6]]), array([7, 8])), (array([[3, 4, 5, 6, 7]]), array([8, 9]))]\n\n\n\nwl = 5\n\nt = np.arange(10).reshape(1, -1)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, stride=3, horizon=1, get_y=None, seq_first=False)(t)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: (1, 10)\n[(array([[0, 1, 2, 3, 4]]), 5), (array([[3, 4, 5, 6, 7]]), 8)]\n\n\n\nwl = 5\nstart = 3\n\nt = np.arange(20)\nprint('input shape:', t.shape)\nX, y = SlidingWindow(wl, stride=None, horizon=1, start=start)(t)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: (20,)\n[(array([[3, 4, 5, 6, 7]]), 8), (array([[ 8,  9, 10, 11, 12]]), 13), (array([[13, 14, 15, 16, 17]]), 18)]\n\n\n\nwl = 5\n\nt = np.arange(20)\nprint('input shape:', t.shape)\ndf = pd.DataFrame(t, columns=['var'])\ndisplay(df)\nX, y = SlidingWindow(wl, stride=None, horizon=1, get_y=None)(df)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: (20,)\n\n\n\n\n\n\n\n\n\nvar\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\n10\n\n\n11\n11\n\n\n12\n12\n\n\n13\n13\n\n\n14\n14\n\n\n15\n15\n\n\n16\n16\n\n\n17\n17\n\n\n18\n18\n\n\n19\n19\n\n\n\n\n\n\n\n[(array([[0, 1, 2, 3, 4]]), 5), (array([[5, 6, 7, 8, 9]]), 10), (array([[10, 11, 12, 13, 14]]), 15)]\n\n\n\nwl = 5\n\nt = np.arange(20)\nprint('input shape:', t.shape)\ndf = pd.DataFrame(t, columns=['var'])\ndisplay(df)\nX, y = SlidingWindow(wl, stride=1, horizon=1, get_y=None)(df)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: (20,)\n\n\n\n\n\n\n\n\n\nvar\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n2\n2\n\n\n3\n3\n\n\n4\n4\n\n\n5\n5\n\n\n6\n6\n\n\n7\n7\n\n\n8\n8\n\n\n9\n9\n\n\n10\n10\n\n\n11\n11\n\n\n12\n12\n\n\n13\n13\n\n\n14\n14\n\n\n15\n15\n\n\n16\n16\n\n\n17\n17\n\n\n18\n18\n\n\n19\n19\n\n\n\n\n\n\n\n[(array([[0, 1, 2, 3, 4]]), 5), (array([[1, 2, 3, 4, 5]]), 6), (array([[2, 3, 4, 5, 6]]), 7), (array([[3, 4, 5, 6, 7]]), 8), (array([[4, 5, 6, 7, 8]]), 9), (array([[5, 6, 7, 8, 9]]), 10), (array([[ 6,  7,  8,  9, 10]]), 11), (array([[ 7,  8,  9, 10, 11]]), 12), (array([[ 8,  9, 10, 11, 12]]), 13), (array([[ 9, 10, 11, 12, 13]]), 14), (array([[10, 11, 12, 13, 14]]), 15), (array([[11, 12, 13, 14, 15]]), 16), (array([[12, 13, 14, 15, 16]]), 17), (array([[13, 14, 15, 16, 17]]), 18), (array([[14, 15, 16, 17, 18]]), 19)]\n\n\n\nwl = 5\n\nt = np.arange(20)\nprint('input shape:', t.shape)\ndf = pd.DataFrame(t, columns=['var']).T\ndisplay(df)\nX, y = SlidingWindow(wl, stride=None, horizon=1, get_y=None, seq_first=False)(df)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: (20,)\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\nvar\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n\n\n\n[(array([[0, 1, 2, 3, 4]]), 5), (array([[5, 6, 7, 8, 9]]), 10), (array([[10, 11, 12, 13, 14]]), 15)]\n\n\n\nwl = 5\nn_vars = 3\n\nt = (torch.stack(n_vars * [torch.arange(10)]).T * tensor([1, 10, 100]))\nprint('input shape:', t.shape)\ndf = pd.DataFrame(t, columns=[f'var_{i}' for i in range(n_vars)])\ndisplay(df)\nX, y = SlidingWindow(wl, horizon=1)(df)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (n_vars, wl))\n\ninput shape: torch.Size([10, 3])\n\n\n\n\n\n\n\n\n\nvar_0\nvar_1\nvar_2\n\n\n\n\n0\n0\n0\n0\n\n\n1\n1\n10\n100\n\n\n2\n2\n20\n200\n\n\n3\n3\n30\n300\n\n\n4\n4\n40\n400\n\n\n5\n5\n50\n500\n\n\n6\n6\n60\n600\n\n\n7\n7\n70\n700\n\n\n8\n8\n80\n800\n\n\n9\n9\n90\n900\n\n\n\n\n\n\n\n[(array([[  0,   1,   2,   3,   4],\n       [  0,  10,  20,  30,  40],\n       [  0, 100, 200, 300, 400]]), array([  5,  50, 500])), (array([[  1,   2,   3,   4,   5],\n       [ 10,  20,  30,  40,  50],\n       [100, 200, 300, 400, 500]]), array([  6,  60, 600])), (array([[  2,   3,   4,   5,   6],\n       [ 20,  30,  40,  50,  60],\n       [200, 300, 400, 500, 600]]), array([  7,  70, 700])), (array([[  3,   4,   5,   6,   7],\n       [ 30,  40,  50,  60,  70],\n       [300, 400, 500, 600, 700]]), array([  8,  80, 800])), (array([[  4,   5,   6,   7,   8],\n       [ 40,  50,  60,  70,  80],\n       [400, 500, 600, 700, 800]]), array([  9,  90, 900]))]\n\n\n\nwl = 5\nn_vars = 3\n\nt = (torch.stack(n_vars * [torch.arange(10)]).T * tensor([1, 10, 100]))\nprint('input shape:', t.shape)\ndf = pd.DataFrame(t, columns=[f'var_{i}' for i in range(n_vars)])\ndisplay(df)\nX, y = SlidingWindow(wl, horizon=1, get_y=\"var_0\")(df)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (n_vars, wl))\n\ninput shape: torch.Size([10, 3])\n\n\n\n\n\n\n\n\n\nvar_0\nvar_1\nvar_2\n\n\n\n\n0\n0\n0\n0\n\n\n1\n1\n10\n100\n\n\n2\n2\n20\n200\n\n\n3\n3\n30\n300\n\n\n4\n4\n40\n400\n\n\n5\n5\n50\n500\n\n\n6\n6\n60\n600\n\n\n7\n7\n70\n700\n\n\n8\n8\n80\n800\n\n\n9\n9\n90\n900\n\n\n\n\n\n\n\n[(array([[  0,   1,   2,   3,   4],\n       [  0,  10,  20,  30,  40],\n       [  0, 100, 200, 300, 400]]), 5), (array([[  1,   2,   3,   4,   5],\n       [ 10,  20,  30,  40,  50],\n       [100, 200, 300, 400, 500]]), 6), (array([[  2,   3,   4,   5,   6],\n       [ 20,  30,  40,  50,  60],\n       [200, 300, 400, 500, 600]]), 7), (array([[  3,   4,   5,   6,   7],\n       [ 30,  40,  50,  60,  70],\n       [300, 400, 500, 600, 700]]), 8), (array([[  4,   5,   6,   7,   8],\n       [ 40,  50,  60,  70,  80],\n       [400, 500, 600, 700, 800]]), 9)]\n\n\n\nwl = 5\nn_vars = 3\n\nt = (torch.stack(n_vars * [torch.arange(10)]).T * tensor([1, 10, 100]))\nprint('input shape:', t.shape)\ncolumns=[f'var_{i}' for i in range(n_vars-1)]+['target']\ndf = pd.DataFrame(t, columns=columns)\ndisplay(df)\nX, y = SlidingWindow(wl, horizon=1, get_x=columns[:-1], get_y='target')(df)\nitems = itemify(X, y)\nprint(items)\ntest_eq(items[0][0].shape, (n_vars-1, wl))\ntest_eq(items[0][1].shape, ())\n\ninput shape: torch.Size([10, 3])\n\n\n\n\n\n\n\n\n\nvar_0\nvar_1\ntarget\n\n\n\n\n0\n0\n0\n0\n\n\n1\n1\n10\n100\n\n\n2\n2\n20\n200\n\n\n3\n3\n30\n300\n\n\n4\n4\n40\n400\n\n\n5\n5\n50\n500\n\n\n6\n6\n60\n600\n\n\n7\n7\n70\n700\n\n\n8\n8\n80\n800\n\n\n9\n9\n90\n900\n\n\n\n\n\n\n\n[(array([[ 0,  1,  2,  3,  4],\n       [ 0, 10, 20, 30, 40]]), 500), (array([[ 1,  2,  3,  4,  5],\n       [10, 20, 30, 40, 50]]), 600), (array([[ 2,  3,  4,  5,  6],\n       [20, 30, 40, 50, 60]]), 700), (array([[ 3,  4,  5,  6,  7],\n       [30, 40, 50, 60, 70]]), 800), (array([[ 4,  5,  6,  7,  8],\n       [40, 50, 60, 70, 80]]), 900)]\n\n\n\nn_vars = 3\n\nt = (np.random.rand(1000, n_vars) - .5).cumsum(0)\nprint(t.shape)\nplt.plot(t)\nplt.show()\nX, y = SlidingWindow(5, stride=None, horizon=0, get_x=[0,1], get_y=2)(t)\ntest_eq(X[0].shape, (n_vars-1, wl))\ntest_eq(y[0].shape, ())\nprint(X.shape, y.shape)\n\n(1000, 3)\n\n\n\n\n\n\n\n\n\n(200, 2, 5) (200,)\n\n\n\nwl = 5\nn_vars = 3\n\nt = (np.random.rand(100, n_vars) - .5).cumsum(0)\nprint(t.shape)\ncolumns=[f'var_{i}' for i in range(n_vars-1)]+['target']\ndf = pd.DataFrame(t, columns=columns)\ndisplay(df)\nX, y = SlidingWindow(5, horizon=0, get_x=columns[:-1], get_y='target')(df)\ntest_eq(X[0].shape, (n_vars-1, wl))\ntest_eq(y[0].shape, ())\nprint(X.shape, y.shape)\n\n(100, 3)\n\n\n\n\n\n\n\n\n\nvar_0\nvar_1\ntarget\n\n\n\n\n0\n0.154072\n0.197194\n-0.083179\n\n\n1\n0.402744\n-0.248788\n-0.560573\n\n\n2\n0.448209\n0.224215\n-0.681264\n\n\n3\n0.631502\n0.406760\n-1.162043\n\n\n4\n1.099973\n0.179926\n-0.712690\n\n\n...\n...\n...\n...\n\n\n95\n-0.405079\n3.662311\n-2.779159\n\n\n96\n-0.445625\n3.488809\n-2.663381\n\n\n97\n-0.187349\n3.304898\n-2.695971\n\n\n98\n-0.100652\n3.505663\n-2.590652\n\n\n99\n0.371272\n3.279901\n-2.764369\n\n\n\n\n100 rows × 3 columns\n\n\n\n(96, 2, 5) (96,)\n\n\n\nseq_len = 100\nn_vars = 5\nt = (np.random.rand(seq_len, n_vars) - .5).cumsum(0)\nprint(t.shape)\ncolumns=[f'var_{i}' for i in range(n_vars-1)]+['target']\ndf = pd.DataFrame(t, columns=columns)\ndisplay(df)\nX, y = SlidingWindow(5, stride=1, horizon=0, get_x=columns[:-1], get_y='target', seq_first=True)(df)\ntest_eq(X[0].shape, (n_vars-1, wl))\ntest_eq(y[0].shape, ())\nprint(X.shape, y.shape)\n\n(100, 5)\n\n\n\n\n\n\n\n\n\nvar_0\nvar_1\nvar_2\nvar_3\ntarget\n\n\n\n\n0\n0.443639\n-0.288128\n-0.049732\n0.288915\n0.325872\n\n\n1\n-0.047608\n-0.009738\n0.056768\n0.541395\n0.017496\n\n\n2\n-0.243972\n0.102227\n0.361387\n0.628397\n0.049012\n\n\n3\n-0.721266\n0.045104\n0.724062\n0.940693\n0.510875\n\n\n4\n-0.641269\n0.141927\n0.793837\n1.158903\n0.417040\n\n\n...\n...\n...\n...\n...\n...\n\n\n95\n3.488117\n2.345512\n0.745483\n0.258568\n2.468550\n\n\n96\n3.187006\n1.945844\n0.833228\n0.511198\n2.115330\n\n\n97\n3.019862\n1.739802\n0.488732\n0.881324\n2.387837\n\n\n98\n3.314247\n1.992000\n0.119230\n0.797794\n2.327720\n\n\n99\n3.394578\n2.012458\n0.003244\n0.387125\n2.345970\n\n\n\n\n100 rows × 5 columns\n\n\n\n(96, 4, 5) (96,)\n\n\n\nseq_len = 100\nn_vars = 5\n\nt = (np.random.rand(seq_len, n_vars) - .5).cumsum(0)\nprint(t.shape)\ncolumns=[f'var_{i}' for i in range(n_vars-1)] + ['target']\ndf = pd.DataFrame(t, columns=columns).T\ndisplay(df)\nX, y = SlidingWindow(5, stride=1, horizon=0, get_x=columns[:-1], get_y='target', seq_first=False)(df)\ntest_eq(X[0].shape, (n_vars-1, wl))\ntest_eq(y[0].shape, ())\nprint(X.shape, y.shape)\n\n(100, 5)\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n...\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n\n\nvar_0\n-0.407162\n-0.742169\n-1.193053\n-1.058644\n-0.721243\n-1.056788\n-1.316226\n-1.247859\n-1.391482\n-1.258618\n...\n-2.847911\n-3.118643\n-3.444248\n-3.036050\n-2.664068\n-2.473782\n-2.508080\n-2.878210\n-2.841170\n-2.688932\n\n\nvar_1\n0.111643\n-0.286318\n-0.221917\n-0.026094\n-0.332200\n-0.376518\n-0.144763\n0.225361\n0.487134\n0.435856\n...\n1.569158\n1.294548\n1.564455\n1.501243\n1.490928\n1.450602\n1.440730\n1.755607\n1.380986\n1.236284\n\n\nvar_2\n-0.126951\n-0.484267\n-0.480375\n-0.706987\n-0.571379\n-0.561959\n-0.717696\n-0.586035\n-0.298053\n-0.047405\n...\n-1.748096\n-1.508691\n-1.158258\n-1.116485\n-1.153738\n-1.575450\n-1.875091\n-1.613255\n-1.274859\n-1.592096\n\n\nvar_3\n-0.462238\n-0.748774\n-0.625473\n-0.360442\n-0.789178\n-0.530832\n-0.785290\n-0.413452\n0.083685\n-0.110964\n...\n-4.873450\n-4.382297\n-4.531454\n-4.087051\n-4.087801\n-4.391084\n-4.262526\n-4.650170\n-4.465874\n-4.535273\n\n\ntarget\n0.241454\n0.084139\n-0.012974\n0.096328\n0.501035\n0.697043\n0.229185\n0.497430\n0.552922\n0.218345\n...\n-4.582426\n-4.194067\n-3.785398\n-3.808516\n-3.629740\n-3.398645\n-3.828007\n-3.600028\n-3.614195\n-3.592783\n\n\n\n\n5 rows × 100 columns\n\n\n\n(96, 4, 5) (96,)\n\n\n\nseq_len = 100\nn_vars = 5\nt = (np.random.rand(seq_len, n_vars) - .5).cumsum(0)\nprint(t.shape)\ncolumns=[f'var_{i}' for i in range(n_vars-1)] + ['target']\ndf = pd.DataFrame(t, columns=columns).T\ndisplay(df)\nX, y = SlidingWindow(5, stride=None, horizon=0, get_x=columns[:-1], get_y='target', seq_first=False)(df)\ntest_eq(X[0].shape, (n_vars-1, wl))\ntest_eq(y[0].shape, ())\nprint(X.shape, y.shape)\n\n(100, 5)\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n...\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n\n\nvar_0\n0.210943\n-0.264863\n-0.307942\n0.176782\n-0.188244\n0.118824\n0.593353\n0.611408\n0.176396\n0.566034\n...\n-4.738294\n-5.138743\n-5.203979\n-4.835758\n-4.534974\n-4.310112\n-4.366365\n-4.328250\n-4.527717\n-4.432726\n\n\nvar_1\n-0.086375\n-0.457413\n0.025571\n0.428256\n0.611573\n0.319714\n-0.085129\n0.161735\n0.052730\n-0.356617\n...\n7.203539\n7.300534\n7.267954\n6.838923\n7.054134\n6.612532\n7.108269\n6.966000\n7.407915\n7.332567\n\n\nvar_2\n0.166139\n-0.231839\n-0.468804\n-0.565628\n-0.500941\n-0.706951\n-0.881385\n-1.138549\n-0.978276\n-0.952727\n...\n0.391942\n0.802356\n0.395688\n0.033288\n0.147283\n0.589911\n0.360847\n0.322019\n0.478120\n0.278228\n\n\nvar_3\n-0.234297\n-0.467480\n-0.925036\n-0.572783\n-0.345585\n0.149537\n-0.078098\n-0.577732\n-0.771975\n-0.322283\n...\n-1.487032\n-1.971348\n-2.300616\n-2.767312\n-2.657974\n-2.880908\n-2.567235\n-2.758240\n-2.605518\n-2.166444\n\n\ntarget\n-0.416187\n-0.164800\n-0.283554\n-0.534897\n-0.896808\n-0.456572\n-0.889556\n-1.178456\n-0.877891\n-1.176442\n...\n-6.094650\n-6.510793\n-6.408799\n-6.685696\n-6.672726\n-6.210781\n-6.377436\n-5.974001\n-5.755187\n-5.608240\n\n\n\n\n5 rows × 100 columns\n\n\n\n(20, 4, 5) (20,)\n\n\n\nfrom tsai.data.validation import TrainValidTestSplitter\n\n\nseq_len = 100\nn_vars = 5\nt = (np.random.rand(seq_len, n_vars) - .5).cumsum(0)\nprint(t.shape)\ncolumns=[f'var_{i}' for i in range(n_vars-1)]+['target']\ndf = pd.DataFrame(t, columns=columns)\ndisplay(df)\nX, y = SlidingWindow(5, stride=1, horizon=0, get_x=columns[:-1], get_y='target', seq_first=True)(df)\nsplits = TrainValidTestSplitter(valid_size=.2, shuffle=False)(y)\nX.shape, y.shape, splits\n\n(100, 5)\n\n\n\n\n\n\n\n\n\nvar_0\nvar_1\nvar_2\nvar_3\ntarget\n\n\n\n\n0\n0.123248\n-0.081596\n0.099444\n0.447980\n-0.397975\n\n\n1\n0.469671\n-0.334499\n0.307867\n0.141345\n-0.131085\n\n\n2\n0.522902\n-0.696817\n0.386597\n0.156818\n0.128043\n\n\n3\n0.487025\n-0.966153\n-0.050574\n-0.248479\n-0.088962\n\n\n4\n0.396284\n-1.319821\n-0.113121\n-0.379227\n0.313690\n\n\n...\n...\n...\n...\n...\n...\n\n\n95\n6.138836\n-1.602917\n1.713049\n1.421797\n-1.873899\n\n\n96\n5.892472\n-1.896914\n1.401137\n1.065859\n-2.239942\n\n\n97\n5.421917\n-1.728568\n1.481270\n0.998533\n-2.157474\n\n\n98\n5.763120\n-1.404330\n1.931361\n1.295956\n-1.934397\n\n\n99\n5.827842\n-1.762438\n1.831712\n1.014259\n-1.831573\n\n\n\n\n100 rows × 5 columns\n\n\n\n((96, 4, 5),\n (96,),\n ((#77) [0,1,2,3,4,5,6,7,8,9...], (#19) [77,78,79,80,81,82,83,84,85,86...]))\n\n\n\ndata = np.concatenate([np.linspace(0, 1, 11).reshape(-1,1).repeat(2, 1), np.arange(11).reshape(-1,1)], -1)\ndf_test = pd.DataFrame(data, columns=['col1', 'col2', 'target'])\ndf_test['target'] = df_test['target'].astype(int)\ndf_test\n\n\n\n\n\n\n\n\ncol1\ncol2\ntarget\n\n\n\n\n0\n0.0\n0.0\n0\n\n\n1\n0.1\n0.1\n1\n\n\n2\n0.2\n0.2\n2\n\n\n3\n0.3\n0.3\n3\n\n\n4\n0.4\n0.4\n4\n\n\n5\n0.5\n0.5\n5\n\n\n6\n0.6\n0.6\n6\n\n\n7\n0.7\n0.7\n7\n\n\n8\n0.8\n0.8\n8\n\n\n9\n0.9\n0.9\n9\n\n\n10\n1.0\n1.0\n10\n\n\n\n\n\n\n\n\ndef _y_func(o): return o[:, 0]\n\n\nfor wl in np.arange(1, 20):\n    x, y = SlidingWindow(wl, None, pad_remainder=True, get_x=['col1', 'col2'], get_y=['target'], horizon=-wl, y_func=_y_func)(df_test)\n    test_eq(x.shape[0], math.ceil((len(df_test))/wl))\n    test_eq(x.shape[0], y.shape[0])\n    test_eq(x.shape[2], wl)\n    test_close(x[:, 0, 0]*10, y)\n\n\nfor wl in np.arange(1, 20):\n    x, y = SlidingWindow(wl, None, pad_remainder=True, get_x=['col1', 'col2'], get_y=['target'], horizon=-wl, y_func=None)(df_test)\n    test_eq(x.shape[0], math.ceil((len(df_test))/ wl))\n    test_eq(x.shape[0], y.shape[0])\n    test_eq(x.shape[2], wl)\n\n\nfor wl in np.arange(1, len(df_test)+1):\n    x, y = SlidingWindow(wl, None, pad_remainder=False, get_x=['col1', 'col2'], get_y=['target'], horizon=-wl, y_func=None)(df_test)\n    test_eq(x.shape[0], len(df_test) // wl)\n    test_eq(x.shape[0], y.shape[0])\n    test_eq(x.shape[2], wl)\n\n\nfor wl in np.arange(1, 20):\n    x, _ = SlidingWindow(wl, None, pad_remainder=True, get_x=['col1', 'col2'], get_y=[], horizon=0)(df_test)\n    test_eq(x.shape[0], math.ceil((len(df_test))/wl))\n    test_eq(x.shape[2], wl)\n\n\nfor wl in np.arange(2, len(df_test)):\n    x, _ = SlidingWindow(wl, wl, pad_remainder=False, get_x=['col1', 'col2'], get_y=[], horizon=0)(df_test)\n    test_eq(x.shape[0], len(df_test) // wl)\n    test_eq(x.shape[2], wl)\n\n\ndf = pd.DataFrame()\ndf['sample_id'] = np.concatenate([np.ones(n)*(i + 1) for i,n in enumerate([13])])\ndf['var1'] = df['sample_id'] + df.index.values - 1\ndf['var2'] = df['var1'] * 10\ndf['target'] = (df['var1']).astype(int)\ndf['sample_id'] = df['sample_id'].astype(int)\ndf\n\n\n\n\n\n\n\n\nsample_id\nvar1\nvar2\ntarget\n\n\n\n\n0\n1\n0.0\n0.0\n0\n\n\n1\n1\n1.0\n10.0\n1\n\n\n2\n1\n2.0\n20.0\n2\n\n\n3\n1\n3.0\n30.0\n3\n\n\n4\n1\n4.0\n40.0\n4\n\n\n5\n1\n5.0\n50.0\n5\n\n\n6\n1\n6.0\n60.0\n6\n\n\n7\n1\n7.0\n70.0\n7\n\n\n8\n1\n8.0\n80.0\n8\n\n\n9\n1\n9.0\n90.0\n9\n\n\n10\n1\n10.0\n100.0\n10\n\n\n11\n1\n11.0\n110.0\n11\n\n\n12\n1\n12.0\n120.0\n12\n\n\n\n\n\n\n\n\nX, y = SlidingWindow(window_len=3, stride=2, start=3, pad_remainder=False, padding=\"pre\", padding_value=np.nan, add_padding_feature=False,\n                     get_x=[\"var1\", \"var2\"], get_y=[\"target\"], y_func=None, output_processor=None, copy=False, horizon=4, seq_first=True, sort_by=None,\n                     ascending=True, check_leakage=True)(df)\ntest_eq(X.shape, (2, 2, 3))\ntest_eq(y.shape, (2, 4))\nX, y\n\n(array([[[ 4.,  5.,  6.],\n         [40., 50., 60.]],\n \n        [[ 6.,  7.,  8.],\n         [60., 70., 80.]]]),\n array([[ 7,  8,  9, 10],\n        [ 9, 10, 11, 12]]))\n\n\n\nX, y = SlidingWindow(window_len=3, stride=2, start=3, pad_remainder=True, padding=\"pre\", padding_value=np.nan, add_padding_feature=False,\n                     get_x=[\"var1\", \"var2\"], get_y=[\"target\"], y_func=None, output_processor=None, copy=False, horizon=4, seq_first=True, sort_by=None,\n                     ascending=True, check_leakage=True)(df)\ntest_eq(X.shape, (3, 2, 3))\ntest_eq(y.shape, (3, 4))\nX, y\n\n(array([[[nan,  3.,  4.],\n         [nan, 30., 40.]],\n \n        [[ 4.,  5.,  6.],\n         [40., 50., 60.]],\n \n        [[ 6.,  7.,  8.],\n         [60., 70., 80.]]]),\n array([[ 5,  6,  7,  8],\n        [ 7,  8,  9, 10],\n        [ 9, 10, 11, 12]]))\n\n\n\nX, y = SlidingWindow(window_len=3, stride=2, start=3, pad_remainder=False, padding=\"post\", padding_value=np.nan, add_padding_feature=False,\n                     get_x=[\"var1\", \"var2\"], get_y=[\"target\"], y_func=None, output_processor=None, copy=False, horizon=4, seq_first=True, sort_by=None,\n                     ascending=True, check_leakage=True)(df)\ntest_eq(X.shape, (2, 2, 3))\ntest_eq(y.shape, (2, 4))\nX, y\n\n(array([[[ 3.,  4.,  5.],\n         [30., 40., 50.]],\n \n        [[ 5.,  6.,  7.],\n         [50., 60., 70.]]]),\n array([[ 6,  7,  8,  9],\n        [ 8,  9, 10, 11]]))\n\n\n\nX, y = SlidingWindow(window_len=3, stride=2, start=3, pad_remainder=True, padding=\"post\", padding_value=np.nan, add_padding_feature=False,\n                     get_x=[\"var1\", \"var2\"], get_y=[\"target\"], y_func=None, output_processor=None, copy=False, horizon=4, seq_first=True, sort_by=None,\n                     ascending=True, check_leakage=True)(df)\ntest_eq(X.shape, (3, 2, 3))\ntest_eq(y.shape, (3, 4))\nX, y\n\n(array([[[ 3.,  4.,  5.],\n         [30., 40., 50.]],\n \n        [[ 5.,  6.,  7.],\n         [50., 60., 70.]],\n \n        [[ 7.,  8.,  9.],\n         [70., 80., 90.]]]),\n array([[ 6.,  7.,  8.,  9.],\n        [ 8.,  9., 10., 11.],\n        [10., 11., 12., nan]]))\n\n\n\nX, y = SlidingWindow(window_len=10, stride=2, start=3, pad_remainder=True, padding=\"pre\", padding_value=np.nan, add_padding_feature=False,\n                     get_x=[\"var1\", \"var2\"], get_y=[\"target\"], y_func=None, output_processor=None, copy=False, horizon=4, seq_first=True, sort_by=None,\n                     ascending=True, check_leakage=True)(df)\ntest_eq(X.shape, (1, 2, 10))\ntest_eq(y.shape, (1, 4))\nX, y\n\n(array([[[nan, nan, nan, nan,  3.,  4.,  5.,  6.,  7.,  8.],\n         [nan, nan, nan, nan, 30., 40., 50., 60., 70., 80.]]]),\n array([[ 9, 10, 11, 12]]))\n\n\n\nX, y = SlidingWindow(window_len=10, stride=2, start=3, pad_remainder=True, padding=\"post\", padding_value=np.nan, add_padding_feature=False,\n                     get_x=[\"var1\", \"var2\"], get_y=[\"target\"], y_func=None, output_processor=None, copy=False, horizon=4, seq_first=True, sort_by=None,\n                     ascending=True, check_leakage=True)(df)\ntest_eq(X.shape, (1, 2, 10))\ntest_eq(y.shape, (1, 4))\nX, y\n\n(array([[[  3.,   4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.,  12.],\n         [ 30.,  40.,  50.,  60.,  70.,  80.,  90., 100., 110., 120.]]]),\n array([[nan, nan, nan, nan]]))\n\n\n\nsource\n\n\nSlidingWindowPanel\n\n SlidingWindowPanel (window_len:int, unique_id_cols:list,\n                     stride:Optional[int]=1, start:int=0,\n                     pad_remainder:bool=False, padding:str='post',\n                     padding_value:float=nan,\n                     add_padding_feature:bool=True,\n                     get_x:Union[NoneType,int,list]=None,\n                     get_y:Union[NoneType,int,list]=None,\n                     y_func:Optional[&lt;built-infunctioncallable&gt;]=None,\n                     output_processor:Optional[&lt;built-\n                     infunctioncallable&gt;]=None, copy:bool=False,\n                     horizon:Union[int,list]=1, seq_first:bool=True,\n                     sort_by:Optional[list]=None, ascending:bool=True,\n                     check_leakage:bool=True, return_key:bool=False,\n                     verbose:bool=True)\n\n*Applies a sliding window to a pd.DataFrame.\nArgs: window_len = length of lookback window unique_id_cols = pd.DataFrame columns that will be used to identify a time series for each entity. stride = n datapoints the window is moved ahead along the sequence. Default: 1. If None, stride=window_len (no overlap) start = determines the step where the first window is applied: 0 (default), a given step (int), or random within the 1st stride (None). pad_remainder = allows to pad remainder subsequences when the sliding window is applied and get_y == [] (unlabeled data). padding = ‘pre’ or ‘post’ (optional, defaults to ‘pre’): pad either before or after each sequence. If pad_remainder == False, it indicates the starting point to create the sequence (‘pre’ from the end, and ‘post’ from the beginning) padding_value = value (float) that will be used for padding. Default: np.nan add_padding_feature = add an additional feature indicating whether each timestep is padded (1) or not (0). horizon = number of future datapoints to predict (y). If get_y is [] horizon will be set to 0. * 0 for last step in each sub-window. * n &gt; 0 for a range of n future steps (1 to n). * n &lt; 0 for a range of n past steps (-n + 1 to 0). * list : for those exact timesteps. get_x = indices of columns that contain the independent variable (xs). If None, all data will be used as x. get_y = indices of columns that contain the target (ys). If None, all data will be used as y. [] means no y data is created (unlabeled data). y_func = function to calculate the ys based on the get_y col/s and each y sub-window. y_func must be a function applied to axis=1! output_processor = optional function to filter output (X (and y if available)). This is useful when some values need to be removed. The function should take X and y (even if it’s None) as arguments. copy = copy the original object to avoid changes in it. seq_first = True if input shape (seq_len, n_vars), False if input shape (n_vars, seq_len) sort_by = column/s used for sorting the array in ascending order ascending = used in sorting check_leakage = checks if there’s leakage in the output between X and y return_key = when True, the key corresponsing to unique_id_cols for each sample is returned verbose = controls verbosity. True or 1 displays progress bar. 2 or more show records that cannot be created due to its length.\nInput: You can use np.ndarray, pd.DataFrame or torch.Tensor as input shape: (seq_len, ) or (seq_len, n_vars) if seq_first=True else (n_vars, seq_len)*\n\nsamples = 100_000\nwl = 5\nn_vars = 10\n\nt = (torch.stack(n_vars * [torch.arange(samples)]).T * tensor([10**i for i in range(n_vars)]))\ndf = pd.DataFrame(t, columns=[f'var_{i}' for i in range(n_vars)])\ndf['time'] = np.arange(len(t))\ndf['device'] = 0\ndf['target'] = np.random.randint(0, 2, len(df))\ndf2 = df.copy()\ndf3 = df.copy()\ncols = ['var_0', 'var_1', 'var_2', 'device', 'target']\ndf2[cols] = df2[cols] + 1\ndf3[cols] = df3[cols] + 2\ndf2 = df2.loc[:3]\ndf['region'] = 'A'\ndf2['region'] = 'A'\ndf3['region'] = 'B'\ndf = pd.concat([df, df2, df3], ignore_index=True)\ndf['index'] = np.arange(len(df))\ndf = df.sample(frac=1).reset_index(drop=True)\ndisplay(df.head())\ndf.shape\n\n\n\n\n\n\n\n\nvar_0\nvar_1\nvar_2\nvar_3\nvar_4\nvar_5\nvar_6\nvar_7\nvar_8\nvar_9\ntime\ndevice\ntarget\nregion\nindex\n\n\n\n\n0\n86008\n860080\n8600800\n86008000\n860080000\n8600800000\n86008000000\n860080000000\n8600800000000\n86008000000000\n86008\n0\n0\nA\n86008\n\n\n1\n90003\n900012\n9000102\n90001000\n900010000\n9000100000\n90001000000\n900010000000\n9000100000000\n90001000000000\n90001\n2\n2\nB\n190005\n\n\n2\n43819\n438172\n4381702\n43817000\n438170000\n4381700000\n43817000000\n438170000000\n4381700000000\n43817000000000\n43817\n2\n3\nB\n143821\n\n\n3\n80751\n807492\n8074902\n80749000\n807490000\n8074900000\n80749000000\n807490000000\n8074900000000\n80749000000000\n80749\n2\n3\nB\n180753\n\n\n4\n84917\n849152\n8491502\n84915000\n849150000\n8491500000\n84915000000\n849150000000\n8491500000000\n84915000000000\n84915\n2\n3\nB\n184919\n\n\n\n\n\n\n\n(200004, 15)\n\n\n\nX, y = SlidingWindowPanel(window_len=5, unique_id_cols=['device'], stride=1, start=0, get_x=df.columns[:n_vars], get_y=['target'], \n                          horizon=0, seq_first=True, sort_by=['time'], ascending=True, return_key=False)(df)\nX.shape, y.shape\n\nprocessing data...\n\n\n\n\n\n\n\n\n\n...data processed\nconcatenating X...\n...X concatenated\nconcatenating y...\n...y concatenated\n\n\n((199992, 10, 5), (199992,))\n\n\n\nX, y, key = SlidingWindowPanel(window_len=5, unique_id_cols=['device'], stride=1, start=0, get_x=df.columns[:n_vars], get_y=['target'], \n                               horizon=0, seq_first=True, sort_by=['time'], ascending=True, return_key=True)(df)\nX.shape, y.shape, key.shape\n\nprocessing data...\n\n\n\n\n\n\n\n\n\n...data processed\nconcatenating X...\n...X concatenated\nconcatenating y...\n...y concatenated\n\n\n((199992, 10, 5), (199992,), (199992,))\n\n\n\nX, y = SlidingWindowPanel(window_len=5, unique_id_cols=['device', 'region'], stride=1, start=0, get_x=df.columns[:n_vars], get_y=['target'], \n                          horizon=0, seq_first=True, sort_by=['time'], ascending=True)(df)\nX.shape, y.shape\n\nprocessing data...\n\n\n\n\n\n\n\n\n\n...data processed\nconcatenating X...\n...X concatenated\nconcatenating y...\n...y concatenated\n\n\n((199992, 10, 5), (199992,))\n\n\n\n# y_func must be a function applied to axis=1!\ndef y_max(o): return np.max(o, axis=1)\n\n\nX, y = SlidingWindowPanel(window_len=5, unique_id_cols=['device', 'region'], stride=1, start=0, get_x=df.columns[:n_vars], get_y=['target'], \n                          y_func=y_max, horizon=5, seq_first=True, sort_by=['time'], ascending=True)(df)\nX.shape, y.shape\n\nprocessing data...\n\n\n\n\n\n\n\n    \n      \n      0.00% [0/3 00:00&lt;?]\n    \n    \n\n\n...data processed\nconcatenating X...\n...X concatenated\nconcatenating y...\n...y concatenated\n\n\n((199982, 10, 5), (199982,))\n\n\n\nsource\n\n\nidentify_padding\n\n identify_padding (float_mask, value=-1)\n\n*Identifies padded subsequences in a mask of type float\nThis function identifies as padded subsequences those where all values == nan from the end of the sequence (last dimension) across all channels, and sets those values to the selected value (default = -1)\nArgs: mask: boolean or float mask value: scalar that will be used to identify padded subsequences*\n\nwl = 5\nstride = 5\n\nt = np.repeat(np.arange(13).reshape(-1,1), 3, axis=-1)\nprint('input shape:', t.shape)\nX, _ = SlidingWindow(wl, stride=stride, pad_remainder=True, get_y=[])(t)\nX = tensor(X)\nX[0, 1, -2:] = np.nan\nX[1,..., :3] = np.nan\nprint(X)\nidentify_padding(torch.isnan(X).float())\n\ninput shape: (13, 3)\ntensor([[[ 0.,  1.,  2.,  3.,  4.],\n         [ 0.,  1.,  2., nan, nan],\n         [ 0.,  1.,  2.,  3.,  4.],\n         [ 0.,  0.,  0.,  0.,  0.]],\n\n        [[nan, nan, nan,  8.,  9.],\n         [nan, nan, nan,  8.,  9.],\n         [nan, nan, nan,  8.,  9.],\n         [nan, nan, nan,  0.,  0.]],\n\n        [[10., 11., 12., nan, nan],\n         [10., 11., 12., nan, nan],\n         [10., 11., 12., nan, nan],\n         [ 0.,  0.,  0.,  1.,  1.]]])\n\n\ntensor([[[0., 0., 0., 0., 0.],\n         [0., 0., 0., 1., 1.],\n         [0., 0., 0., 0., 0.],\n         [0., 0., 0., 0., 0.]],\n\n        [[1., 1., 1., 0., 0.],\n         [1., 1., 1., 0., 0.],\n         [1., 1., 1., 0., 0.],\n         [1., 1., 1., 0., 0.]],\n\n        [[0., 0., 0., 1., 1.],\n         [0., 0., 0., 1., 1.],\n         [0., 0., 0., 1., 1.],\n         [0., 0., 0., 0., 0.]]])\n\n\n\n\nForecasting data preparation\n\nsource\n\nbasic_data_preparation_fn\n\n basic_data_preparation_fn (df, drop_duplicates=True, datetime_col=None,\n                            use_index=False, keep='last',\n                            add_missing_datetimes=True, freq='1D',\n                            method=None, sort_by=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe to preprocess\n\n\ndrop_duplicates\nbool\nTrue\nflag to indicate if rows with duplicate datetime info should be removed\n\n\ndatetime_col\nNoneType\nNone\nstr indicating the name of the column/s that contains the datetime info\n\n\nuse_index\nbool\nFalse\nflag to indicate if the datetime info is in the index\n\n\nkeep\nstr\nlast\nstr to indicate what data should be kept in case of duplicate rows\n\n\nadd_missing_datetimes\nbool\nTrue\nflaf to indicate if missing datetimes should be added\n\n\nfreq\nstr\n1D\nstr to indicate the frequency used in the datetime info. Used in case missing timestamps exists\n\n\nmethod\nNoneType\nNone\nstr indicating the method used to fill data for missing timestamps: None, ‘bfill’, ‘ffill’\n\n\nsort_by\nNoneType\nNone\nstr or list of str to indicate if how to sort data. If use_index=True the index will be used to sort the dataframe.\n\n\n\n\ndf_len = 100\ndatetime_col = 'datetime' \ndf = pd.DataFrame(np.arange(df_len), columns=['value'])\ndf['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df_len, freq='1D')\ndf['type'] = 1\n# drop 10 rows at random\ndf = df.drop(df.sample(10).index)\n# add 2 duplicated rows\ndf = pd.concat([df, df.sample(2)])\ndisplay(df)\n\nnew_df = basic_data_preparation_fn(df, drop_duplicates=True, datetime_col=datetime_col, use_index=False, keep='last', \n                                   add_missing_datetimes=True, freq='1D', method='ffill', sort_by=datetime_col)\ndisplay(new_df)\n\n\n\n\n\n\n\n\nvalue\ndatetime\ntype\n\n\n\n\n0\n0\n1749-03-31\n1\n\n\n1\n1\n1749-04-01\n1\n\n\n3\n3\n1749-04-03\n1\n\n\n4\n4\n1749-04-04\n1\n\n\n5\n5\n1749-04-05\n1\n\n\n...\n...\n...\n...\n\n\n96\n96\n1749-07-05\n1\n\n\n97\n97\n1749-07-06\n1\n\n\n99\n99\n1749-07-08\n1\n\n\n0\n0\n1749-03-31\n1\n\n\n19\n19\n1749-04-19\n1\n\n\n\n\n92 rows × 3 columns\n\n\n\n\n\n\n\n\n\n\nvalue\ndatetime\ntype\n\n\n\n\n0\n0\n1749-03-31\n1\n\n\n1\n1\n1749-04-01\n1\n\n\n2\n1\n1749-04-02\n1\n\n\n3\n3\n1749-04-03\n1\n\n\n4\n4\n1749-04-04\n1\n\n\n...\n...\n...\n...\n\n\n95\n95\n1749-07-04\n1\n\n\n96\n96\n1749-07-05\n1\n\n\n97\n97\n1749-07-06\n1\n\n\n98\n97\n1749-07-07\n1\n\n\n99\n99\n1749-07-08\n1\n\n\n\n\n100 rows × 3 columns\n\n\n\n\nsource\n\n\ncheck_safe_conversion\n\n check_safe_conversion (o, dtype='float32', cols=None)\n\nChecks if the conversion to float is safe\n\nassert check_safe_conversion(-2**11, 'float16') == True\nassert check_safe_conversion(-2**11 - 1, 'float16') == False\nassert check_safe_conversion(2**24, 'float32') == True\nassert check_safe_conversion(2**24+1, 'float32') == False\nassert check_safe_conversion(2**53, 'float64') == True\nassert check_safe_conversion(2**53+1, 'float64') == False\n\ndf = pd.DataFrame({'a': [1, 2, 3], 'b': [2**24, 2**24+1, 2**24+2]})\nassert not check_safe_conversion(df, 'float32')\nassert check_safe_conversion(df, 'int32')\nassert check_safe_conversion(df, 'float32', cols='a')\nassert not check_safe_conversion(df, 'float32', cols='b')\n\n-2147483648 1 3 2147483647\n-2147483648 16777216 16777218 2147483647\n\n\n/var/folders/42/4hhwknbd5kzcbq48tmy_gbp00000gn/T/ipykernel_30986/657350933.py:39: UserWarning: Unsafe conversion to float32: {'a': True, 'b': False}\n  warnings.warn(f\"Unsafe conversion to {dtype}: {dict(zip(cols, checks))}\")\n/var/folders/42/4hhwknbd5kzcbq48tmy_gbp00000gn/T/ipykernel_30986/657350933.py:39: UserWarning: Unsafe conversion to float32: {'b': False}\n  warnings.warn(f\"Unsafe conversion to {dtype}: {dict(zip(cols, checks))}\")\n\n\n\nsource\n\n\nprepare_forecasting_data\n\nfrom tsai.data.validation import get_forecasting_splits\n\n\nfcst_history = 10 \nfcst_horizon = 5\nstride = 1\nvalid_size=0.2\ntest_size=0.2\n\ndf = pd.DataFrame()\ndf['target'] = np.arange(50)\n\nX, y = prepare_forecasting_data(df, fcst_history, fcst_horizon)\nsplits = get_forecasting_splits(df, fcst_history, fcst_horizon, valid_size=valid_size, test_size=test_size, stride=stride, show_plot=False)\nassert y[splits[0]][-1][0][-1] == y[splits[1]][0][0][0] - stride\nassert y[splits[1]][-1][0][-1] == y[splits[2]][0][0][0] - stride\nfor s,t in zip(splits, ['\\ntrain_split:', '\\nvalid_split:', '\\ntest_split :']):\n    print(t)\n    for xi, yi in zip(X[s], y[s]):\n        print(xi, yi)\n\n\ntrain_split:\n[[0 1 2 3 4 5 6 7 8 9]] [[10 11 12 13 14]]\n[[ 1  2  3  4  5  6  7  8  9 10]] [[11 12 13 14 15]]\n[[ 2  3  4  5  6  7  8  9 10 11]] [[12 13 14 15 16]]\n[[ 3  4  5  6  7  8  9 10 11 12]] [[13 14 15 16 17]]\n[[ 4  5  6  7  8  9 10 11 12 13]] [[14 15 16 17 18]]\n[[ 5  6  7  8  9 10 11 12 13 14]] [[15 16 17 18 19]]\n[[ 6  7  8  9 10 11 12 13 14 15]] [[16 17 18 19 20]]\n[[ 7  8  9 10 11 12 13 14 15 16]] [[17 18 19 20 21]]\n[[ 8  9 10 11 12 13 14 15 16 17]] [[18 19 20 21 22]]\n[[ 9 10 11 12 13 14 15 16 17 18]] [[19 20 21 22 23]]\n[[10 11 12 13 14 15 16 17 18 19]] [[20 21 22 23 24]]\n[[11 12 13 14 15 16 17 18 19 20]] [[21 22 23 24 25]]\n[[12 13 14 15 16 17 18 19 20 21]] [[22 23 24 25 26]]\n[[13 14 15 16 17 18 19 20 21 22]] [[23 24 25 26 27]]\n[[14 15 16 17 18 19 20 21 22 23]] [[24 25 26 27 28]]\n[[15 16 17 18 19 20 21 22 23 24]] [[25 26 27 28 29]]\n\nvalid_split:\n[[20 21 22 23 24 25 26 27 28 29]] [[30 31 32 33 34]]\n[[21 22 23 24 25 26 27 28 29 30]] [[31 32 33 34 35]]\n[[22 23 24 25 26 27 28 29 30 31]] [[32 33 34 35 36]]\n[[23 24 25 26 27 28 29 30 31 32]] [[33 34 35 36 37]]\n[[24 25 26 27 28 29 30 31 32 33]] [[34 35 36 37 38]]\n[[25 26 27 28 29 30 31 32 33 34]] [[35 36 37 38 39]]\n\ntest_split :\n[[30 31 32 33 34 35 36 37 38 39]] [[40 41 42 43 44]]\n[[31 32 33 34 35 36 37 38 39 40]] [[41 42 43 44 45]]\n[[32 33 34 35 36 37 38 39 40 41]] [[42 43 44 45 46]]\n[[33 34 35 36 37 38 39 40 41 42]] [[43 44 45 46 47]]\n[[34 35 36 37 38 39 40 41 42 43]] [[44 45 46 47 48]]\n[[35 36 37 38 39 40 41 42 43 44]] [[45 46 47 48 49]]\n\n\n\nfcst_history = 10 \nfcst_horizon = 5\nstride = 1\nvalid_size=0.2\ntest_size=0.2\n\ndf = pd.DataFrame()\ndf['target'] = np.arange(50)\n\nX, y = prepare_forecasting_data(df, fcst_history, fcst_horizon, x_vars=None, y_vars=[])\nsplits = get_forecasting_splits(df, fcst_history, fcst_horizon, valid_size=valid_size, test_size=test_size, stride=stride, show_plot=False)\nassert y is None\n\n\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime' \ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**i).astype(np.float32)\ndisplay(df)\n\nfcst_history = 10\nfcst_horizon = 5\nx_vars = df.columns\ny_vars = None\ndtype = None\n\nX, y = prepare_forecasting_data(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, x_vars=x_vars, y_vars=y_vars, dtype=dtype)\ntest_eq(X.shape, (86, 3, 10))\ntest_eq(y.shape, (86, 3, 5))\ntest_eq(y[:3, :, 0],  X[:3, :, -1] + np.array([1, 10, 100]).reshape(1, 1, -1))\nprint(X[:3].astype(int))\nprint(y[:3].astype(int))\n\n\n\n\n\n\n\n\nvalue_0\nvalue_1\nvalue_2\n\n\n\n\n0\n0.0\n0.0\n0.0\n\n\n1\n1.0\n10.0\n100.0\n\n\n2\n2.0\n20.0\n200.0\n\n\n3\n3.0\n30.0\n300.0\n\n\n4\n4.0\n40.0\n400.0\n\n\n...\n...\n...\n...\n\n\n95\n95.0\n950.0\n9500.0\n\n\n96\n96.0\n960.0\n9600.0\n\n\n97\n97.0\n970.0\n9700.0\n\n\n98\n98.0\n980.0\n9800.0\n\n\n99\n99.0\n990.0\n9900.0\n\n\n\n\n100 rows × 3 columns\n\n\n\n[[[   0    1    2    3    4    5    6    7    8    9]\n  [   0   10   20   30   40   50   60   70   80   90]\n  [   0  100  200  300  400  500  600  700  800  900]]\n\n [[   1    2    3    4    5    6    7    8    9   10]\n  [  10   20   30   40   50   60   70   80   90  100]\n  [ 100  200  300  400  500  600  700  800  900 1000]]\n\n [[   2    3    4    5    6    7    8    9   10   11]\n  [  20   30   40   50   60   70   80   90  100  110]\n  [ 200  300  400  500  600  700  800  900 1000 1100]]]\n[[[  10   11   12   13   14]\n  [ 100  110  120  130  140]\n  [1000 1100 1200 1300 1400]]\n\n [[  11   12   13   14   15]\n  [ 110  120  130  140  150]\n  [1100 1200 1300 1400 1500]]\n\n [[  12   13   14   15   16]\n  [ 120  130  140  150  160]\n  [1200 1300 1400 1500 1600]]]\n\n\n\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime' \ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**(i + 1)).astype(np.float32)\n\ndf['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df_len, freq='1D')\ndf['type'] = np.random.randint(0, 4, df_len)\ndf['target'] = np.arange(df_len)\ndisplay(df)\n\nfcst_history = 10\nfcst_horizon = 5\nx_vars = ['value_0', 'value_1', 'value_2', 'target']\ny_vars = 'target'\ndtype = np.float32\n\nX, y = prepare_forecasting_data(df, fcst_history=fcst_history, fcst_horizon=fcst_horizon, x_vars=x_vars, y_vars=y_vars, dtype=dtype)\ntest_eq(X.shape, (86, 4, 10))\ntest_eq(y.shape, (86, 1, 5))\nprint(X[:3].astype(int))\nprint(y[:3])\n\n\n\n\n\n\n\n\nvalue_0\nvalue_1\nvalue_2\ndatetime\ntype\ntarget\n\n\n\n\n0\n0.0\n0.0\n0.0\n1749-03-31\n3\n0\n\n\n1\n10.0\n100.0\n1000.0\n1749-04-01\n1\n1\n\n\n2\n20.0\n200.0\n2000.0\n1749-04-02\n1\n2\n\n\n3\n30.0\n300.0\n3000.0\n1749-04-03\n1\n3\n\n\n4\n40.0\n400.0\n4000.0\n1749-04-04\n2\n4\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n95\n950.0\n9500.0\n95000.0\n1749-07-04\n0\n95\n\n\n96\n960.0\n9600.0\n96000.0\n1749-07-05\n0\n96\n\n\n97\n970.0\n9700.0\n97000.0\n1749-07-06\n3\n97\n\n\n98\n980.0\n9800.0\n98000.0\n1749-07-07\n2\n98\n\n\n99\n990.0\n9900.0\n99000.0\n1749-07-08\n1\n99\n\n\n\n\n100 rows × 6 columns\n\n\n\n[[[    0    10    20    30    40    50    60    70    80    90]\n  [    0   100   200   300   400   500   600   700   800   900]\n  [    0  1000  2000  3000  4000  5000  6000  7000  8000  9000]\n  [    0     1     2     3     4     5     6     7     8     9]]\n\n [[   10    20    30    40    50    60    70    80    90   100]\n  [  100   200   300   400   500   600   700   800   900  1000]\n  [ 1000  2000  3000  4000  5000  6000  7000  8000  9000 10000]\n  [    1     2     3     4     5     6     7     8     9    10]]\n\n [[   20    30    40    50    60    70    80    90   100   110]\n  [  200   300   400   500   600   700   800   900  1000  1100]\n  [ 2000  3000  4000  5000  6000  7000  8000  9000 10000 11000]\n  [    2     3     4     5     6     7     8     9    10    11]]]\n[[[10. 11. 12. 13. 14.]]\n\n [[11. 12. 13. 14. 15.]]\n\n [[12. 13. 14. 15. 16.]]]\n\n\n\nsource\n\n\nget_today\n\n get_today (datetime_format='%Y-%m-%d')\n\n\ntest_eq(get_today(), dt.datetime.today().strftime(\"%Y-%m-%d\"))\n\n\nsource\n\n\nsplit_fcst_datetime\n\n split_fcst_datetime (fcst_datetime)\n\nDefine fcst start and end dates\n\n\n\n\nDetails\n\n\n\n\nfcst_datetime\nstr or list of str with datetime\n\n\n\n\ntest_eq(split_fcst_datetime(None), (None, None))\ntest_eq(split_fcst_datetime('2020-01-01'), ('2020-01-01', '2020-01-01'))\ntest_eq(split_fcst_datetime(['2019-01-01', '2020-01-01']), ['2019-01-01', '2020-01-01'])\n\n\nsource\n\n\nset_df_datetime\n\n set_df_datetime (df, datetime_col=None, use_index=False)\n\nMake sure datetime column or index is of the right date type.\n\n# Test\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime'\ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**(i + 1)).astype(np.float32)\ndf['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df_len, freq='1D')\nset_df_datetime(df, datetime_col=datetime_col)\ntest_eq(df['datetime'].dtypes, np.dtype('datetime64[ns]'))\ndf_index = df.set_index('datetime')\nset_df_datetime(df_index, use_index=True)\ntest_eq(df_index.index.dtype, np.dtype('datetime64[ns]'))\n\n\nsource\n\n\nget_df_datetime_bounds\n\n get_df_datetime_bounds (df, datetime_col=None, use_index=False)\n\nReturns the start date and and dates used by the forecast\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing forecasting data\n\n\ndatetime_col\nNoneType\nNone\nstr data column containing the datetime\n\n\nuse_index\nbool\nFalse\nbool flag to indicate if index should be used to get column\n\n\n\n\n# Test\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime'\ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**(i + 1)).astype(np.float32)\ndf['datetime'] = pd.date_range(pd.to_datetime('1749-03-31'), periods=df_len, freq='1D')\ntest_eq(get_df_datetime_bounds(df, datetime_col=datetime_col), (df['datetime'].min(), df['datetime'].max()))\ndf_index = df.set_index('datetime')\ntest_eq(get_df_datetime_bounds(df_index, use_index=True), (df_index.index.min(), df_index.index.max()))\n\n\nsource\n\n\nget_fcst_bounds\n\n get_fcst_bounds (df, fcst_datetime, fcst_history=None, fcst_horizon=None,\n                  freq='D', datetime_format='%Y-%m-%d', datetime_col=None,\n                  use_index=False)\n\nReturns the start and end datetimes used by the forecast\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing forecasting data\n\n\nfcst_datetime\n\n\ndatetime for which a fcst is created. Optionally tuple of datatimes if the fcst is created for a range of dates.\n\n\nfcst_history\nNoneType\nNone\n# steps used as input\n\n\nfcst_horizon\nNoneType\nNone\n# predicted steps\n\n\nfreq\nstr\nD\ndatetime units. May contain a letters only or a combination of ints + letters: eg. “7D”\n\n\ndatetime_format\nstr\n%Y-%m-%d\nformat used to convert “today”\n\n\ndatetime_col\nNoneType\nNone\nstr data column containing the datetime\n\n\nuse_index\nbool\nFalse\nbool flag to indicate if index should be used to get column\n\n\n\n\nfrom datetime import timedelta\n\n\n# Test\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime'\ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**(i + 1)).astype(np.float32)\nfreq = \"7D\"\ntoday = pd.Timestamp(get_today()).floor(freq)\ndf['datetime'] = pd.date_range(None, today, periods=df_len, freq=freq)\ndisplay(df)\nmax_dt = pd.Timestamp(df['datetime'].max()).floor(freq)\nfcst_history = 30\nfcst_horizon = 10\nfcst_datetime = max_dt - timedelta(weeks=fcst_horizon)\nprint('fcst_datetime :', fcst_datetime)\nstart_datetime, end_datetime = get_fcst_bounds(df, fcst_datetime, datetime_col=datetime_col, fcst_history=fcst_history, fcst_horizon=fcst_horizon, freq=freq)\nprint('start_datetime:', start_datetime)\nprint('end_datetime  :', end_datetime)\ndates = pd.date_range(start_datetime, end_datetime, freq=freq)\nprint(dates)\ntest_eq(len(dates), fcst_history + fcst_horizon)\ntest_eq(end_datetime, max_dt)\n\n\n\n\n\n\n\n\nvalue_0\nvalue_1\nvalue_2\ndatetime\n\n\n\n\n0\n0.0\n0.0\n0.0\n2021-11-25\n\n\n1\n10.0\n100.0\n1000.0\n2021-12-02\n\n\n2\n20.0\n200.0\n2000.0\n2021-12-09\n\n\n3\n30.0\n300.0\n3000.0\n2021-12-16\n\n\n4\n40.0\n400.0\n4000.0\n2021-12-23\n\n\n...\n...\n...\n...\n...\n\n\n95\n950.0\n9500.0\n95000.0\n2023-09-21\n\n\n96\n960.0\n9600.0\n96000.0\n2023-09-28\n\n\n97\n970.0\n9700.0\n97000.0\n2023-10-05\n\n\n98\n980.0\n9800.0\n98000.0\n2023-10-12\n\n\n99\n990.0\n9900.0\n99000.0\n2023-10-19\n\n\n\n\n100 rows × 4 columns\n\n\n\nfcst_datetime : 2023-08-10 00:00:00\nstart_datetime: 2023-01-19 00:00:00\nend_datetime  : 2023-10-19 00:00:00\nDatetimeIndex(['2023-01-19', '2023-01-26', '2023-02-02', '2023-02-09',\n               '2023-02-16', '2023-02-23', '2023-03-02', '2023-03-09',\n               '2023-03-16', '2023-03-23', '2023-03-30', '2023-04-06',\n               '2023-04-13', '2023-04-20', '2023-04-27', '2023-05-04',\n               '2023-05-11', '2023-05-18', '2023-05-25', '2023-06-01',\n               '2023-06-08', '2023-06-15', '2023-06-22', '2023-06-29',\n               '2023-07-06', '2023-07-13', '2023-07-20', '2023-07-27',\n               '2023-08-03', '2023-08-10', '2023-08-17', '2023-08-24',\n               '2023-08-31', '2023-09-07', '2023-09-14', '2023-09-21',\n               '2023-09-28', '2023-10-05', '2023-10-12', '2023-10-19'],\n              dtype='datetime64[ns]', freq='7D')\n\n\n\nsource\n\n\nfilter_df_by_datetime\n\n filter_df_by_datetime (df, start_datetime=None, end_datetime=None,\n                        datetime_col=None, use_index=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing forecasting data\n\n\nstart_datetime\nNoneType\nNone\nlower datetime bound\n\n\nend_datetime\nNoneType\nNone\nupper datetime bound\n\n\ndatetime_col\nNoneType\nNone\nstr data column containing the datetime\n\n\nuse_index\nbool\nFalse\nbool flag to indicate if index should be used to get column\n\n\n\n\n# Test\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime'\ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**(i + 1)).astype(np.float32)\nfreq = \"7D\"\ndf['datetime'] = pd.date_range(None, pd.Timestamp(get_today()).floor(freq), periods=df_len, freq=freq)\ndisplay(df)\nmax_dt = pd.Timestamp(df['datetime'].max()).floor(freq)\nfcst_history = 30\nfcst_horizon = 10\nfcst_datetime = pd.date_range(end=fcst_datetime, periods=fcst_horizon + 1, freq=freq).floor(freq)[-1]\nstart_datetime, end_datetime = get_fcst_bounds(df, fcst_datetime, datetime_col=datetime_col, fcst_history=fcst_history, fcst_horizon=fcst_horizon, freq=freq)\ntest_eq(len(filter_df_by_datetime(df, start_datetime=start_datetime, end_datetime=end_datetime, datetime_col=datetime_col)), fcst_history + fcst_horizon)\n\n\n\n\n\n\n\n\nvalue_0\nvalue_1\nvalue_2\ndatetime\n\n\n\n\n0\n0.0\n0.0\n0.0\n2021-11-25\n\n\n1\n10.0\n100.0\n1000.0\n2021-12-02\n\n\n2\n20.0\n200.0\n2000.0\n2021-12-09\n\n\n3\n30.0\n300.0\n3000.0\n2021-12-16\n\n\n4\n40.0\n400.0\n4000.0\n2021-12-23\n\n\n...\n...\n...\n...\n...\n\n\n95\n950.0\n9500.0\n95000.0\n2023-09-21\n\n\n96\n960.0\n9600.0\n96000.0\n2023-09-28\n\n\n97\n970.0\n9700.0\n97000.0\n2023-10-05\n\n\n98\n980.0\n9800.0\n98000.0\n2023-10-12\n\n\n99\n990.0\n9900.0\n99000.0\n2023-10-19\n\n\n\n\n100 rows × 4 columns\n\n\n\n\nsource\n\n\nget_fcst_data_from_df\n\n get_fcst_data_from_df (df, fcst_datetime, fcst_history=None,\n                        fcst_horizon=None, freq='D',\n                        datetime_format='%Y-%m-%d', datetime_col=None,\n                        use_index=False)\n\nGet forecasting data from a dataframe\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndf\n\n\ndataframe containing forecasting data\n\n\nfcst_datetime\n\n\ndatetime for which a fcst is created. Optionally tuple of datatimes if the fcst is created for a range of dates.\n\n\nfcst_history\nNoneType\nNone\n# steps used as input\n\n\nfcst_horizon\nNoneType\nNone\n# predicted steps\n\n\nfreq\nstr\nD\ndatetime units. May contain a letters only or a combination of ints + letters: eg. “7D”\n\n\ndatetime_format\nstr\n%Y-%m-%d\nformat used to convert “today”\n\n\ndatetime_col\nNoneType\nNone\nstr data column containing the datetime\n\n\nuse_index\nbool\nFalse\nbool flag to indicate if index should be used to get column\n\n\n\n\n# Test\ndf_len = 100\nn_values = 3\ndatetime_col = 'datetime'\ndf = pd.DataFrame()\nfor i in range(n_values):\n    df[f\"value_{i}\"] = (np.arange(df_len) * 10**(i + 1)).astype(np.float32)\nfreq = \"7D\"\ndf['datetime'] = pd.date_range(None, pd.Timestamp(get_today()).floor(freq), periods=df_len, freq=freq)\ndisplay(df)\nmax_dt = pd.Timestamp(df['datetime'].max()).floor(freq)\nfcst_history = 30\nfcst_horizon = 10\nfcst_datetime = pd.date_range(end=fcst_datetime, periods=fcst_horizon + 1, freq=freq).floor(freq)[-1]\ntest_eq(len(get_fcst_data_from_df(df, fcst_datetime, fcst_history=fcst_history, fcst_horizon=fcst_horizon, freq=freq, datetime_col=datetime_col)), \n                                  fcst_history + fcst_horizon)\n\n\n\n\n\n\n\n\nvalue_0\nvalue_1\nvalue_2\ndatetime\n\n\n\n\n0\n0.0\n0.0\n0.0\n2021-11-25\n\n\n1\n10.0\n100.0\n1000.0\n2021-12-02\n\n\n2\n20.0\n200.0\n2000.0\n2021-12-09\n\n\n3\n30.0\n300.0\n3000.0\n2021-12-16\n\n\n4\n40.0\n400.0\n4000.0\n2021-12-23\n\n\n...\n...\n...\n...\n...\n\n\n95\n950.0\n9500.0\n95000.0\n2023-09-21\n\n\n96\n960.0\n9600.0\n96000.0\n2023-09-28\n\n\n97\n970.0\n9700.0\n97000.0\n2023-10-05\n\n\n98\n980.0\n9800.0\n98000.0\n2023-10-12\n\n\n99\n990.0\n9900.0\n99000.0\n2023-10-19\n\n\n\n\n100 rows × 4 columns",
    "crumbs": [
      "Data",
      "Data preparation"
    ]
  },
  {
    "objectID": "models.tabfusiontransformer.html",
    "href": "models.tabfusiontransformer.html",
    "title": "TabFusionTransformer",
    "section": "",
    "text": "This is a a Pytorch implementeation of TabTransformerTransformer created by Ignacio Oguiza (oguiza@timeseriesAI.co)\nThis implementation is inspired by:\nHuang, X., Khetan, A., Cvitkovic, M., & Karnin, Z. (2020). TabTransformer: Tabular Data Modeling Using Contextual Embeddings. arXiv preprint https://arxiv.org/pdf/2012.06678\nOfficial repo: https://github.com/awslabs/autogluon/tree/master/tabular/src/autogluon/tabular/models/tab_transformer\n\nsource\n\nTabFusionTransformer\n\n TabFusionTransformer (classes, cont_names, c_out, d_model=32, n_layers=6,\n                       n_heads=8, d_k=None, d_v=None, d_ff=None,\n                       res_attention=True, attention_act='gelu',\n                       res_dropout=0.0, fc_mults=(4, 2), fc_dropout=0.0,\n                       fc_act=None, fc_skip=False, fc_bn=False,\n                       bn_final=False, init=True)\n\nClass that allows you to pass one or multiple inputs\n\nsource\n\n\nTabFusionBackbone\n\n TabFusionBackbone (classes, cont_names, d_model=32, n_layers=6,\n                    n_heads=8, d_k=None, d_v=None, d_ff=None, init=True,\n                    res_attention=True, attention_act='gelu',\n                    res_dropout=0.0)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nSequential\n\n Sequential (*args)\n\nClass that allows you to pass one or multiple inputs\n\nsource\n\n\nifnone\n\n ifnone (a, b)\n\nb if a is None else a\n\nfrom fastai.tabular.all import *\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\ndls = TabularDataLoaders.from_csv(path/'adult.csv', path=path, y_names=\"salary\",\n    cat_names = ['workclass', 'education', 'marital-status', 'occupation', 'relationship', 'race'],\n    cont_names = ['age', 'fnlwgt', 'education-num'],\n    procs = [Categorify, FillMissing, Normalize])\nx_cat, x_cont, yb = first(dls.train)\nmodel = TabFusionTransformer(dls.classes, dls.cont_names, dls.c)\ntest_eq(model(x_cat, x_cont).shape, (dls.train.bs, dls.c))\n\n\nsource\n\n\nTSTabFusionTransformer\n\n TSTabFusionTransformer (c_in, c_out, seq_len, classes, cont_names,\n                         d_model=32, n_layers=6, n_heads=8, d_k=None,\n                         d_v=None, d_ff=None, res_attention=True,\n                         attention_act='gelu', res_dropout=0.0,\n                         fc_mults=(1, 0.5), fc_dropout=0.0, fc_act=None,\n                         fc_skip=False, fc_bn=False, bn_final=False,\n                         init=True)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nclasses = {'education': ['#na#', '10th', '11th', '12th', '1st-4th', '5th-6th', '7th-8th', '9th', 'Assoc-acdm', 'Assoc-voc', 'Bachelors', 'Doctorate', \n                         'HS-grad', 'Masters', 'Preschool', 'Prof-school', 'Some-college'],\n 'education-num_na': ['#na#', False, True],\n 'marital-status': ['#na#', 'Divorced', 'Married-AF-spouse', 'Married-civ-spouse', 'Married-spouse-absent', 'Never-married', 'Separated', 'Widowed'],\n 'occupation': ['#na#', '?', 'Adm-clerical', 'Armed-Forces', 'Craft-repair', 'Exec-managerial', 'Farming-fishing', 'Handlers-cleaners', 'Machine-op-inspct', \n                'Other-service', 'Priv-house-serv', 'Prof-specialty', 'Protective-serv', 'Sales', 'Tech-support', 'Transport-moving'],\n 'race': ['#na#', 'Amer-Indian-Eskimo', 'Asian-Pac-Islander', 'Black', 'Other', 'White'],\n 'relationship': ['#na#', 'Husband', 'Not-in-family', 'Other-relative', 'Own-child', 'Unmarried', 'Wife'],\n 'workclass': ['#na#', '?', 'Federal-gov', 'Local-gov', 'Never-worked', 'Private', 'Self-emp-inc', 'Self-emp-not-inc', 'State-gov', 'Without-pay']}\n\ncont_names = ['a', 'b', 'c']\nc_out = 6\nx_ts = torch.randn(64, 3, 10)\nx_cat = torch.randint(0,3,(64,7))\nx_cont = torch.randn(64,3)\nmodel = TSTabFusionTransformer(x_ts.shape[1], c_out, x_ts.shape[-1], classes, cont_names)\nx = (x_ts, (x_cat, x_cont))\ntest_eq(model(x).shape, (x_ts.shape[0], c_out))",
    "crumbs": [
      "Models",
      "Tabular models",
      "TabFusionTransformer"
    ]
  },
  {
    "objectID": "models.tst.html",
    "href": "models.tst.html",
    "title": "TST",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza of - oguiza@timeseriesAI.co based on: * George Zerveas et al. A Transformer-based Framework for Multivariate Time Series Representation Learning, in Proceedings of the 27th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD ’21), August 14–18, 2021. ArXiV version: https://arxiv.org/abs/2010.02803 * Official implementation: https://github.com/gzerveas/mvts_transformer\nThis paper uses ‘Attention is all you need’ as a major reference: * Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … & Polosukhin, I. (2017). Attention is all you need. In Advances in neural information processing systems (pp. 5998-6008).\nThis implementation is adapted to work with the rest of the tsai library, and contain some hyperparameters that are not available in the original implementation. They are included to experiment with them.",
    "crumbs": [
      "Models",
      "Transformers",
      "TST"
    ]
  },
  {
    "objectID": "models.tst.html#tst-arguments",
    "href": "models.tst.html#tst-arguments",
    "title": "TST",
    "section": "TST arguments",
    "text": "TST arguments\nUsual values are the ones that appear in the “Attention is all you need” and “A Transformer-based Framework for Multivariate Time Series Representation Learning” papers.\nThe default values are the ones selected as a default configuration in the latter.\n\nc_in: the number of features (aka variables, dimensions, channels) in the time series dataset. dls.var\nc_out: the number of target classes. dls.c\nseq_len: number of time steps in the time series. dls.len\nmax_seq_len: useful to control the temporal resolution in long time series to avoid memory issues. Default. None.\nd_model: total dimension of the model (number of features created by the model). Usual values: 128-1024. Default: 128.\nn_heads: parallel attention heads. Usual values: 8-16. Default: 16.\nd_k: size of the learned linear projection of queries and keys in the MHA. Usual values: 16-512. Default: None -&gt; (d_model/n_heads) = 32.\nd_v: size of the learned linear projection of values in the MHA. Usual values: 16-512. Default: None -&gt; (d_model/n_heads) = 32.\nd_ff: the dimension of the feedforward network model. Usual values: 256-4096. Default: 256.\ndropout: amount of residual dropout applied in the encoder. Usual values: 0.-0.3. Default: 0.1.\nactivation: the activation function of intermediate layer, relu or gelu. Default: ‘gelu’.\nn_layers: the number of sub-encoder-layers in the encoder. Usual values: 2-8. Default: 3.\nfc_dropout: dropout applied to the final fully connected layer. Usual values: 0.-0.8. Default: 0.\ny_range: range of possible y values (used in regression tasks). Default: None\nkwargs: nn.Conv1d kwargs. If not {}, a nn.Conv1d with those kwargs will be applied to original time series.",
    "crumbs": [
      "Models",
      "Transformers",
      "TST"
    ]
  },
  {
    "objectID": "models.tst.html#imports",
    "href": "models.tst.html#imports",
    "title": "TST",
    "section": "Imports",
    "text": "Imports",
    "crumbs": [
      "Models",
      "Transformers",
      "TST"
    ]
  },
  {
    "objectID": "models.tst.html#tst",
    "href": "models.tst.html#tst",
    "title": "TST",
    "section": "TST",
    "text": "TST\n\nt = torch.rand(16, 50, 128)\noutput, attn = _MultiHeadAttention(d_model=128, n_heads=3, d_k=8, d_v=6)(t, t, t)\noutput.shape, attn.shape\n\n(torch.Size([16, 50, 128]), torch.Size([16, 3, 50, 50]))\n\n\n\nt = torch.rand(16, 50, 128)\noutput = _TSTEncoderLayer(q_len=50, d_model=128, n_heads=3, d_k=None, d_v=None, d_ff=512, dropout=0.1, activation='gelu')(t)\noutput.shape\n\ntorch.Size([16, 50, 128])\n\n\n\nsource\n\nTST\n\n TST (c_in:int, c_out:int, seq_len:int, max_seq_len:Optional[int]=None,\n      n_layers:int=3, d_model:int=128, n_heads:int=16,\n      d_k:Optional[int]=None, d_v:Optional[int]=None, d_ff:int=256,\n      dropout:float=0.1, act:str='gelu', fc_dropout:float=0.0,\n      y_range:Optional[tuple]=None, verbose:bool=False, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 5000\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nmax_seq_len = 256\nd_model = 128\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\ndropout = 0.1\nactivation = \"gelu\"\nn_layers = 3\nfc_dropout = 0.1\nkwargs = {}\n\nmodel = TST(c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, dropout=dropout, activation=activation, n_layers=n_layers,\n            fc_dropout=fc_dropout, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 517378\n\n\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 60\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nmax_seq_len = 120\nd_model = 128\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\ndropout = 0.1\nact = \"gelu\"\nn_layers = 3\nfc_dropout = 0.1\nkwargs = {}\n# kwargs = dict(kernel_size=5, padding=2)\n\nmodel = TST(c_in, c_out, seq_len, max_seq_len=max_seq_len, d_model=d_model, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, dropout=dropout, act=act, n_layers=n_layers,\n            fc_dropout=fc_dropout, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 420226",
    "crumbs": [
      "Models",
      "Transformers",
      "TST"
    ]
  },
  {
    "objectID": "models.multimodal.html",
    "href": "models.multimodal.html",
    "title": "Multimodal",
    "section": "",
    "text": "Functionality used for multiple data modalities.\n\nA common scenario in time-series related tasks is the use of multiple types of inputs:\n\nstatic: data that doesn’t change with time\nobserved: temporal data only available in the past\nknown: temporal data available in the past and in the future\n\nAt the same time, these different modalities may contain:\n\ncategorical data\ncontinuous or numerical data\n\nBased on that, there are situations where we have up to 6 different types of input features:\n\ns_cat: static continuous variables\no_cat: observed categorical variables\no_cont: observed continuous variables\nk_cat: known categorical variables\nk_cont: known continuous variables\n\n\nsource\n\nget_feat_idxs\n\n get_feat_idxs (c_in, s_cat_idxs=None, s_cont_idxs=None, o_cat_idxs=None,\n                o_cont_idxs=None)\n\nCalculate the indices of the features used for training.\n\nsource\n\n\nget_o_cont_idxs\n\n get_o_cont_idxs (c_in, s_cat_idxs=None, s_cont_idxs=None,\n                  o_cat_idxs=None)\n\nCalculate the indices of the observed continuous features.\n\nc_in = 7\ns_cat_idxs = 3\ns_cont_idxs = [1, 4, 5]\no_cat_idxs = None\no_cont_idxs = None\n\ns_cat_idxs, s_cont_idxs, o_cat_idxs, o_cont_idxs = get_feat_idxs(c_in, s_cat_idxs=s_cat_idxs, s_cont_idxs=s_cont_idxs, o_cat_idxs=o_cat_idxs, o_cont_idxs=o_cont_idxs)\n\ntest_eq(s_cat_idxs, [3])\ntest_eq(s_cont_idxs, [1, 4, 5])\ntest_eq(o_cat_idxs, [])\ntest_eq(o_cont_idxs, [0, 2, 6])\n\n\nsource\n\n\nTensorSplitter\n\n TensorSplitter (s_cat_idxs:list=None, s_cont_idxs:list=None,\n                 o_cat_idxs:list=None, o_cont_idxs:list=None,\n                 k_cat_idxs:list=None, k_cont_idxs:list=None,\n                 horizon:int=None)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ns_cat_idxs\nlist\nNone\nlist of indices for static categorical variables\n\n\ns_cont_idxs\nlist\nNone\nlist of indices for static continuous variables\n\n\no_cat_idxs\nlist\nNone\nlist of indices for observed categorical variables\n\n\no_cont_idxs\nlist\nNone\nlist of indices for observed continuous variables\n\n\nk_cat_idxs\nlist\nNone\nlist of indices for known categorical variables\n\n\nk_cont_idxs\nlist\nNone\nlist of indices for known continuous variables\n\n\nhorizon\nint\nNone\nnumber of time steps to predict ahead\n\n\n\n\n# Example usage\nbs = 4\ns_cat_idxs = 1\ns_cont_idxs = [0, 2]\no_cat_idxs =[ 3, 4, 5]\no_cont_idxs = None\nk_cat_idxs = None\nk_cont_idxs = None\nhorizon=None\ninput_tensor = torch.randn(bs, 6, 10)  # 3D input tensor\nsplitter = TensorSplitter(s_cat_idxs=s_cat_idxs, s_cont_idxs=s_cont_idxs,\n                          o_cat_idxs=o_cat_idxs, o_cont_idxs=o_cont_idxs)\nslices = splitter(input_tensor)\nfor i, slice_tensor in enumerate(slices):\n    print(f\"Slice {i+1}: {slice_tensor.shape} {slice_tensor.dtype}\")\n\nSlice 1: torch.Size([4, 1]) torch.int64\nSlice 2: torch.Size([4, 2]) torch.int64\nSlice 3: torch.Size([4, 3, 10]) torch.float32\nSlice 4: torch.Size([4, 0, 10]) torch.float32\n\n\n\n# Example usage\nbs = 4\ns_cat_idxs = 1\ns_cont_idxs = [0, 2]\no_cat_idxs =[ 3, 4, 5]\no_cont_idxs = None\nk_cat_idxs = [6,7]\nk_cont_idxs = 8\nhorizon=3\ninput_tensor = torch.randn(4, 9, 10)  # 3D input tensor\nsplitter = TensorSplitter(s_cat_idxs=s_cat_idxs, s_cont_idxs=s_cont_idxs,\n                          o_cat_idxs=o_cat_idxs, o_cont_idxs=o_cont_idxs,\n                          k_cat_idxs=k_cat_idxs, k_cont_idxs=k_cont_idxs, horizon=horizon)\nslices = splitter(input_tensor)\nfor i, slice_tensor in enumerate(slices):\n    print(f\"Slice {i+1}: {slice_tensor.shape} {slice_tensor.dtype}\")\n\nSlice 1: torch.Size([4, 1]) torch.int64\nSlice 2: torch.Size([4, 2]) torch.int64\nSlice 3: torch.Size([4, 3, 7]) torch.float32\nSlice 4: torch.Size([4, 0, 7]) torch.float32\nSlice 5: torch.Size([4, 2, 10]) torch.float32\nSlice 6: torch.Size([4, 1, 10]) torch.float32\n\n\n\nsource\n\n\nEmbeddings\n\n Embeddings (n_embeddings:list, embedding_dims:list=None,\n             padding_idx:int=0, embed_dropout:float=0.0, **kwargs)\n\nEmbedding layers for each categorical variable in a 2D or 3D tensor\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nn_embeddings\nlist\n\nList of num_embeddings for each categorical variable\n\n\nembedding_dims\nlist\nNone\nList of embedding dimensions for each categorical variable\n\n\npadding_idx\nint\n0\nEmbedding padding_idx\n\n\nembed_dropout\nfloat\n0.0\nDropout probability for Embedding layer\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nt1 = torch.randint(0, 7, (16, 1))\nt2 = torch.randint(0, 5, (16, 1))\nt = torch.cat([t1, t2], 1).float()\nemb = Embeddings([7, 5], None, embed_dropout=0.1)\ntest_eq(emb(t).shape, (16, 12))\n\n\nt1 = torch.randint(0, 7, (16, 1))\nt2 = torch.randint(0, 5, (16, 1))\nt = torch.cat([t1, t2], 1).float()\nemb = Embeddings([7, 5], [4, 3])\ntest_eq(emb(t).shape, (16, 12))\n\n\nt1 = torch.randint(0, 7, (16, 1, 10))\nt2 = torch.randint(0, 5, (16, 1, 10))\nt = torch.cat([t1, t2], 1).float()\nemb = Embeddings([7, 5], None)\ntest_eq(emb(t).shape, (16, 12, 10))\n\n\nsource\n\n\nStaticBackbone\n\n StaticBackbone (c_in, c_out, seq_len, d=None, layers=[200, 100],\n                 dropouts=[0.1, 0.2], act=ReLU(inplace=True),\n                 use_bn=False, lin_first=False)\n\nStatic backbone model to embed static features\n\n# Example usage\nbs = 4\nc_in = 6\nc_out = 8\nseq_len = 10\ninput_tensor = torch.randn(bs, c_in, seq_len)  # 3D input tensor\nbackbone = StaticBackbone(c_in, c_out, seq_len)\noutput_tensor = backbone(input_tensor)\nprint(f\"Input shape: {input_tensor.shape} Output shape: {output_tensor.shape}\")\nbackbone\n\nInput shape: torch.Size([4, 6, 10]) Output shape: torch.Size([4, 100])\n\n\nStaticBackbone(\n  (flatten): Reshape(bs)\n  (mlp): ModuleList(\n    (0): LinBnDrop(\n      (0): Dropout(p=0.1, inplace=False)\n      (1): Linear(in_features=60, out_features=200, bias=True)\n      (2): ReLU(inplace=True)\n    )\n    (1): LinBnDrop(\n      (0): Dropout(p=0.2, inplace=False)\n      (1): Linear(in_features=200, out_features=100, bias=True)\n      (2): ReLU(inplace=True)\n    )\n  )\n)\n\n\n\nsource\n\n\nFusionMLP\n\n FusionMLP (comb_dim, layers, act='relu', dropout=0.0, use_bn=True)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nbs = 16\nemb_dim = 128\nseq_len = 20\ncat_dim = 24\ncont_feat = 3\n\ncomb_dim = emb_dim + cat_dim + cont_feat\nemb = torch.randn(bs, emb_dim, seq_len)\ncat = torch.randn(bs, cat_dim)\ncont = torch.randn(bs, cont_feat)\nfusion_mlp = FusionMLP(comb_dim, layers=comb_dim, act='relu', dropout=.1)\noutput = fusion_mlp(cat, cont, emb)\ntest_eq(output.shape, (bs, comb_dim))\n\n\nbs = 16\nemb_dim = 50000\ncat_dim = 24\ncont_feat = 3\n\ncomb_dim = emb_dim + cat_dim + cont_feat\nemb = torch.randn(bs, emb_dim)\ncat = torch.randn(bs, cat_dim)\ncont = torch.randn(bs, cont_feat)\nfusion_mlp = FusionMLP(comb_dim, layers=[128], act='relu', dropout=.1)\noutput = fusion_mlp(cat, cont, emb)\ntest_eq(output.shape, (bs, 128))\n\n\nsource\n\n\nMultInputBackboneWrapper\n\n MultInputBackboneWrapper (arch, c_in:int=None, seq_len:int=None,\n                           d:tuple=None,\n                           dls:tsai.data.core.TSDataLoaders=None,\n                           s_cat_idxs:list=None,\n                           s_cat_embeddings:list=None,\n                           s_cat_embedding_dims:list=None,\n                           s_cont_idxs:list=None, o_cat_idxs:list=None,\n                           o_cat_embeddings:list=None,\n                           o_cat_embedding_dims:list=None,\n                           o_cont_idxs:list=None, patch_len:int=None,\n                           patch_stride:int=None,\n                           fusion_layers:list=[128],\n                           fusion_act:str='relu',\n                           fusion_dropout:float=0.0,\n                           fusion_use_bn:bool=True, **kwargs)\n\nModel backbone wrapper for input tensors with static and/ or observed, categorical and/ or numerical features.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\narch\n\n\n\n\n\nc_in\nint\nNone\nnumber of input variables\n\n\nseq_len\nint\nNone\ninput sequence length\n\n\nd\ntuple\nNone\nshape of the output tensor\n\n\ndls\nTSDataLoaders\nNone\nTSDataLoaders object\n\n\ns_cat_idxs\nlist\nNone\nlist of indices for static categorical variables\n\n\ns_cat_embeddings\nlist\nNone\nlist of num_embeddings for each static categorical variable\n\n\ns_cat_embedding_dims\nlist\nNone\nlist of embedding dimensions for each static categorical variable\n\n\ns_cont_idxs\nlist\nNone\nlist of indices for static continuous variables\n\n\no_cat_idxs\nlist\nNone\nlist of indices for observed categorical variables\n\n\no_cat_embeddings\nlist\nNone\nlist of num_embeddings for each observed categorical variable\n\n\no_cat_embedding_dims\nlist\nNone\nlist of embedding dimensions for each observed categorical variable\n\n\no_cont_idxs\nlist\nNone\nlist of indices for observed continuous variables. All features not in s_cat_idxs, s_cont_idxs, o_cat_idxs are considered observed continuous variables.\n\n\npatch_len\nint\nNone\nNumber of time steps in each patch.\n\n\npatch_stride\nint\nNone\nStride of the patch.\n\n\nfusion_layers\nlist\n[128]\nlist of layer dimensions for the fusion MLP\n\n\nfusion_act\nstr\nrelu\nactivation function for the fusion MLP\n\n\nfusion_dropout\nfloat\n0.0\ndropout probability for the fusion MLP\n\n\nfusion_use_bn\nbool\nTrue\nboolean indicating whether to use batch normalization in the fusion MLP\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nsource\n\n\nMultInputWrapper\n\n MultInputWrapper (arch, c_in:int=None, c_out:int=1, seq_len:int=None,\n                   d:tuple=None, dls:tsai.data.core.TSDataLoaders=None,\n                   s_cat_idxs:list=None, s_cat_embeddings:list=None,\n                   s_cat_embedding_dims:list=None, s_cont_idxs:list=None,\n                   o_cat_idxs:list=None, o_cat_embeddings:list=None,\n                   o_cat_embedding_dims:list=None, o_cont_idxs:list=None,\n                   patch_len:int=None, patch_stride:int=None,\n                   fusion_layers:list=128, fusion_act:str='relu',\n                   fusion_dropout:float=0.0, fusion_use_bn:bool=True,\n                   custom_head=None, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\narch\n\n\n\n\n\nc_in\nint\nNone\nnumber of input variables\n\n\nc_out\nint\n1\nnumber of output variables\n\n\nseq_len\nint\nNone\ninput sequence length\n\n\nd\ntuple\nNone\nshape of the output tensor\n\n\ndls\nTSDataLoaders\nNone\nTSDataLoaders object\n\n\ns_cat_idxs\nlist\nNone\nlist of indices for static categorical variables\n\n\ns_cat_embeddings\nlist\nNone\nlist of num_embeddings for each static categorical variable\n\n\ns_cat_embedding_dims\nlist\nNone\nlist of embedding dimensions for each static categorical variable\n\n\ns_cont_idxs\nlist\nNone\nlist of indices for static continuous variables\n\n\no_cat_idxs\nlist\nNone\nlist of indices for observed categorical variables\n\n\no_cat_embeddings\nlist\nNone\nlist of num_embeddings for each observed categorical variable\n\n\no_cat_embedding_dims\nlist\nNone\nlist of embedding dimensions for each observed categorical variable\n\n\no_cont_idxs\nlist\nNone\nlist of indices for observed continuous variables. All features not in s_cat_idxs, s_cont_idxs, o_cat_idxs are considered observed continuous variables.\n\n\npatch_len\nint\nNone\nNumber of time steps in each patch.\n\n\npatch_stride\nint\nNone\nStride of the patch.\n\n\nfusion_layers\nlist\n128\nlist of layer dimensions for the fusion MLP\n\n\nfusion_act\nstr\nrelu\nactivation function for the fusion MLP\n\n\nfusion_dropout\nfloat\n0.0\ndropout probability for the fusion MLP\n\n\nfusion_use_bn\nbool\nTrue\nboolean indicating whether to use batch normalization in the fusion MLP\n\n\ncustom_head\nNoneType\nNone\ncustom head to replace the default head\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nfrom tsai.models.InceptionTimePlus import InceptionTimePlus\n\n\nbs = 8\nc_in = 6\nc_out = 3\nseq_len = 97\nd = None\n\ns_cat_idxs=2\ns_cont_idxs=4\no_cat_idxs=[0, 3]\no_cont_idxs=None\ns_cat_embeddings = 5\ns_cat_embedding_dims = None\no_cat_embeddings = [7, 3]\no_cat_embedding_dims = [3, None]\n\nfusion_layers = 128\n\nt0 = torch.randint(0, 7, (bs, 1, seq_len)) # cat\nt1 = torch.randn(bs, 1, seq_len)\nt2 = torch.randint(0, 5, (bs, 1, seq_len)) # cat\nt3 = torch.randint(0, 3, (bs, 1, seq_len)) # cat\nt4 = torch.randn(bs, 1, seq_len)\nt5 = torch.randn(bs, 1, seq_len)\n\nt = torch.cat([t0, t1, t2, t3, t4, t5], 1).float().to(default_device())\n\npatch_lens = [None, 5, 5, 5, 5]\npatch_strides = [None, None, 1, 3, 5]\nfor patch_len, patch_stride in zip(patch_lens, patch_strides):\n    for arch in [\"InceptionTimePlus\", InceptionTimePlus, \"TSiTPlus\"]:\n        print(f\"arch: {arch}, patch_len: {patch_len}, patch_stride: {patch_stride}\")\n\n        model = MultInputWrapper(\n            arch=arch,\n            c_in=c_in,\n            c_out=c_out,\n            seq_len=seq_len,\n            d=d,\n            s_cat_idxs=s_cat_idxs, s_cat_embeddings=s_cat_embeddings, s_cat_embedding_dims=s_cat_embedding_dims,\n            s_cont_idxs=s_cont_idxs,\n            o_cat_idxs=o_cat_idxs, o_cat_embeddings=o_cat_embeddings, o_cat_embedding_dims=o_cat_embedding_dims,\n            o_cont_idxs=o_cont_idxs,\n            patch_len=patch_len,\n            patch_stride=patch_stride,\n            fusion_layers=fusion_layers,\n        ).to(default_device())\n\n        test_eq(model(t).shape, (bs, c_out))\n\narch: InceptionTimePlus, patch_len: None, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: None, patch_stride: None\narch: TSiTPlus, patch_len: None, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: None\narch: TSiTPlus, patch_len: 5, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: 1\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 1\narch: TSiTPlus, patch_len: 5, patch_stride: 1\narch: InceptionTimePlus, patch_len: 5, patch_stride: 3\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 3\narch: TSiTPlus, patch_len: 5, patch_stride: 3\narch: InceptionTimePlus, patch_len: 5, patch_stride: 5\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 5\narch: TSiTPlus, patch_len: 5, patch_stride: 5\n\n\n\nbs = 8\nc_in = 6\nc_out = 3\nseq_len = 97\nd = None\n\ns_cat_idxs=None\ns_cont_idxs=4\no_cat_idxs=[0, 3]\no_cont_idxs=None\ns_cat_embeddings = None\ns_cat_embedding_dims = None\no_cat_embeddings = [7, 3]\no_cat_embedding_dims = [3, None]\n\nfusion_layers = 128\n\nt0 = torch.randint(0, 7, (bs, 1, seq_len)) # cat\nt1 = torch.randn(bs, 1, seq_len)\nt2 = torch.randint(0, 5, (bs, 1, seq_len)) # cat\nt3 = torch.randint(0, 3, (bs, 1, seq_len)) # cat\nt4 = torch.randn(bs, 1, seq_len)\nt5 = torch.randn(bs, 1, seq_len)\n\nt = torch.cat([t0, t1, t2, t3, t4, t5], 1).float().to(default_device())\n\npatch_lens = [None, 5, 5, 5, 5]\npatch_strides = [None, None, 1, 3, 5]\nfor patch_len, patch_stride in zip(patch_lens, patch_strides):\n    for arch in [\"InceptionTimePlus\", InceptionTimePlus, \"TSiTPlus\"]:\n        print(f\"arch: {arch}, patch_len: {patch_len}, patch_stride: {patch_stride}\")\n\n        model = MultInputWrapper(\n            arch=arch,\n            c_in=c_in,\n            c_out=c_out,\n            seq_len=seq_len,\n            d=d,\n            s_cat_idxs=s_cat_idxs, s_cat_embeddings=s_cat_embeddings, s_cat_embedding_dims=s_cat_embedding_dims,\n            s_cont_idxs=s_cont_idxs,\n            o_cat_idxs=o_cat_idxs, o_cat_embeddings=o_cat_embeddings, o_cat_embedding_dims=o_cat_embedding_dims,\n            o_cont_idxs=o_cont_idxs,\n            patch_len=patch_len,\n            patch_stride=patch_stride,\n            fusion_layers=fusion_layers,\n        ).to(default_device())\n\n        test_eq(model(t).shape, (bs, c_out))\n\narch: InceptionTimePlus, patch_len: None, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: None, patch_stride: None\narch: TSiTPlus, patch_len: None, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: None\narch: TSiTPlus, patch_len: 5, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: 1\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 1\narch: TSiTPlus, patch_len: 5, patch_stride: 1\narch: InceptionTimePlus, patch_len: 5, patch_stride: 3\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 3\narch: TSiTPlus, patch_len: 5, patch_stride: 3\narch: InceptionTimePlus, patch_len: 5, patch_stride: 5\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 5\narch: TSiTPlus, patch_len: 5, patch_stride: 5\n\n\n\nbs = 8\nc_in = 6\nc_out = 3\nseq_len = 97\nd = None\n\ns_cat_idxs=2\ns_cont_idxs=4\no_cat_idxs=None\no_cont_idxs=None\ns_cat_embeddings = 5\ns_cat_embedding_dims = None\no_cat_embeddings = None\no_cat_embedding_dims = None\n\nfusion_layers = 128\n\nt0 = torch.randint(0, 7, (bs, 1, seq_len)) # cat\nt1 = torch.randn(bs, 1, seq_len)\nt2 = torch.randint(0, 5, (bs, 1, seq_len)) # cat\nt3 = torch.randint(0, 3, (bs, 1, seq_len)) # cat\nt4 = torch.randn(bs, 1, seq_len)\nt5 = torch.randn(bs, 1, seq_len)\n\nt = torch.cat([t0, t1, t2, t3, t4, t5], 1).float().to(default_device())\n\npatch_lens = [None, 5, 5, 5, 5]\npatch_strides = [None, None, 1, 3, 5]\nfor patch_len, patch_stride in zip(patch_lens, patch_strides):\n    for arch in [\"InceptionTimePlus\", InceptionTimePlus, \"TSiTPlus\"]:\n        print(f\"arch: {arch}, patch_len: {patch_len}, patch_stride: {patch_stride}\")\n\n        model = MultInputWrapper(\n            arch=arch,\n            c_in=c_in,\n            c_out=c_out,\n            seq_len=seq_len,\n            d=d,\n            s_cat_idxs=s_cat_idxs, s_cat_embeddings=s_cat_embeddings, s_cat_embedding_dims=s_cat_embedding_dims,\n            s_cont_idxs=s_cont_idxs,\n            o_cat_idxs=o_cat_idxs, o_cat_embeddings=o_cat_embeddings, o_cat_embedding_dims=o_cat_embedding_dims,\n            o_cont_idxs=o_cont_idxs,\n            patch_len=patch_len,\n            patch_stride=patch_stride,\n            fusion_layers=fusion_layers,\n        ).to(default_device())\n\n        test_eq(model(t).shape, (bs, c_out))\n\narch: InceptionTimePlus, patch_len: None, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: None, patch_stride: None\narch: TSiTPlus, patch_len: None, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: None\narch: TSiTPlus, patch_len: 5, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: 1\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 1\narch: TSiTPlus, patch_len: 5, patch_stride: 1\narch: InceptionTimePlus, patch_len: 5, patch_stride: 3\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 3\narch: TSiTPlus, patch_len: 5, patch_stride: 3\narch: InceptionTimePlus, patch_len: 5, patch_stride: 5\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 5\narch: TSiTPlus, patch_len: 5, patch_stride: 5\n\n\n\nbs = 8\nc_in = 6\nc_out = 3\nseq_len = 97\nd = None\n\ns_cat_idxs=None\ns_cont_idxs=None\no_cat_idxs=None\no_cont_idxs=None\ns_cat_embeddings = None\ns_cat_embedding_dims = None\no_cat_embeddings = None\no_cat_embedding_dims = None\n\nfusion_layers = 128\n\nt0 = torch.randint(0, 7, (bs, 1, seq_len)) # cat\nt1 = torch.randn(bs, 1, seq_len)\nt2 = torch.randint(0, 5, (bs, 1, seq_len)) # cat\nt3 = torch.randint(0, 3, (bs, 1, seq_len)) # cat\nt4 = torch.randn(bs, 1, seq_len)\nt5 = torch.randn(bs, 1, seq_len)\n\nt = torch.cat([t0, t1, t2, t3, t4, t5], 1).float().to(default_device())\n\npatch_lens = [None, 5, 5, 5, 5]\npatch_strides = [None, None, 1, 3, 5]\nfor patch_len, patch_stride in zip(patch_lens, patch_strides):\n    for arch in [\"InceptionTimePlus\", InceptionTimePlus, \"TSiTPlus\"]:\n        print(f\"arch: {arch}, patch_len: {patch_len}, patch_stride: {patch_stride}\")\n\n        model = MultInputWrapper(\n            arch=arch,\n            c_in=c_in,\n            c_out=c_out,\n            seq_len=seq_len,\n            d=d,\n            s_cat_idxs=s_cat_idxs, s_cat_embeddings=s_cat_embeddings, s_cat_embedding_dims=s_cat_embedding_dims,\n            s_cont_idxs=s_cont_idxs,\n            o_cat_idxs=o_cat_idxs, o_cat_embeddings=o_cat_embeddings, o_cat_embedding_dims=o_cat_embedding_dims,\n            o_cont_idxs=o_cont_idxs,\n            patch_len=patch_len,\n            patch_stride=patch_stride,\n            fusion_layers=fusion_layers,\n        ).to(default_device())\n\n        test_eq(model(t).shape, (bs, c_out))\n\narch: InceptionTimePlus, patch_len: None, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: None, patch_stride: None\narch: TSiTPlus, patch_len: None, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: None\narch: TSiTPlus, patch_len: 5, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: 1\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 1\narch: TSiTPlus, patch_len: 5, patch_stride: 1\narch: InceptionTimePlus, patch_len: 5, patch_stride: 3\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 3\narch: TSiTPlus, patch_len: 5, patch_stride: 3\narch: InceptionTimePlus, patch_len: 5, patch_stride: 5\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 5\narch: TSiTPlus, patch_len: 5, patch_stride: 5\n\n\n\nclass CustomHead(nn.Module):\n    def __init__(self, head_nf, c_out, seq_len, d):\n        super().__init__()\n        self.d = d\n        self.c_out = c_out\n        self.fc = nn.Linear(head_nf, d * c_out)\n\n    def forward(self, x):\n        x = self.fc(x)         # [batch_size, d*c]\n        x = x.view(x.shape[0], self.d, self.c_out)\n        return x\n\n\nbs = 8\nc_in = 6\nc_out = 3\nseq_len = 97\nd = 7\n\ns_cat_idxs=None\ns_cont_idxs=None\no_cat_idxs=None\no_cont_idxs=None\ns_cat_embeddings = None\ns_cat_embedding_dims = None\no_cat_embeddings = None\no_cat_embedding_dims = None\n\nfusion_layers = 128\n\nt0 = torch.randint(0, 7, (bs, 1, seq_len)) # cat\nt1 = torch.randn(bs, 1, seq_len)\nt2 = torch.randint(0, 5, (bs, 1, seq_len)) # cat\nt3 = torch.randint(0, 3, (bs, 1, seq_len)) # cat\nt4 = torch.randn(bs, 1, seq_len)\nt5 = torch.randn(bs, 1, seq_len)\n\nt = torch.cat([t0, t1, t2, t3, t4, t5], 1).float().to(default_device())\n\npatch_lens = [None, 5, 5, 5, 5]\npatch_strides = [None, None, 1, 3, 5]\nfor patch_len, patch_stride in zip(patch_lens, patch_strides):\n    for arch in [\"InceptionTimePlus\", InceptionTimePlus, \"TSiTPlus\"]:\n        print(f\"arch: {arch}, patch_len: {patch_len}, patch_stride: {patch_stride}\")\n        model = MultInputWrapper(\n            arch=arch,\n            custom_head=CustomHead,\n            c_in=c_in,\n            c_out=c_out,\n            seq_len=seq_len,\n            d=d,\n            s_cat_idxs=s_cat_idxs, s_cat_embeddings=s_cat_embeddings, s_cat_embedding_dims=s_cat_embedding_dims,\n            s_cont_idxs=s_cont_idxs,\n            o_cat_idxs=o_cat_idxs, o_cat_embeddings=o_cat_embeddings, o_cat_embedding_dims=o_cat_embedding_dims,\n            o_cont_idxs=o_cont_idxs,\n            patch_len=patch_len,\n            patch_stride=patch_stride,\n            fusion_layers=fusion_layers,\n        ).to(default_device())\n\n        test_eq(model(t).shape, (bs, d, c_out))\n\narch: InceptionTimePlus, patch_len: None, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: None, patch_stride: None\narch: TSiTPlus, patch_len: None, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: None\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: None\narch: TSiTPlus, patch_len: 5, patch_stride: None\narch: InceptionTimePlus, patch_len: 5, patch_stride: 1\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 1\narch: TSiTPlus, patch_len: 5, patch_stride: 1\narch: InceptionTimePlus, patch_len: 5, patch_stride: 3\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 3\narch: TSiTPlus, patch_len: 5, patch_stride: 3\narch: InceptionTimePlus, patch_len: 5, patch_stride: 5\narch: &lt;class 'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, patch_len: 5, patch_stride: 5\narch: TSiTPlus, patch_len: 5, patch_stride: 5",
    "crumbs": [
      "Models",
      "Miscellaneous",
      "Multimodal"
    ]
  },
  {
    "objectID": "models.xceptiontimeplus.html",
    "href": "models.xceptiontimeplus.html",
    "title": "XceptionTimePlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza - oguiza@timeseriesAI.co modified on:\nFawaz, H. I., Lucas, B., Forestier, G., Pelletier, C., Schmidt, D. F., Weber, J. & Petitjean, F. (2019). InceptionTime: Finding AlexNet for Time Series Classification. arXiv preprint arXiv:1909.04939.\nOfficial InceptionTime tensorflow implementation: https://github.com/hfawaz/InceptionTime\n\nsource\n\nXceptionTimePlus\n\n XceptionTimePlus (c_in, c_out, seq_len=None, nf=16, nb_filters=None,\n                   coord=False, norm='Batch', concat_pool=False,\n                   adaptive_size=50, custom_head=None, residual=True,\n                   zero_norm=False, act=&lt;class\n                   'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nXceptionBlockPlus\n\n XceptionBlockPlus (ni, nf, residual=True, coord=False, norm='Batch',\n                    zero_norm=False, act=&lt;class\n                    'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={},\n                    ks=40, kss=None, bottleneck=True, separable=True,\n                    bn_1st=True, norm_act=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nXceptionModulePlus\n\n XceptionModulePlus (ni, nf, ks=40, kss=None, bottleneck=True,\n                     coord=False, separable=True, norm='Batch',\n                     zero_norm=False, bn_1st=True, act=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={},\n                     norm_act=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nvars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, vars, seq_len)\n\n\ntest_eq(XceptionTimePlus(vars,c_out)(xb).shape, [bs, c_out])\ntest_eq(XceptionTimePlus(vars,c_out, nf=32)(xb).shape, [bs, c_out])\ntest_eq(XceptionTimePlus(vars,c_out, bottleneck=False)(xb).shape, [bs, c_out])\ntest_eq(XceptionTimePlus(vars,c_out, residual=False)(xb).shape, [bs, c_out])\ntest_eq(XceptionTimePlus(vars,c_out, coord=True)(xb).shape, [bs, c_out])\ntest_eq(XceptionTimePlus(vars,c_out, concat_pool=True)(xb).shape, [bs, c_out])\ntest_eq(count_parameters(XceptionTimePlus(3, 2)), 399540)\n\n\nm = XceptionTimePlus(2,3)\ntest_eq(check_weight(m, is_bn)[0].sum(), 5)\ntest_eq(len(check_bias(m, is_conv)[0]), 0)\nm = XceptionTimePlus(2,3, zero_norm=True)\ntest_eq(check_weight(m, is_bn)[0].sum(), 5)\nm = XceptionTimePlus(2,3, zero_norm=True, norm_act=True)\ntest_eq(check_weight(m, is_bn)[0].sum(), 7)\n\n\nm = XceptionTimePlus(2,3, coord=True)\ntest_eq(len(get_layers(m, cond=is_layer(AddCoords1d))), 25)\ntest_eq(len(get_layers(m, cond=is_layer(nn.Conv1d))), 37)\nm = XceptionTimePlus(2,3, bottleneck=False, coord=True)\ntest_eq(len(get_layers(m, cond=is_layer(AddCoords1d))), 21)\ntest_eq(len(get_layers(m, cond=is_layer(nn.Conv1d))), 33)\n\n\nm = XceptionTimePlus(vars, c_out, seq_len=seq_len, custom_head=mlp_head)\ntest_eq(m(xb).shape, [bs, c_out])\n\n\nXceptionTimePlus(vars, c_out, coord=True)\n\nXceptionTimePlus(\n  (backbone): XceptionBlockPlus(\n    (xception): ModuleList(\n      (0): XceptionModulePlus(\n        (bottleneck): ConvBlock(\n          (0): AddCoords1d()\n          (1): Conv1d(4, 16, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (convs): ModuleList(\n          (0): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(17, 17, kernel_size=(39,), stride=(1,), padding=(19,), groups=17, bias=False)\n              (pointwise_conv): Conv1d(17, 16, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(17, 17, kernel_size=(19,), stride=(1,), padding=(9,), groups=17, bias=False)\n              (pointwise_conv): Conv1d(17, 16, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (2): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(17, 17, kernel_size=(9,), stride=(1,), padding=(4,), groups=17, bias=False)\n              (pointwise_conv): Conv1d(17, 16, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n        )\n        (mp_conv): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(4, 16, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (concat): Concat(dim=1)\n      )\n      (1): XceptionModulePlus(\n        (bottleneck): ConvBlock(\n          (0): AddCoords1d()\n          (1): Conv1d(65, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (convs): ModuleList(\n          (0): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(33, 33, kernel_size=(39,), stride=(1,), padding=(19,), groups=33, bias=False)\n              (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(33, 33, kernel_size=(19,), stride=(1,), padding=(9,), groups=33, bias=False)\n              (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (2): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(33, 33, kernel_size=(9,), stride=(1,), padding=(4,), groups=33, bias=False)\n              (pointwise_conv): Conv1d(33, 32, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n        )\n        (mp_conv): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(65, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (concat): Concat(dim=1)\n      )\n      (2): XceptionModulePlus(\n        (bottleneck): ConvBlock(\n          (0): AddCoords1d()\n          (1): Conv1d(129, 64, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (convs): ModuleList(\n          (0): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(65, 65, kernel_size=(39,), stride=(1,), padding=(19,), groups=65, bias=False)\n              (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(65, 65, kernel_size=(19,), stride=(1,), padding=(9,), groups=65, bias=False)\n              (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (2): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(65, 65, kernel_size=(9,), stride=(1,), padding=(4,), groups=65, bias=False)\n              (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n        )\n        (mp_conv): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(129, 64, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (concat): Concat(dim=1)\n      )\n      (3): XceptionModulePlus(\n        (bottleneck): ConvBlock(\n          (0): AddCoords1d()\n          (1): Conv1d(257, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (convs): ModuleList(\n          (0): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(129, 129, kernel_size=(39,), stride=(1,), padding=(19,), groups=129, bias=False)\n              (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(129, 129, kernel_size=(19,), stride=(1,), padding=(9,), groups=129, bias=False)\n              (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n          (2): ConvBlock(\n            (0): AddCoords1d()\n            (1): SeparableConv1d(\n              (depthwise_conv): Conv1d(129, 129, kernel_size=(9,), stride=(1,), padding=(4,), groups=129, bias=False)\n              (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n            )\n          )\n        )\n        (mp_conv): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): ConvBlock(\n            (0): AddCoords1d()\n            (1): Conv1d(257, 128, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (concat): Concat(dim=1)\n      )\n    )\n    (shortcut): ModuleList(\n      (0): ConvBlock(\n        (0): AddCoords1d()\n        (1): Conv1d(4, 128, kernel_size=(1,), stride=(1,), bias=False)\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (1): ConvBlock(\n        (0): AddCoords1d()\n        (1): Conv1d(129, 512, kernel_size=(1,), stride=(1,), bias=False)\n        (2): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (act): ModuleList(\n      (0): ReLU()\n      (1): ReLU()\n    )\n    (add): Add\n  )\n  (head): Sequential(\n    (0): AdaptiveAvgPool1d(output_size=50)\n    (1): ConvBlock(\n      (0): AddCoords1d()\n      (1): Conv1d(513, 256, kernel_size=(1,), stride=(1,), bias=False)\n      (2): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): ReLU()\n    )\n    (2): ConvBlock(\n      (0): AddCoords1d()\n      (1): Conv1d(257, 128, kernel_size=(1,), stride=(1,), bias=False)\n      (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): ReLU()\n    )\n    (3): ConvBlock(\n      (0): AddCoords1d()\n      (1): Conv1d(129, 2, kernel_size=(1,), stride=(1,), bias=False)\n      (2): BatchNorm1d(2, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): ReLU()\n    )\n    (4): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Reshape(bs)\n    )\n  )\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "XceptionTimePlus"
    ]
  },
  {
    "objectID": "inference.html",
    "href": "inference.html",
    "title": "Inference",
    "section": "",
    "text": "Code required for inference.\n\n\nsource\n\nLearner.get_X_preds\n\n Learner.get_X_preds (X, y=None, bs=64, with_input=False,\n                      with_decoded=True, with_loss=False, act=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nX\n\n\n\n\n\ny\nNoneType\nNone\n\n\n\nbs\nint\n64\n\n\n\nwith_input\nbool\nFalse\nreturns the input as well\n\n\nwith_decoded\nbool\nTrue\nreturns decoded predictions as well\n\n\nwith_loss\nbool\nFalse\nreturns the loss per item as well\n\n\nact\nNoneType\nNone\nApply activation to predictions, defaults to self.loss_func’s activation\n\n\n\nGet the predictions and targets, optionally with_input and with_loss.\nwith_decoded will also return the decoded predictions (it reverses the transforms applied).\nThe order of the output is the following:\n\ninput (optional): if with_input is True\nprobabiblities (for classification) or predictions (for regression)\ntarget: if y is provided. Otherwise None.\npredictions: predicted labels. Predictions will be decoded if with_decoded=True.\nloss (optional): if with_loss is set to True and y is not None.\n\n\nfrom tsai.data.external import get_UCR_data\n\n\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, split_data=False)\nX_test = X[splits[1]]\ny_test = y[splits[1]]\n\n\nlearn = load_learner(\"./models/test.pth\")\n\n⚠️ Warning: load_learner (from fastai) requires all your custom code be in the exact same place as when exporting your Learner (the main script, or the module you imported it from).\n\ntest_probas, test_targets, test_preds = learn.get_X_preds(X_test, with_decoded=True)\ntest_probas, test_targets, test_preds\n\n\n\n\n\n\n\n\n(tensor([[0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2639],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2641],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2421, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640]]),\n None,\n array(['4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n        '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n        '4', '4', '4', '4'], dtype='&lt;U1'))\n\n\n\nimport torch\nfrom fastcore.test import test_close\n\n\ntorch_test_probas, torch_test_targets, torch_test_preds = learn.get_X_preds(torch.from_numpy(X_test), with_decoded=True)\ntorch_test_probas, torch_test_targets, torch_test_preds\ntest_close(test_probas, torch_test_probas)\n\n\n\n\n\n\n\n\n\ntest_probas2, test_targets2, test_preds2 = learn.get_X_preds(X_test, y_test, with_decoded=True)\ntest_probas2, test_targets2, test_preds2\n\n\n\n\n\n\n\n\n(tensor([[0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2639],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2641],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2421, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640]]),\n tensor([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,\n         3, 3, 3, 3, 3, 3]),\n array(['4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n        '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n        '4', '4', '4', '4'], dtype='&lt;U1'))\n\n\n\ntest_probas3, test_targets3, test_preds3, test_losses3 = learn.get_X_preds(X_test, y_test, with_loss=True, with_decoded=True)\ntest_probas3, test_targets3, test_preds3, test_losses3\n\n\n\n\n\n\n\n\n(tensor([[0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2639],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2641],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2421, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2421, 0.2364, 0.2641],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640],\n         [0.2574, 0.2422, 0.2364, 0.2640]]),\n tensor([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,\n         3, 3, 3, 3, 3, 3]),\n array(['4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n        '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n        '4', '4', '4', '4'], dtype='&lt;U1'),\n TensorBase([1.3572, 1.3572, 1.3572, 1.3571, 1.3572, 1.4181, 1.4181, 1.4181,\n             1.4181, 1.4181, 1.4181, 1.4181, 1.4181, 1.4181, 1.4423, 1.4422,\n             1.4422, 1.4422, 1.3316, 1.3316, 1.3316, 1.3316, 1.3316, 1.3316,\n             1.3316, 1.3316, 1.3316, 1.3316, 1.3317, 1.3317]))\n\n\n\nfrom fastcore.test import test_eq\n\n\ntest_eq(test_probas, test_probas2)\ntest_eq(test_preds, test_preds2)\ntest_eq(test_probas, test_probas3)\ntest_eq(test_preds, test_preds3)",
    "crumbs": [
      "Inference"
    ]
  },
  {
    "objectID": "models.xceptiontime.html",
    "href": "models.xceptiontime.html",
    "title": "XceptionTime",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza - oguiza@timeseriesAI.co modified on:\nFawaz, H. I., Lucas, B., Forestier, G., Pelletier, C., Schmidt, D. F., Weber, J. & Petitjean, F. (2019). InceptionTime: Finding AlexNet for Time Series Classification. arXiv preprint arXiv:1909.04939.\nOfficial InceptionTime tensorflow implementation: https://github.com/hfawaz/InceptionTime\n\nsource\n\nXceptionTime\n\n XceptionTime (c_in, c_out, nf=16, nb_filters=None, adaptive_size=50,\n               residual=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nXceptionBlock\n\n XceptionBlock (ni, nf, residual=True, ks=40, bottleneck=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nXceptionModule\n\n XceptionModule (ni, nf, ks=40, bottleneck=True)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nvars = 3\nseq_len = 12\nc_out = 6\nxb = torch.rand(bs, vars, seq_len)\ntest_eq(XceptionTime(vars,c_out)(xb).shape, [bs, c_out])\ntest_eq(XceptionTime(vars,c_out, bottleneck=False)(xb).shape, [bs, c_out])\ntest_eq(XceptionTime(vars,c_out, residual=False)(xb).shape, [bs, c_out])\ntest_eq(count_parameters(XceptionTime(3, 2)), 399540)\n\n\nm = XceptionTime(2,3)\ntest_eq(check_weight(m, is_bn)[0].sum(), 5) # 2 shortcut + 3 bn\ntest_eq(len(check_bias(m, is_conv)[0]), 0)\ntest_eq(len(check_bias(m)[0]), 5) # 2 shortcut + 3 bn\n\n\nXceptionTime(3, 2)\n\nXceptionTime(\n  (block): XceptionBlock(\n    (xception): ModuleList(\n      (0): XceptionModule(\n        (bottleneck): Conv1d(3, 16, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): SeparableConv1d(\n            (depthwise_conv): Conv1d(16, 16, kernel_size=(39,), stride=(1,), padding=(19,), groups=16, bias=False)\n            (pointwise_conv): Conv1d(16, 16, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (1): SeparableConv1d(\n            (depthwise_conv): Conv1d(16, 16, kernel_size=(19,), stride=(1,), padding=(9,), groups=16, bias=False)\n            (pointwise_conv): Conv1d(16, 16, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (2): SeparableConv1d(\n            (depthwise_conv): Conv1d(16, 16, kernel_size=(9,), stride=(1,), padding=(4,), groups=16, bias=False)\n            (pointwise_conv): Conv1d(16, 16, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(3, 16, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n      )\n      (1): XceptionModule(\n        (bottleneck): Conv1d(64, 32, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): SeparableConv1d(\n            (depthwise_conv): Conv1d(32, 32, kernel_size=(39,), stride=(1,), padding=(19,), groups=32, bias=False)\n            (pointwise_conv): Conv1d(32, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (1): SeparableConv1d(\n            (depthwise_conv): Conv1d(32, 32, kernel_size=(19,), stride=(1,), padding=(9,), groups=32, bias=False)\n            (pointwise_conv): Conv1d(32, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (2): SeparableConv1d(\n            (depthwise_conv): Conv1d(32, 32, kernel_size=(9,), stride=(1,), padding=(4,), groups=32, bias=False)\n            (pointwise_conv): Conv1d(32, 32, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(64, 32, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n      )\n      (2): XceptionModule(\n        (bottleneck): Conv1d(128, 64, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): SeparableConv1d(\n            (depthwise_conv): Conv1d(64, 64, kernel_size=(39,), stride=(1,), padding=(19,), groups=64, bias=False)\n            (pointwise_conv): Conv1d(64, 64, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (1): SeparableConv1d(\n            (depthwise_conv): Conv1d(64, 64, kernel_size=(19,), stride=(1,), padding=(9,), groups=64, bias=False)\n            (pointwise_conv): Conv1d(64, 64, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (2): SeparableConv1d(\n            (depthwise_conv): Conv1d(64, 64, kernel_size=(9,), stride=(1,), padding=(4,), groups=64, bias=False)\n            (pointwise_conv): Conv1d(64, 64, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(128, 64, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n      )\n      (3): XceptionModule(\n        (bottleneck): Conv1d(256, 128, kernel_size=(1,), stride=(1,), bias=False)\n        (convs): ModuleList(\n          (0): SeparableConv1d(\n            (depthwise_conv): Conv1d(128, 128, kernel_size=(39,), stride=(1,), padding=(19,), groups=128, bias=False)\n            (pointwise_conv): Conv1d(128, 128, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (1): SeparableConv1d(\n            (depthwise_conv): Conv1d(128, 128, kernel_size=(19,), stride=(1,), padding=(9,), groups=128, bias=False)\n            (pointwise_conv): Conv1d(128, 128, kernel_size=(1,), stride=(1,), bias=False)\n          )\n          (2): SeparableConv1d(\n            (depthwise_conv): Conv1d(128, 128, kernel_size=(9,), stride=(1,), padding=(4,), groups=128, bias=False)\n            (pointwise_conv): Conv1d(128, 128, kernel_size=(1,), stride=(1,), bias=False)\n          )\n        )\n        (maxconvpool): Sequential(\n          (0): MaxPool1d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False)\n          (1): Conv1d(256, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (concat): Concat(dim=1)\n      )\n    )\n    (shortcut): ModuleList(\n      (0): ConvBlock(\n        (0): Conv1d(3, 128, kernel_size=(1,), stride=(1,), bias=False)\n        (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (1): ConvBlock(\n        (0): Conv1d(128, 512, kernel_size=(1,), stride=(1,), bias=False)\n        (1): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (add): Add\n    (act): ReLU()\n  )\n  (head): Sequential(\n    (0): AdaptiveAvgPool1d(output_size=50)\n    (1): ConvBlock(\n      (0): Conv1d(512, 256, kernel_size=(1,), stride=(1,), bias=False)\n      (1): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (2): ConvBlock(\n      (0): Conv1d(256, 128, kernel_size=(1,), stride=(1,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (3): ConvBlock(\n      (0): Conv1d(128, 2, kernel_size=(1,), stride=(1,), bias=False)\n      (1): BatchNorm1d(2, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (4): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Flatten(full=False)\n    )\n  )\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "XceptionTime"
    ]
  },
  {
    "objectID": "models.patchtst.html",
    "href": "models.patchtst.html",
    "title": "PatchTST",
    "section": "",
    "text": "This is an unofficial PyTorch implementation of PatchTST created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on:\nIn this notebook, we are going to use a new state-of-the-art model called PatchTST (Nie et al, 2022) to create a long-term time series forecast.\nHere are some paper details:\n\nNie, Y., Nguyen, N. H., Sinthong, P., & Kalagnanam, J. (2022). A Time Series is Worth 64 Words: Long-term Forecasting with Transformers. arXiv preprint arXiv:2211.14730.\nOfficial implementation:: https://github.com/yuqinie98/PatchTST\n\n@article{Yuqietal-2022-PatchTST,\n  title={A Time Series is Worth 64 Words: Long-term Forecasting with Transformers},\n  author={Yuqi Nie and \n          Nam H. Nguyen and \n          Phanwadee Sinthong and \n          Jayant Kalagnanam},\n  journal={arXiv preprint arXiv:2211.14730},\n  year={2022}\n}\nPatchTST has shown some impressive results across some of the most widely used long-term datasets for benchmarking:\n\n\n\nimage.png\n\n\n\nsource\n\nSeriesDecomposition\n\n SeriesDecomposition (kernel_size:int)\n\nSeries decomposition block\n\n\n\n\nType\nDetails\n\n\n\n\nkernel_size\nint\nthe size of the window\n\n\n\n\nsource\n\n\nMovingAverage\n\n MovingAverage (kernel_size:int)\n\nMoving average block to highlight the trend of time series\n\n\n\n\nType\nDetails\n\n\n\n\nkernel_size\nint\nthe size of the window\n\n\n\n\nsource\n\n\nFlatten_Head\n\n Flatten_Head (individual, n_vars, nf, pred_dim)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nPatchTST\n\n PatchTST (c_in, c_out, seq_len, pred_dim=None, n_layers=2, n_heads=8,\n           d_model=512, d_ff=2048, dropout=0.05, attn_dropout=0.0,\n           patch_len=16, stride=8, padding_patch=True, revin=True,\n           affine=False, individual=False, subtract_last=False,\n           decomposition=False, kernel_size=25, activation='gelu',\n           norm='BatchNorm', pre_norm=False, res_attention=True,\n           store_attn=False)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\nnumber of input channels\n\n\nc_out\n\n\nused for compatibility\n\n\nseq_len\n\n\ninput sequence length\n\n\npred_dim\nNoneType\nNone\nprediction sequence length\n\n\nn_layers\nint\n2\nnumber of encoder layers\n\n\nn_heads\nint\n8\nnumber of heads\n\n\nd_model\nint\n512\ndimension of model\n\n\nd_ff\nint\n2048\ndimension of fully connected network (fcn)\n\n\ndropout\nfloat\n0.05\ndropout applied to all linear layers in the encoder\n\n\nattn_dropout\nfloat\n0.0\ndropout applied to the attention scores\n\n\npatch_len\nint\n16\npatch_len\n\n\nstride\nint\n8\nstride\n\n\npadding_patch\nbool\nTrue\nflag to indicate if padded is added if necessary\n\n\nrevin\nbool\nTrue\nRevIN\n\n\naffine\nbool\nFalse\nRevIN affine\n\n\nindividual\nbool\nFalse\nindividual head\n\n\nsubtract_last\nbool\nFalse\nsubtract_last\n\n\ndecomposition\nbool\nFalse\napply decomposition\n\n\nkernel_size\nint\n25\ndecomposition kernel size\n\n\nactivation\nstr\ngelu\nactivation function of intermediate layer, relu or gelu.\n\n\nnorm\nstr\nBatchNorm\ntype of normalization layer used in the encoder\n\n\npre_norm\nbool\nFalse\nflag to indicate if normalization is applied as the first step in the sublayers\n\n\nres_attention\nbool\nTrue\nflag to indicate if Residual MultiheadAttention should be used\n\n\nstore_attn\nbool\nFalse\ncan be used to visualize attention weights\n\n\n\n\nfrom fastcore.test import test_eq\nfrom tsai.models.utils import count_parameters\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 1\nseq_len = 60\npred_dim = 20\n\nxb = torch.randn(bs, c_in, seq_len)\n\narch_config=dict(\n        n_layers=3,  # number of encoder layers\n        n_heads=16,  # number of heads\n        d_model=128,  # dimension of model\n        d_ff=256,  # dimension of fully connected network (fcn)\n        attn_dropout=0.,\n        dropout=0.2,  # dropout applied to all linear layers in the encoder\n        patch_len=16,  # patch_len\n        stride=8,  # stride\n    )\n\nmodel = PatchTST(c_in, c_out, seq_len, pred_dim, **arch_config)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_in, pred_dim])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 418470\n\n\n\n\nTest conversion to Torchscript\n\nimport gc\nimport os\nimport torch\nimport torch.nn as nn\nfrom fastcore.test import test_eq, test_close\n\n\nbs = 1\nnew_bs = 8\nc_in = 3\nc_out = 1\nseq_len = 96\npred_dim = 20\n\n# module\nmodel = PatchTST(c_in, c_out, seq_len, pred_dim)\nmodel = model.eval()\n\n# input data\ninp = torch.rand(bs, c_in, seq_len)\nnew_inp = torch.rand(new_bs, c_in, seq_len)\n\n# original\ntry:\n    output = model(inp)\n    new_output = model(new_inp)\n    print(f'{\"original\":10}: ok')\nexcept:\n    print(f'{\"original\":10}: failed')\n\n# tracing\ntry:\n    traced_model = torch.jit.trace(model, inp)\n    file_path = f\"_test_traced_model.pt\"\n    torch.jit.save(traced_model, file_path)\n    traced_model = torch.jit.load(file_path)\n    test_eq(output, traced_model(inp))\n    test_eq(new_output, traced_model(new_inp))\n    os.remove(file_path)\n    del traced_model\n    gc.collect()\n    print(f'{\"tracing\":10}: ok')\nexcept:\n    print(f'{\"tracing\":10}: failed')\n\n# scripting\ntry:\n    scripted_model = torch.jit.script(model)\n    file_path = f\"_test_scripted_model.pt\"\n    torch.jit.save(scripted_model, file_path)\n    scripted_model = torch.jit.load(file_path)\n    test_eq(output, scripted_model(inp))\n    test_eq(new_output, scripted_model(new_inp))\n    os.remove(file_path)\n    del scripted_model\n    gc.collect()\n    print(f'{\"scripting\":10}: ok')\nexcept:\n    print(f'{\"scripting\":10}: failed')\n\noriginal  : ok\ntracing   : ok\nscripting : failed\n\n\n\n\nTest conversion to onnx\n\ntry:\n    import onnx\n    import onnxruntime as ort\n    \n    try:\n        file_path = \"_model_cpu.onnx\"\n        torch.onnx.export(model.cpu(),               # model being run\n                        inp,                       # model input (or a tuple for multiple inputs)\n                        file_path,                 # where to save the model (can be a file or file-like object)\n                        input_names = ['input'],   # the model's input names\n                        output_names = ['output'], # the model's output names\n                        dynamic_axes={\n                            'input'  : {0 : 'batch_size'}, \n                            'output' : {0 : 'batch_size'}} # variable length axes\n                        )\n\n\n        # Load the model and check it's ok\n        onnx_model = onnx.load(file_path)\n        onnx.checker.check_model(onnx_model)\n        del onnx_model\n        gc.collect()\n\n        # New session\n        ort_sess = ort.InferenceSession(file_path)\n        output_onnx = ort_sess.run(None, {'input': inp.numpy()})[0]\n        test_close(output.detach().numpy(), output_onnx)\n        new_output_onnx = ort_sess.run(None, {'input': new_inp.numpy()})[0]\n        test_close(new_output.detach().numpy(), new_output_onnx)\n        os.remove(file_path)\n        print(f'{\"onnx\":10}: ok')\n    except:\n        print(f'{\"onnx\":10}: failed')\n\nexcept ImportError:\n    print('onnx and onnxruntime are not installed. Please install them to run this test')\n\nonnx and onnxruntime are not installed. Please install them to run this test",
    "crumbs": [
      "Models",
      "Transformers",
      "PatchTST"
    ]
  },
  {
    "objectID": "data.preprocessing.html",
    "href": "data.preprocessing.html",
    "title": "Data preprocessing",
    "section": "",
    "text": "Functions used to preprocess time series (both X and y).\nfrom tsai.data.external import get_UCR_data\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\ntfms = [None, Categorize()]\ndsets = TSDatasets(X, y, tfms=tfms, splits=splits)\nsource",
    "crumbs": [
      "Data",
      "Data preprocessing"
    ]
  },
  {
    "objectID": "data.preprocessing.html#y-transforms",
    "href": "data.preprocessing.html#y-transforms",
    "title": "Data preprocessing",
    "section": "y transforms",
    "text": "y transforms\n\nsource\n\nPreprocessor\n\n Preprocessor (preprocessor, **kwargs)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n# Standardize\nfrom tsai.data.validation import TimeSplitter\n\n\ny = random_shuffle(np.random.randn(1000) * 10 + 5)\nsplits = TimeSplitter()(y)\npreprocessor = Preprocessor(StandardScaler)\npreprocessor.fit(y[splits[0]])\ny_tfm = preprocessor.transform(y)\ntest_close(preprocessor.inverse_transform(y_tfm), y)\nplt.hist(y, 50, label='ori',)\nplt.hist(y_tfm, 50, label='tfm')\nplt.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# RobustScaler\ny = random_shuffle(np.random.randn(1000) * 10 + 5)\nsplits = TimeSplitter()(y)\npreprocessor = Preprocessor(RobustScaler)\npreprocessor.fit(y[splits[0]])\ny_tfm = preprocessor.transform(y)\ntest_close(preprocessor.inverse_transform(y_tfm), y)\nplt.hist(y, 50, label='ori',)\nplt.hist(y_tfm, 50, label='tfm')\nplt.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Normalize\ny = random_shuffle(np.random.rand(1000) * 3 + .5)\nsplits = TimeSplitter()(y)\npreprocessor = Preprocessor(Normalizer)\npreprocessor.fit(y[splits[0]])\ny_tfm = preprocessor.transform(y)\ntest_close(preprocessor.inverse_transform(y_tfm), y)\nplt.hist(y, 50, label='ori',)\nplt.hist(y_tfm, 50, label='tfm')\nplt.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# BoxCox\ny = random_shuffle(np.random.rand(1000) * 10 + 5)\nsplits = TimeSplitter()(y)\npreprocessor = Preprocessor(BoxCox)\npreprocessor.fit(y[splits[0]])\ny_tfm = preprocessor.transform(y)\ntest_close(preprocessor.inverse_transform(y_tfm), y)\nplt.hist(y, 50, label='ori',)\nplt.hist(y_tfm, 50, label='tfm')\nplt.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# YeoJohnshon\ny = random_shuffle(np.random.randn(1000) * 10 + 5)\ny = np.random.beta(.5, .5, size=1000)\nsplits = TimeSplitter()(y)\npreprocessor = Preprocessor(YeoJohnshon)\npreprocessor.fit(y[splits[0]])\ny_tfm = preprocessor.transform(y)\ntest_close(preprocessor.inverse_transform(y_tfm), y)\nplt.hist(y, 50, label='ori',)\nplt.hist(y_tfm, 50, label='tfm')\nplt.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# QuantileTransformer\ny = - np.random.beta(1, .5, 10000) * 10\nsplits = TimeSplitter()(y)\npreprocessor = Preprocessor(Quantile)\npreprocessor.fit(y[splits[0]])\nplt.hist(y, 50, label='ori',)\ny_tfm = preprocessor.transform(y)\nplt.legend(loc='best')\nplt.show()\nplt.hist(y_tfm, 50, label='tfm')\nplt.legend(loc='best')\nplt.show()\ntest_close(preprocessor.inverse_transform(y_tfm), y, 1e-1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nReLabeler\n\n ReLabeler (cm)\n\nChanges the labels in a dataset based on a dictionary (class mapping) Args: cm = class mapping dictionary\n\nvals = {0:'a', 1:'b', 2:'c', 3:'d', 4:'e'}\ny = np.array([vals[i] for i in np.random.randint(0, 5, 20)])\nlabeler = ReLabeler(dict(a='x', b='x', c='y', d='z', e='z'))\ny_new = labeler(y)\ntest_eq(y.shape, y_new.shape)\ny, y_new\n\n(array(['d', 'd', 'a', 'd', 'b', 'e', 'a', 'd', 'b', 'c', 'b', 'e', 'b',\n        'b', 'a', 'e', 'd', 'e', 'c', 'e'], dtype='&lt;U1'),\n array(['z', 'z', 'x', 'z', 'x', 'z', 'x', 'z', 'x', 'y', 'x', 'z', 'x',\n        'x', 'x', 'z', 'z', 'z', 'y', 'z'], dtype='&lt;U1'))",
    "crumbs": [
      "Data",
      "Data preprocessing"
    ]
  },
  {
    "objectID": "models.rnn_fcnplus.html",
    "href": "models.rnn_fcnplus.html",
    "title": "RNN_FCNPlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\nMGRU_FCNPlus\n\n MGRU_FCNPlus (*args, se=16, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nMLSTM_FCNPlus\n\n MLSTM_FCNPlus (*args, se=16, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nMRNN_FCNPlus\n\n MRNN_FCNPlus (*args, se=16, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nGRU_FCNPlus\n\n GRU_FCNPlus (c_in, c_out, seq_len=None, d=None, hidden_size=100,\n              rnn_layers=1, bias=True, cell_dropout=0, rnn_dropout=0.8,\n              bidirectional=False, shuffle=True, fc_dropout=0.0,\n              use_bn=False, conv_layers=[128, 256, 128], kss=[7, 5, 3],\n              se=0, custom_head=None)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nLSTM_FCNPlus\n\n LSTM_FCNPlus (c_in, c_out, seq_len=None, d=None, hidden_size=100,\n               rnn_layers=1, bias=True, cell_dropout=0, rnn_dropout=0.8,\n               bidirectional=False, shuffle=True, fc_dropout=0.0,\n               use_bn=False, conv_layers=[128, 256, 128], kss=[7, 5, 3],\n               se=0, custom_head=None)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nRNN_FCNPlus\n\n RNN_FCNPlus (c_in, c_out, seq_len=None, d=None, hidden_size=100,\n              rnn_layers=1, bias=True, cell_dropout=0, rnn_dropout=0.8,\n              bidirectional=False, shuffle=True, fc_dropout=0.0,\n              use_bn=False, conv_layers=[128, 256, 128], kss=[7, 5, 3],\n              se=0, custom_head=None)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom tsai.models.utils import count_parameters\nfrom tsai.models.RNN_FCN import *\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\ntest_eq(RNN_FCNPlus(n_vars, c_out, seq_len)(xb).shape, [bs, c_out])\ntest_eq(LSTM_FCNPlus(n_vars, c_out, seq_len)(xb).shape, [bs, c_out])\ntest_eq(MLSTM_FCNPlus(n_vars, c_out, seq_len)(xb).shape, [bs, c_out])\ntest_eq(GRU_FCNPlus(n_vars, c_out, shuffle=False)(xb).shape, [bs, c_out])\ntest_eq(GRU_FCNPlus(n_vars, c_out, seq_len, shuffle=False)(xb).shape, [bs, c_out])\ntest_eq(count_parameters(LSTM_FCNPlus(n_vars, c_out, seq_len)), count_parameters(LSTM_FCN(n_vars, c_out, seq_len)))\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\ncustom_head = nn.Linear(228, c_out)\ntest_eq(RNN_FCNPlus(n_vars, c_out, seq_len, custom_head=custom_head)(xb).shape, [bs, c_out])\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nd = 10\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\ntest_eq(RNN_FCNPlus(n_vars, c_out, seq_len, d=d)(xb).shape, [bs, d, c_out])\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nd = (5, 3)\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\ntest_eq(RNN_FCNPlus(n_vars, c_out, seq_len, d=d)(xb).shape, [bs, *d, c_out])\n\n\nLSTM_FCNPlus(n_vars, seq_len, c_out, se=8)\n\nLSTM_FCNPlus(\n  (backbone): _RNN_FCN_Base_Backbone(\n    (rnn): LSTM(2, 100, batch_first=True)\n    (rnn_dropout): Dropout(p=0.8, inplace=False)\n    (convblock1): ConvBlock(\n      (0): Conv1d(3, 128, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (se1): SqueezeExciteBlock(\n      (avg_pool): GAP1d(\n        (gap): AdaptiveAvgPool1d(output_size=1)\n        (flatten): Reshape(bs)\n      )\n      (fc): Sequential(\n        (0): Linear(in_features=128, out_features=16, bias=False)\n        (1): ReLU()\n        (2): Linear(in_features=16, out_features=128, bias=False)\n        (3): Sigmoid()\n      )\n    )\n    (convblock2): ConvBlock(\n      (0): Conv1d(128, 256, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n      (1): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (se2): SqueezeExciteBlock(\n      (avg_pool): GAP1d(\n        (gap): AdaptiveAvgPool1d(output_size=1)\n        (flatten): Reshape(bs)\n      )\n      (fc): Sequential(\n        (0): Linear(in_features=256, out_features=32, bias=False)\n        (1): ReLU()\n        (2): Linear(in_features=32, out_features=256, bias=False)\n        (3): Sigmoid()\n      )\n    )\n    (convblock3): ConvBlock(\n      (0): Conv1d(256, 128, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (gap): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Reshape(bs)\n    )\n    (concat): Concat(dim=1)\n  )\n  (head): Sequential(\n    (0): Linear(in_features=228, out_features=12, bias=True)\n  )\n)",
    "crumbs": [
      "Models",
      "Hybrid models",
      "RNN_FCNPlus"
    ]
  },
  {
    "objectID": "models.rnn.html",
    "href": "models.rnn.html",
    "title": "RNNs",
    "section": "",
    "text": "These are RNN, LSTM and GRU PyTorch implementations created by Ignacio Oguiza - oguiza@timeseriesAI.co\nsource",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNs"
    ]
  },
  {
    "objectID": "models.rnn.html#converting-a-model-to-torchscript",
    "href": "models.rnn.html#converting-a-model-to-torchscript",
    "title": "RNNs",
    "section": "Converting a model to TorchScript",
    "text": "Converting a model to TorchScript\n\nmodel = LSTM(c_in, c_out, hidden_size=100, n_layers=2, bidirectional=True, rnn_dropout=.5, fc_dropout=.5)\nmodel.eval()\ninp = torch.rand(1, c_in, 50)\noutput = model(inp)\nprint(output)\n\ntensor([[-0.0287, -0.0105]], grad_fn=&lt;AddmmBackward0&gt;)\n\n\n\nTracing\n\n# save to gpu, cpu or both\ntraced_cpu = torch.jit.trace(model.cpu(), inp)\nprint(traced_cpu)\ntorch.jit.save(traced_cpu, \"cpu.pt\")\n\n# load cpu or gpu model\ntraced_cpu = torch.jit.load(\"cpu.pt\")\ntest_eq(traced_cpu(inp), output)\n\n!rm \"cpu.pt\"\n\nLSTM(\n  original_name=LSTM\n  (rnn): LSTM(original_name=LSTM)\n  (dropout): Dropout(original_name=Dropout)\n  (fc): Linear(original_name=Linear)\n)\n\n\n\n\nScripting\n\n# save to gpu, cpu or both\nscripted_cpu = torch.jit.script(model.cpu())\nprint(scripted_cpu)\ntorch.jit.save(scripted_cpu, \"cpu.pt\")\n\n# load cpu or gpu model\nscripted_cpu = torch.jit.load(\"cpu.pt\")\ntest_eq(scripted_cpu(inp), output)\n\n!rm \"cpu.pt\"\n\nRecursiveScriptModule(\n  original_name=LSTM\n  (rnn): RecursiveScriptModule(original_name=LSTM)\n  (dropout): RecursiveScriptModule(original_name=Dropout)\n  (fc): RecursiveScriptModule(original_name=Linear)\n)",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNs"
    ]
  },
  {
    "objectID": "models.rnn.html#converting-a-model-to-onnx",
    "href": "models.rnn.html#converting-a-model-to-onnx",
    "title": "RNNs",
    "section": "Converting a model to ONNX",
    "text": "Converting a model to ONNX\nimport onnx\n\n# Export the model\ntorch.onnx.export(model.cpu(),               # model being run\n                  inp,                       # model input (or a tuple for multiple inputs)\n                  \"cpu.onnx\",                # where to save the model (can be a file or file-like object)\n                  export_params=True,        # store the trained parameter weights inside the model file\n                  verbose=False,\n                  opset_version=13,          # the ONNX version to export the model to\n                  do_constant_folding=True,  # whether to execute constant folding for optimization\n                  input_names = ['input'],   # the model's input names\n                  output_names = ['output'], # the model's output names\n                  dynamic_axes={\n                      'input'  : {0 : 'batch_size'}, \n                      'output' : {0 : 'batch_size'}} # variable length axes\n                 )\n\n# Load the model and check it's ok\nonnx_model = onnx.load(\"cpu.onnx\")\nonnx.checker.check_model(onnx_model)\n\n# You can ignore the WARNINGS below\nimport onnxruntime as ort\n\nort_sess = ort.InferenceSession('cpu.onnx')\nout = ort_sess.run(None, {'input': inp.numpy()})\n\n# input & output names\ninput_name = ort_sess.get_inputs()[0].name\noutput_name = ort_sess.get_outputs()[0].name\n\n# input dimensions\ninput_dims = ort_sess.get_inputs()[0].shape\nprint(input_name, output_name, input_dims)\n\ntest_close(out, output.detach().numpy())\n!rm \"cpu.onnx\"",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNs"
    ]
  },
  {
    "objectID": "models.minirocket.html",
    "href": "models.minirocket.html",
    "title": "MINIROCKET",
    "section": "",
    "text": "A Very Fast (Almost) Deterministic Transform for Time Series Classification.\n\n\nsource\n\nMiniRocketClassifier\n\n MiniRocketClassifier (num_features=10000, max_dilations_per_kernel=32,\n                       random_state=None, alphas=array([1.e-03, 1.e-02,\n                       1.e-01, 1.e+00, 1.e+01, 1.e+02, 1.e+03]),\n                       normalize_features=True, memory=None,\n                       verbose=False, scoring=None, class_weight=None,\n                       **kwargs)\n\nTime series classification using MINIROCKET features and a linear classifier\n\nsource\n\n\nload_minirocket\n\n load_minirocket (fname, path='./models')\n\n\nsource\n\n\nMiniRocketRegressor\n\n MiniRocketRegressor (num_features=10000, max_dilations_per_kernel=32,\n                      random_state=None, alphas=array([1.e-03, 1.e-02,\n                      1.e-01, 1.e+00, 1.e+01, 1.e+02, 1.e+03]),\n                      normalize_features=True, memory=None, verbose=False,\n                      scoring=None, **kwargs)\n\nTime series regression using MINIROCKET features and a linear regressor\n\nsource\n\n\nload_minirocket\n\n load_minirocket (fname, path='./models')\n\n\nsource\n\n\nMiniRocketVotingClassifier\n\n MiniRocketVotingClassifier (n_estimators=5, weights=None, n_jobs=-1,\n                             num_features=10000,\n                             max_dilations_per_kernel=32,\n                             random_state=None, alphas=array([1.e-03,\n                             1.e-02, 1.e-01, 1.e+00, 1.e+01, 1.e+02,\n                             1.e+03]), normalize_features=True,\n                             memory=None, verbose=False, scoring=None,\n                             class_weight=None, **kwargs)\n\nTime series classification ensemble using MINIROCKET features, a linear classifier and majority voting\n\nsource\n\n\nget_minirocket_preds\n\n get_minirocket_preds (X, fname, path='./models', model=None)\n\n\nsource\n\n\nMiniRocketVotingRegressor\n\n MiniRocketVotingRegressor (n_estimators=5, weights=None, n_jobs=-1,\n                            num_features=10000,\n                            max_dilations_per_kernel=32,\n                            random_state=None, alphas=array([1.e-03,\n                            1.e-02, 1.e-01, 1.e+00, 1.e+01, 1.e+02,\n                            1.e+03]), normalize_features=True,\n                            memory=None, verbose=False, scoring=None,\n                            **kwargs)\n\nTime series regression ensemble using MINIROCKET features, a linear regressor and a voting regressor\n\n# Univariate classification with sklearn-type API\ndsid = 'OliveOil'\nfname = 'MiniRocketClassifier'\nX_train, y_train, X_test, y_test = get_UCR_data(dsid)\ncls = MiniRocketClassifier()\ncls.fit(X_train, y_train)\ncls.save(fname)\npred = cls.score(X_test, y_test)\ndel cls\ncls = load_minirocket(fname)\ntest_eq(cls.score(X_test, y_test), pred)\n\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n\n\n\n# Multivariate classification with sklearn-type API\ndsid = 'NATOPS'\nX_train, y_train, X_test, y_test = get_UCR_data(dsid)\ncls = MiniRocketClassifier()\ncls.fit(X_train, y_train)\ncls.score(X_test, y_test)\n\n0.9277777777777778\n\n\n\n# Multivariate classification with sklearn-type API\ndsid = 'NATOPS'\nX_train, y_train, X_test, y_test = get_UCR_data(dsid)\ncls = MiniRocketVotingClassifier(5)\ncls.fit(X_train, y_train)\ncls.score(X_test, y_test)\n\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n\n\n0.9166666666666666\n\n\n\nfrom sklearn.metrics import mean_squared_error\n\n\n# Univariate regression with sklearn-type API\ndsid = 'Covid3Month'\nfname = 'MiniRocketRegressor'\nX_train, y_train, X_test, y_test = get_Monash_regression_data(dsid)\nif X_train is not None:\n    rmse_scorer = make_scorer(mean_squared_error, greater_is_better=False)\n    reg = MiniRocketRegressor(scoring=rmse_scorer)\n    reg.fit(X_train, y_train)\n    reg.save(fname)\n    del reg\n    reg = load_minirocket(fname)\n    y_pred = reg.predict(X_test)\n    print(mean_squared_error(y_test, y_pred, squared=False))\n\n0.04099244037606886\n\n\n\n# Multivariate regression with sklearn-type API\ndsid = 'AppliancesEnergy'\nX_train, y_train, X_test, y_test = get_Monash_regression_data(dsid)\nif X_train is not None:\n    rmse_scorer = make_scorer(mean_squared_error, greater_is_better=False)\n    reg = MiniRocketRegressor(scoring=rmse_scorer)\n    reg.fit(X_train, y_train)\n    reg.save(fname)\n    del reg\n    reg = load_minirocket(fname)\n    y_pred = reg.predict(X_test)\n    print(mean_squared_error(y_test, y_pred, squared=False))\n\n2.2938026879322577\n\n\n\n# Multivariate regression ensemble with sklearn-type API\nif X_train is not None:\n    reg = MiniRocketVotingRegressor(5, scoring=rmse_scorer)\n    reg.fit(X_train, y_train)\n    y_pred = reg.predict(X_test)\n    print(mean_squared_error(y_test, y_pred, squared=False))\n\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n\n\n2.286295546348893",
    "crumbs": [
      "Models",
      "ROCKETs",
      "MINIROCKET"
    ]
  },
  {
    "objectID": "models.tsperceiver.html",
    "href": "models.tsperceiver.html",
    "title": "TSPerceiver",
    "section": "",
    "text": "This implementation is inspired by:\nJaegle, A., Gimeno, F., Brock, A., Zisserman, A., Vinyals, O., & Carreira, J. (2021).\nPerceiver: General Perception with Iterative Attention. arXiv preprint arXiv:2103.03206.\nPaper: https://arxiv.org/pdf/2103.03206.pdf\nOfficial repo: Not available as og April, 2021.\n\nsource\n\nTSPerceiver\n\n TSPerceiver (c_in, c_out, seq_len, cat_szs=0, n_cont=0, n_latents=512,\n              d_latent=128, d_context=None, n_layers=6,\n              self_per_cross_attn=1, share_weights=True, cross_n_heads=1,\n              self_n_heads=8, d_head=None, attn_dropout=0.0,\n              fc_dropout=0.0, concat_pool=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.basics import *\nfrom tsai.data.all import *\n\n\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, split_data=False)\nts_features_df = get_ts_features(X, y)\nts_features_df.shape\n\nFeature Extraction: 100%|██████████████████████████████████████████| 30/30 [00:00&lt;00:00, 189.16it/s]\n\n\n(60, 11)\n\n\n\n# raw ts\ntfms  = [None, [Categorize()]]\nbatch_tfms = TSStandardize(by_sample=True)\nts_dls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\n\n# ts features\ncat_names = None\ncont_names = ts_features_df.columns[:-2]\ny_names = 'target'\ntab_dls = get_tabular_dls(ts_features_df, cat_names=cat_names, cont_names=cont_names, y_names=y_names, splits=splits)\n\n# mixed\nmixed_dls = get_mixed_dls(ts_dls, tab_dls)\nxb, yb = mixed_dls.one_batch()\n\n\nmodel = TSPerceiver(ts_dls.vars, ts_dls.c, ts_dls.len, cat_szs=0, \n                    # n_cont=0, \n                    n_cont=xb[1][1].shape[1], \n                    n_latents=128, d_latent=128, n_layers=3, self_per_cross_attn=1, share_weights=True,\n                    cross_n_heads=16, self_n_heads=16, d_head=None, attn_dropout=0., fc_dropout=0.).to(device)\ntest_eq(model(xb).shape, (yb.shape[0], len(np.unique(y))))",
    "crumbs": [
      "Models",
      "Transformers",
      "TSPerceiver"
    ]
  },
  {
    "objectID": "models.rocket_pytorch.html",
    "href": "models.rocket_pytorch.html",
    "title": "ROCKET Pytorch",
    "section": "",
    "text": "ROCKET (RandOm Convolutional KErnel Transform) functions for univariate and multivariate time series developed in Pytorch.\n\n\nsource\n\nROCKET\n\n ROCKET (c_in, seq_len, n_kernels=10000, kss=[7, 9, 11], device=None,\n         verbose=False)\n\n*RandOm Convolutional KErnel Transform\nROCKET is a GPU Pytorch implementation of the ROCKET functions generate_kernels and apply_kernels that can be used with univariate and multivariate time series.*\n\nsource\n\n\ncreate_rocket_features\n\n create_rocket_features (dl, model, verbose=False)\n\nArgs: model : ROCKET model instance dl : single TSDataLoader (for example dls.train or dls.valid)\n\nbs = 16\nc_in = 7  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 15\nxb = torch.randn(bs, c_in, seq_len).to(default_device())\n\nm = ROCKET(c_in, seq_len, n_kernels=1_000, kss=[7, 9, 11]) # 1_000 for testing with a cpu. Default is 10k with a gpu!\ntest_eq(m(xb).shape, [bs, 2_000])\n\n\nfrom tsai.data.all import *\nfrom tsai.models.utils import *\n\n\nX, y, splits = get_UCR_data('OliveOil', split_data=False)\ntfms = [None, TSRegression()]\nbatch_tfms = TSStandardize(by_var=True)\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, shuffle_train=False, drop_last=False)\nmodel = build_ts_model(ROCKET, dls=dls, n_kernels=1_000) # 1_000 for testing with a cpu. Default is 10k with a gpu!\nX_train, y_train = create_rocket_features(dls.train, model) \nX_valid, y_valid = create_rocket_features(dls.valid, model)\nX_train.shape, X_valid.shape\n\n((30, 2000), (30, 2000))",
    "crumbs": [
      "Models",
      "ROCKETs",
      "ROCKET Pytorch"
    ]
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "Metrics",
    "section": "",
    "text": "Metrics not included in fastai.\n\n\nsource\n\nMatthewsCorrCoefBinary\n\n MatthewsCorrCoefBinary (sample_weight=None)\n\nMatthews correlation coefficient for single-label classification problems\n\nsource\n\n\nget_task_metrics\n\n get_task_metrics (dls, binary_metrics=None, multi_class_metrics=None,\n                   regression_metrics=None, verbose=True)\n\nAll metrics applicable to multi classification have been created by Doug Williams (https://github.com/williamsdoug). Thanks a lot Doug!!\n\nsource\n\n\nF1_multi\n\n F1_multi (*args, **kwargs)\n\n\nsource\n\n\nFbeta_multi\n\n Fbeta_multi (inp, targ, beta=1.0, thresh=0.5, sigmoid=True)\n\nComputes Fbeta when inp and targ are the same size.\n\nsource\n\n\nbalanced_accuracy_multi\n\n balanced_accuracy_multi (inp, targ, thresh=0.5, sigmoid=True)\n\nComputes balanced accuracy when inp and targ are the same size.\n\nsource\n\n\nspecificity_multi\n\n specificity_multi (inp, targ, thresh=0.5, sigmoid=True)\n\nComputes specificity (true negative rate) when inp and targ are the same size.\n\nsource\n\n\nrecall_multi\n\n recall_multi (inp, targ, thresh=0.5, sigmoid=True)\n\nComputes recall when inp and targ are the same size.\n\nsource\n\n\nprecision_multi\n\n precision_multi (inp, targ, thresh=0.5, sigmoid=True)\n\nComputes precision when inp and targ are the same size.\n\nsource\n\n\nmetrics_multi_common\n\n metrics_multi_common (inp, targ, thresh=0.5, sigmoid=True,\n                       by_sample=False)\n\nComputes TP, TN, FP, FN when inp and targ are the same size.\n\nsource\n\n\naccuracy_multi\n\n accuracy_multi (inp, targ, thresh=0.5, sigmoid=True, by_sample=False)\n\nComputes accuracy when inp and targ are the same size.\n\nsource\n\n\nmae\n\n mae (inp, targ)\n\nMean absolute error between inp and targ.\n\nsource\n\n\nmape\n\n mape (inp, targ)\n\nMean absolute percentage error between inp and targ.\n\nn_classes = 4\ninp = torch.normal(0, 1, (16, 20, n_classes))\ntarg = torch.randint(0, n_classes, (16, 20)).to(torch.int8)\n_mAP(inp, targ)\n\n0.27493315845795063",
    "crumbs": [
      "Training",
      "Metrics"
    ]
  },
  {
    "objectID": "models.gmlp.html",
    "href": "models.gmlp.html",
    "title": "gMLP",
    "section": "",
    "text": "This is an unofficial PyTorch implementation based on:\n\nLiu, H., Dai, Z., So, D. R., & Le, Q. V. (2021). Pay Attention to MLPs. arXiv preprint arXiv:2105.08050.\nCholakov, R., & Kolev, T. (2022). The GatedTabTransformer. An enhanced deep learning architecture for tabular modeling. arXiv preprint arXiv:2201.00199.\n\n\nsource\n\ngMLP\n\n gMLP (c_in, c_out, seq_len, patch_size=1, d_model=256, d_ffn=512,\n       depth=6)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nbs = 16\nc_in = 3\nc_out = 2\nseq_len = 64\npatch_size = 4\nxb = torch.rand(bs, c_in, seq_len)\nmodel = gMLP(c_in, c_out, seq_len, patch_size=patch_size)\ntest_eq(model(xb).shape, (bs, c_out))",
    "crumbs": [
      "Models",
      "MLPs",
      "gMLP"
    ]
  },
  {
    "objectID": "models.xresnet1dplus.html",
    "href": "models.xresnet1dplus.html",
    "title": "XResNet1dPlus",
    "section": "",
    "text": "This is a modified version of fastai’s XResNet model in github\n\n\nsource\n\nXResNet1dPlus\n\n XResNet1dPlus (block=&lt;class 'tsai.models.layers.ResBlock1dPlus'&gt;,\n                expansion=4, layers=[3, 4, 6, 3], fc_dropout=0.0, c_in=3,\n                c_out=None, n_out=1000, seq_len=None, stem_szs=(32, 32,\n                64), widen=1.0, sa=False, act_cls=&lt;class\n                'torch.nn.modules.activation.ReLU'&gt;, ks=3, stride=2,\n                coord=False, custom_head=None, block_szs_base=(64, 128,\n                256, 512), groups=1, reduction=None, nh1=None, nh2=None,\n                dw=False, g2=1, sym=False, norm='Batch', zero_norm=True,\n                pool=&lt;function AvgPool&gt;, pool_first=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nxresnet1d50_deeperplus\n\n xresnet1d50_deeperplus (c_in, c_out, seq_len=None, act=&lt;class\n                         'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                         groups=1, reduction=None, nh1=None, nh2=None,\n                         dw=False, g2=1, sa=False, sym=False,\n                         norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                         'torch.nn.modules.activation.ReLU'&gt;, ndim=2,\n                         ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                         padding=None, bias=None, bn_1st=True,\n                         transpose=False, init='auto', xtra=None,\n                         bias_std=0.01,\n                         dilation:Union[int,tuple[int,int]]=1,\n                         padding_mode:str='zeros', device=None,\n                         dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d34_deeperplus\n\n xresnet1d34_deeperplus (c_in, c_out, seq_len=None, act=&lt;class\n                         'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                         groups=1, reduction=None, nh1=None, nh2=None,\n                         dw=False, g2=1, sa=False, sym=False,\n                         norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                         'torch.nn.modules.activation.ReLU'&gt;, ndim=2,\n                         ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                         padding=None, bias=None, bn_1st=True,\n                         transpose=False, init='auto', xtra=None,\n                         bias_std=0.01,\n                         dilation:Union[int,tuple[int,int]]=1,\n                         padding_mode:str='zeros', device=None,\n                         dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d18_deeperplus\n\n xresnet1d18_deeperplus (c_in, c_out, seq_len=None, act=&lt;class\n                         'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                         groups=1, reduction=None, nh1=None, nh2=None,\n                         dw=False, g2=1, sa=False, sym=False,\n                         norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                         'torch.nn.modules.activation.ReLU'&gt;, ndim=2,\n                         ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                         padding=None, bias=None, bn_1st=True,\n                         transpose=False, init='auto', xtra=None,\n                         bias_std=0.01,\n                         dilation:Union[int,tuple[int,int]]=1,\n                         padding_mode:str='zeros', device=None,\n                         dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d50_deepplus\n\n xresnet1d50_deepplus (c_in, c_out, seq_len=None, act=&lt;class\n                       'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                       groups=1, reduction=None, nh1=None, nh2=None,\n                       dw=False, g2=1, sa=False, sym=False,\n                       norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                       'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n                       pool=&lt;function AvgPool&gt;, pool_first=True,\n                       padding=None, bias=None, bn_1st=True,\n                       transpose=False, init='auto', xtra=None,\n                       bias_std=0.01,\n                       dilation:Union[int,tuple[int,int]]=1,\n                       padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d34_deepplus\n\n xresnet1d34_deepplus (c_in, c_out, seq_len=None, act=&lt;class\n                       'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                       groups=1, reduction=None, nh1=None, nh2=None,\n                       dw=False, g2=1, sa=False, sym=False,\n                       norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                       'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n                       pool=&lt;function AvgPool&gt;, pool_first=True,\n                       padding=None, bias=None, bn_1st=True,\n                       transpose=False, init='auto', xtra=None,\n                       bias_std=0.01,\n                       dilation:Union[int,tuple[int,int]]=1,\n                       padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d18_deepplus\n\n xresnet1d18_deepplus (c_in, c_out, seq_len=None, act=&lt;class\n                       'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                       groups=1, reduction=None, nh1=None, nh2=None,\n                       dw=False, g2=1, sa=False, sym=False,\n                       norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                       'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n                       pool=&lt;function AvgPool&gt;, pool_first=True,\n                       padding=None, bias=None, bn_1st=True,\n                       transpose=False, init='auto', xtra=None,\n                       bias_std=0.01,\n                       dilation:Union[int,tuple[int,int]]=1,\n                       padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d152plus\n\n xresnet1d152plus (c_in, c_out, seq_len=None, act=&lt;class\n                   'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                   groups=1, reduction=None, nh1=None, nh2=None, dw=False,\n                   g2=1, sa=False, sym=False, norm_type=&lt;NormType.Batch:\n                   1&gt;, act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                   ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                   padding=None, bias=None, bn_1st=True, transpose=False,\n                   init='auto', xtra=None, bias_std=0.01,\n                   dilation:Union[int,tuple[int,int]]=1,\n                   padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d101plus\n\n xresnet1d101plus (c_in, c_out, seq_len=None, act=&lt;class\n                   'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                   groups=1, reduction=None, nh1=None, nh2=None, dw=False,\n                   g2=1, sa=False, sym=False, norm_type=&lt;NormType.Batch:\n                   1&gt;, act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                   ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                   padding=None, bias=None, bn_1st=True, transpose=False,\n                   init='auto', xtra=None, bias_std=0.01,\n                   dilation:Union[int,tuple[int,int]]=1,\n                   padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d50plus\n\n xresnet1d50plus (c_in, c_out, seq_len=None, act=&lt;class\n                  'torch.nn.modules.activation.ReLU'&gt;, stride=1, groups=1,\n                  reduction=None, nh1=None, nh2=None, dw=False, g2=1,\n                  sa=False, sym=False, norm_type=&lt;NormType.Batch: 1&gt;,\n                  act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                  ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                  padding=None, bias=None, bn_1st=True, transpose=False,\n                  init='auto', xtra=None, bias_std=0.01,\n                  dilation:Union[int,tuple[int,int]]=1,\n                  padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d34plus\n\n xresnet1d34plus (c_in, c_out, seq_len=None, act=&lt;class\n                  'torch.nn.modules.activation.ReLU'&gt;, stride=1, groups=1,\n                  reduction=None, nh1=None, nh2=None, dw=False, g2=1,\n                  sa=False, sym=False, norm_type=&lt;NormType.Batch: 1&gt;,\n                  act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                  ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                  padding=None, bias=None, bn_1st=True, transpose=False,\n                  init='auto', xtra=None, bias_std=0.01,\n                  dilation:Union[int,tuple[int,int]]=1,\n                  padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d18plus\n\n xresnet1d18plus (c_in, c_out, seq_len=None, act=&lt;class\n                  'torch.nn.modules.activation.ReLU'&gt;, stride=1, groups=1,\n                  reduction=None, nh1=None, nh2=None, dw=False, g2=1,\n                  sa=False, sym=False, norm_type=&lt;NormType.Batch: 1&gt;,\n                  act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                  ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                  padding=None, bias=None, bn_1st=True, transpose=False,\n                  init='auto', xtra=None, bias_std=0.01,\n                  dilation:Union[int,tuple[int,int]]=1,\n                  padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nseq_len\nNoneType\nNone\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nnet = xresnet1d18plus(3, 2, coord=True)\nx = torch.rand(32, 3, 50)\nnet(x)\n\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [2, 2, 2, 2]\n\n\nTensorBase([[ 0.1829,  0.3597],\n            [ 0.0274, -0.1443],\n            [ 0.0240, -0.2374],\n            [-0.1323, -0.6574],\n            [ 0.1481, -0.1438],\n            [ 0.2410, -0.1225],\n            [-0.1186, -0.1978],\n            [-0.0640, -0.4547],\n            [-0.0229, -0.3214],\n            [ 0.2336, -0.4466],\n            [-0.1843, -0.0934],\n            [-0.0416,  0.1997],\n            [-0.0109, -0.0253],\n            [ 0.3014, -0.2193],\n            [ 0.0966,  0.0602],\n            [ 0.2364,  0.2209],\n            [-0.1437, -0.1476],\n            [ 0.0070, -0.2900],\n            [ 0.2807,  0.4797],\n            [-0.2386, -0.1563],\n            [ 0.1620, -0.2285],\n            [ 0.0479, -0.2348],\n            [ 0.1573, -0.4420],\n            [-0.5469,  0.1512],\n            [ 0.0243, -0.1806],\n            [ 0.3396,  0.1434],\n            [ 0.0666, -0.1644],\n            [ 0.3286, -0.5637],\n            [ 0.0993, -0.6281],\n            [-0.1068, -0.0763],\n            [-0.2713,  0.1946],\n            [-0.1416, -0.4043]], grad_fn=&lt;AliasBackward0&gt;)\n\n\n\nbs, c_in, seq_len = 2, 4, 32\nc_out = 2\nx = torch.rand(bs, c_in, seq_len)\narchs = [\n    xresnet1d18plus, xresnet1d34plus, xresnet1d50plus, \n    xresnet1d18_deepplus, xresnet1d34_deepplus, xresnet1d50_deepplus, xresnet1d18_deeperplus,\n    xresnet1d34_deeperplus, xresnet1d50_deeperplus\n#     # Long test\n#     xresnet1d101, xresnet1d152,\n]\nfor i, arch in enumerate(archs):\n    print(i, arch.__name__)\n    test_eq(arch(c_in, c_out, sa=True, act=Mish, coord=True)(x).shape, (bs, c_out))\n\n0 xresnet1d18plus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [2, 2, 2, 2]\n1 xresnet1d34plus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [3, 4, 6, 3]\n2 xresnet1d50plus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 4 layers [3, 4, 6, 3]\n3 xresnet1d18_deepplus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [2, 2, 2, 2, 1, 1]\n4 xresnet1d34_deepplus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [3, 4, 6, 3, 1, 1]\n5 xresnet1d50_deepplus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 4 layers [3, 4, 6, 3, 1, 1]\n6 xresnet1d18_deeperplus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [2, 2, 1, 1, 1, 1, 1, 1]\n7 xresnet1d34_deeperplus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [3, 4, 6, 3, 1, 1, 1, 1]\n8 xresnet1d50_deeperplus\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 4 layers [3, 4, 6, 3, 1, 1, 1, 1]\n\n\n\nm = xresnet1d34plus(4, 2, act=Mish)\ntest_eq(len(get_layers(m, is_bn)), 38)\ntest_eq(check_weight(m, is_bn)[0].sum(), 22)\n\nblock &lt;class 'tsai.models.layers.ResBlock1dPlus'&gt; expansion 1 layers [3, 4, 6, 3]",
    "crumbs": [
      "Models",
      "CNNs",
      "XResNet1dPlus"
    ]
  },
  {
    "objectID": "models.xresnet1d.html",
    "href": "models.xresnet1d.html",
    "title": "XResNet1d",
    "section": "",
    "text": "This is a modified version of fastai’s XResNet model in github\n\n\nsource\n\nxresnet1d50_deeper\n\n xresnet1d50_deeper (c_in, c_out, act=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                     groups=1, reduction=None, nh1=None, nh2=None,\n                     dw=False, g2=1, sa=False, sym=False,\n                     norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n                     pool=&lt;function AvgPool&gt;, pool_first=True,\n                     padding=None, bias=None, bn_1st=True,\n                     transpose=False, init='auto', xtra=None,\n                     bias_std=0.01, dilation:Union[int,tuple[int,int]]=1,\n                     padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d34_deeper\n\n xresnet1d34_deeper (c_in, c_out, act=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                     groups=1, reduction=None, nh1=None, nh2=None,\n                     dw=False, g2=1, sa=False, sym=False,\n                     norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n                     pool=&lt;function AvgPool&gt;, pool_first=True,\n                     padding=None, bias=None, bn_1st=True,\n                     transpose=False, init='auto', xtra=None,\n                     bias_std=0.01, dilation:Union[int,tuple[int,int]]=1,\n                     padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d18_deeper\n\n xresnet1d18_deeper (c_in, c_out, act=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                     groups=1, reduction=None, nh1=None, nh2=None,\n                     dw=False, g2=1, sa=False, sym=False,\n                     norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n                     'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n                     pool=&lt;function AvgPool&gt;, pool_first=True,\n                     padding=None, bias=None, bn_1st=True,\n                     transpose=False, init='auto', xtra=None,\n                     bias_std=0.01, dilation:Union[int,tuple[int,int]]=1,\n                     padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d50_deep\n\n xresnet1d50_deep (c_in, c_out, act=&lt;class\n                   'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                   groups=1, reduction=None, nh1=None, nh2=None, dw=False,\n                   g2=1, sa=False, sym=False, norm_type=&lt;NormType.Batch:\n                   1&gt;, act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                   ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                   padding=None, bias=None, bn_1st=True, transpose=False,\n                   init='auto', xtra=None, bias_std=0.01,\n                   dilation:Union[int,tuple[int,int]]=1,\n                   padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d34_deep\n\n xresnet1d34_deep (c_in, c_out, act=&lt;class\n                   'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                   groups=1, reduction=None, nh1=None, nh2=None, dw=False,\n                   g2=1, sa=False, sym=False, norm_type=&lt;NormType.Batch:\n                   1&gt;, act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                   ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                   padding=None, bias=None, bn_1st=True, transpose=False,\n                   init='auto', xtra=None, bias_std=0.01,\n                   dilation:Union[int,tuple[int,int]]=1,\n                   padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d18_deep\n\n xresnet1d18_deep (c_in, c_out, act=&lt;class\n                   'torch.nn.modules.activation.ReLU'&gt;, stride=1,\n                   groups=1, reduction=None, nh1=None, nh2=None, dw=False,\n                   g2=1, sa=False, sym=False, norm_type=&lt;NormType.Batch:\n                   1&gt;, act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n                   ndim=2, ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n                   padding=None, bias=None, bn_1st=True, transpose=False,\n                   init='auto', xtra=None, bias_std=0.01,\n                   dilation:Union[int,tuple[int,int]]=1,\n                   padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d152\n\n xresnet1d152 (c_in, c_out, act=&lt;class\n               'torch.nn.modules.activation.ReLU'&gt;, stride=1, groups=1,\n               reduction=None, nh1=None, nh2=None, dw=False, g2=1,\n               sa=False, sym=False, norm_type=&lt;NormType.Batch: 1&gt;,\n               act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;, ndim=2,\n               ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n               padding=None, bias=None, bn_1st=True, transpose=False,\n               init='auto', xtra=None, bias_std=0.01,\n               dilation:Union[int,tuple[int,int]]=1,\n               padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d101\n\n xresnet1d101 (c_in, c_out, act=&lt;class\n               'torch.nn.modules.activation.ReLU'&gt;, stride=1, groups=1,\n               reduction=None, nh1=None, nh2=None, dw=False, g2=1,\n               sa=False, sym=False, norm_type=&lt;NormType.Batch: 1&gt;,\n               act_cls=&lt;class 'torch.nn.modules.activation.ReLU'&gt;, ndim=2,\n               ks=3, pool=&lt;function AvgPool&gt;, pool_first=True,\n               padding=None, bias=None, bn_1st=True, transpose=False,\n               init='auto', xtra=None, bias_std=0.01,\n               dilation:Union[int,tuple[int,int]]=1,\n               padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d50\n\n xresnet1d50 (c_in, c_out, act=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n              stride=1, groups=1, reduction=None, nh1=None, nh2=None,\n              dw=False, g2=1, sa=False, sym=False,\n              norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n              'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n              pool=&lt;function AvgPool&gt;, pool_first=True, padding=None,\n              bias=None, bn_1st=True, transpose=False, init='auto',\n              xtra=None, bias_std=0.01,\n              dilation:Union[int,tuple[int,int]]=1,\n              padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d34\n\n xresnet1d34 (c_in, c_out, act=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n              stride=1, groups=1, reduction=None, nh1=None, nh2=None,\n              dw=False, g2=1, sa=False, sym=False,\n              norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n              'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n              pool=&lt;function AvgPool&gt;, pool_first=True, padding=None,\n              bias=None, bn_1st=True, transpose=False, init='auto',\n              xtra=None, bias_std=0.01,\n              dilation:Union[int,tuple[int,int]]=1,\n              padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nxresnet1d18\n\n xresnet1d18 (c_in, c_out, act=&lt;class 'torch.nn.modules.activation.ReLU'&gt;,\n              stride=1, groups=1, reduction=None, nh1=None, nh2=None,\n              dw=False, g2=1, sa=False, sym=False,\n              norm_type=&lt;NormType.Batch: 1&gt;, act_cls=&lt;class\n              'torch.nn.modules.activation.ReLU'&gt;, ndim=2, ks=3,\n              pool=&lt;function AvgPool&gt;, pool_first=True, padding=None,\n              bias=None, bn_1st=True, transpose=False, init='auto',\n              xtra=None, bias_std=0.01,\n              dilation:Union[int,tuple[int,int]]=1,\n              padding_mode:str='zeros', device=None, dtype=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\n\n\n\n\n\nc_out\n\n\n\n\n\nact\ntype\nReLU\n\n\n\nstride\nint\n1\n\n\n\ngroups\nint\n1\n\n\n\nreduction\nNoneType\nNone\n\n\n\nnh1\nNoneType\nNone\n\n\n\nnh2\nNoneType\nNone\n\n\n\ndw\nbool\nFalse\n\n\n\ng2\nint\n1\n\n\n\nsa\nbool\nFalse\n\n\n\nsym\nbool\nFalse\n\n\n\nnorm_type\nNormType\nNormType.Batch\n\n\n\nact_cls\ntype\nReLU\n\n\n\nndim\nint\n2\n\n\n\nks\nint\n3\n\n\n\npool\nfunction\nAvgPool\n\n\n\npool_first\nbool\nTrue\n\n\n\npadding\nNoneType\nNone\n\n\n\nbias\nNoneType\nNone\n\n\n\nbn_1st\nbool\nTrue\n\n\n\ntranspose\nbool\nFalse\n\n\n\ninit\nstr\nauto\n\n\n\nxtra\nNoneType\nNone\n\n\n\nbias_std\nfloat\n0.01\n\n\n\ndilation\nUnion\n1\n\n\n\npadding_mode\nstr\nzeros\nTODO: refine this type\n\n\ndevice\nNoneType\nNone\n\n\n\ndtype\nNoneType\nNone\n\n\n\n\n\nbs, c_in, seq_len = 2, 4, 32\nc_out = 2\nx = torch.rand(bs, c_in, seq_len)\narchs = [\n    xresnet1d18, xresnet1d34, xresnet1d50, \n    xresnet1d18_deep, xresnet1d34_deep, xresnet1d50_deep, xresnet1d18_deeper,\n    xresnet1d34_deeper, xresnet1d50_deeper\n#     # Long test\n#     xresnet1d101, xresnet1d152,\n]\nfor i, arch in enumerate(archs):\n    print(i, arch.__name__)\n    test_eq(arch(c_in, c_out, sa=True, act=Mish)(x).shape, (bs, c_out))\n\n0 xresnet1d18\n1 xresnet1d34\n2 xresnet1d50\n3 xresnet1d18_deep\n4 xresnet1d34_deep\n5 xresnet1d50_deep\n6 xresnet1d18_deeper\n7 xresnet1d34_deeper\n8 xresnet1d50_deeper\n\n\n\nm = xresnet1d34(4, 2, act=Mish)\ntest_eq(len(get_layers(m, is_bn)), 38)\ntest_eq(check_weight(m, is_bn)[0].sum(), 22)",
    "crumbs": [
      "Models",
      "CNNs",
      "XResNet1d"
    ]
  },
  {
    "objectID": "losses.html",
    "href": "losses.html",
    "title": "Losses",
    "section": "",
    "text": "Losses not available in fastai or Pytorch.\n\n\nsource\n\nHuberLoss\n\n HuberLoss (reduction='mean', delta=1.0)\n\n*Huber loss\nCreates a criterion that uses a squared term if the absolute element-wise error falls below delta and a delta-scaled L1 term otherwise. This loss combines advantages of both :class:L1Loss and :class:MSELoss; the delta-scaled L1 region makes the loss less sensitive to outliers than :class:MSELoss, while the L2 region provides smoothness over :class:L1Loss near 0. See Huber loss &lt;https://en.wikipedia.org/wiki/Huber_loss&gt;_ for more information. This loss is equivalent to nn.SmoothL1Loss when delta == 1.*\n\nsource\n\n\nLogCoshLoss\n\n LogCoshLoss (reduction='mean', delta=1.0)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\ninp = torch.rand(8, 3, 10)\ntarg = torch.randn(8, 3, 10)\ntest_close(HuberLoss(delta=1)(inp, targ), nn.SmoothL1Loss()(inp, targ))\nLogCoshLoss()(inp, targ)\n\ntensor(0.4588)\n\n\n\nsource\n\n\nMaskedLossWrapper\n\n MaskedLossWrapper (crit)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\ninp = torch.rand(8, 3, 10)\ntarg = torch.randn(8, 3, 10)\ntarg[targ &gt;.8] = np.nan\nnn.L1Loss()(inp, targ), MaskedLossWrapper(nn.L1Loss())(inp, targ)\n\n(tensor(nan), tensor(1.0520))\n\n\n\nsource\n\n\nCenterPlusLoss\n\n CenterPlusLoss (loss, c_out, λ=0.01, logits_dim=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nCenterLoss\n\n CenterLoss (c_out, logits_dim=None)\n\n*Code in Pytorch has been slightly modified from: https://github.com/KaiyangZhou/pytorch-center-loss/blob/master/center_loss.py Based on paper: Wen et al. A Discriminative Feature Learning Approach for Deep Face Recognition. ECCV 2016.\nArgs: c_out (int): number of classes. logits_dim (int): dim 1 of the logits. By default same as c_out (for one hot encoded logits)*\n\nc_in = 10\nx = torch.rand(64, c_in).to(device=default_device())\nx = F.softmax(x, dim=1)\nlabel = x.max(dim=1).indices\nCenterLoss(c_in).to(x.device)(x, label), CenterPlusLoss(LabelSmoothingCrossEntropyFlat(), c_in).to(x.device)(x, label)\n\n(tensor(9.2481, grad_fn=&lt;DivBackward0&gt;),\n TensorBase(2.3559, grad_fn=&lt;AliasBackward0&gt;))\n\n\n\nCenterPlusLoss(LabelSmoothingCrossEntropyFlat(), c_in)\n\nCenterPlusLoss(loss=FlattenedLoss of LabelSmoothingCrossEntropy(), c_out=10, λ=0.01)\n\n\n\nsource\n\n\nFocalLoss\n\n FocalLoss (alpha:Optional[torch.Tensor]=None, gamma:float=2.0,\n            reduction:str='mean')\n\nWeighted, multiclass focal loss\n\ninputs = torch.normal(0, 2, (16, 2)).to(device=default_device())\ntargets = torch.randint(0, 2, (16,)).to(device=default_device())\nFocalLoss()(inputs, targets)\n\ntensor(0.9829)\n\n\n\nsource\n\n\nTweedieLoss\n\n TweedieLoss (p=1.5, eps=1e-08)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nc_in = 10\noutput = torch.rand(64).to(device=default_device())\ntarget = torch.rand(64).to(device=default_device())\nTweedieLoss().to(output.device)(output, target)\n\ntensor(3.0539)",
    "crumbs": [
      "Training",
      "Losses"
    ]
  },
  {
    "objectID": "models.minirocket_pytorch.html",
    "href": "models.minirocket_pytorch.html",
    "title": "MINIROCKET Pytorch",
    "section": "",
    "text": "A Very Fast (Almost) Deterministic Transform for Time Series Classification.\n\nThis is a Pytorch implementation of MiniRocket developed by Malcolm McLean and Ignacio Oguiza based on:\nDempster, A., Schmidt, D. F., & Webb, G. I. (2020). MINIROCKET: A Very Fast (Almost) Deterministic Transform for Time Series Classification. arXiv preprint arXiv:2012.08791.\nOriginal paper: https://arxiv.org/abs/2012.08791\nOriginal code: https://github.com/angus924/minirocket\n\nsource\n\nMiniRocketFeatures\n\n MiniRocketFeatures (c_in, seq_len, num_features=10000,\n                     max_dilations_per_kernel=32, random_state=None)\n\n*This is a Pytorch implementation of MiniRocket developed by Malcolm McLean and Ignacio Oguiza\nMiniRocket paper citation: @article{dempster_etal_2020, author = {Dempster, Angus and Schmidt, Daniel F and Webb, Geoffrey I}, title = {{MINIROCKET}: A Very Fast (Almost) Deterministic Transform for Time Series Classification}, year = {2020}, journal = {arXiv:2012.08791} } Original paper: https://arxiv.org/abs/2012.08791 Original code: https://github.com/angus924/minirocket*\n\nsource\n\n\nget_minirocket_features\n\n get_minirocket_features (o, model, chunksize=1024, use_cuda=None,\n                          to_np=True)\n\nFunction used to split a large dataset into chunks, avoiding OOM error.\n\nsource\n\n\nMiniRocketHead\n\n MiniRocketHead (c_in, c_out, seq_len=1, bn=True, fc_dropout=0.0)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nMiniRocket\n\n MiniRocket (c_in, c_out, seq_len, num_features=10000,\n             max_dilations_per_kernel=32, random_state=None, bn=True,\n             fc_dropout=0)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom tsai.imports import default_device\nfrom fastai.metrics import accuracy\nfrom fastai.callback.tracker import ReduceLROnPlateau\nfrom tsai.data.all import *\nfrom tsai.learner import *\n\n\n# Offline feature calculation\ndsid = 'ECGFiveDays'\nX, y, splits = get_UCR_data(dsid, split_data=False)\nmrf = MiniRocketFeatures(c_in=X.shape[1], seq_len=X.shape[2]).to(default_device())\nX_train = X[splits[0]]  # X_train may either be a np.ndarray or a torch.Tensor\nmrf.fit(X_train)\nX_tfm = get_minirocket_features(X, mrf)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize(by_var=True)\ndls = get_ts_dls(X_tfm, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=256)\nlearn = ts_learner(dls, MiniRocketHead, metrics=accuracy)\nlearn.fit(1, 1e-4, cbs=ReduceLROnPlateau(factor=0.5, min_lr=1e-8, patience=10))\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.693147\n0.530879\n0.752613\n00:00\n\n\n\n\n\n\n# Online feature calculation\ndsid = 'ECGFiveDays'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=256)\nlearn = ts_learner(dls, MiniRocket, metrics=accuracy)\nlearn.fit_one_cycle(1, 1e-2)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.693147\n0.713297\n0.502904\n00:06",
    "crumbs": [
      "Models",
      "ROCKETs",
      "MINIROCKET Pytorch"
    ]
  },
  {
    "objectID": "models.xcm.html",
    "href": "models.xcm.html",
    "title": "XCM",
    "section": "",
    "text": "An Explainable Convolutional Neural Network for Multivariate Time Series Classification\n\nThis is an unofficial PyTorch implementation of XCM created by Ignacio Oguiza (oguiza@timeseriesAI.co)\n\nsource\n\nXCM\n\n XCM (c_in:int, c_out:int, seq_len:Optional[int]=None, nf:int=128,\n      window_perc:float=1.0, flatten:bool=False, custom_head:&lt;built-\n      infunctioncallable&gt;=None, concat_pool:bool=False,\n      fc_dropout:float=0.0, bn:bool=False, y_range:tuple=None, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.data.basics import *\nfrom tsai.learner import *\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ntfms = [None, TSCategorize()]\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms)\nmodel =  XCM(dls.vars, dls.c, dls.len)\nlearn = ts_learner(dls, model, metrics=accuracy)\nxb, yb = dls.one_batch()\n\nbs, c_in, seq_len = xb.shape\nc_out = len(np.unique(yb.cpu().numpy()))\n\nmodel = XCM(c_in, c_out, seq_len, fc_dropout=.5)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = XCM(c_in, c_out, seq_len, concat_pool=True)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = XCM(c_in, c_out, seq_len)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel\n\nXCM(\n  (conv2dblock): Sequential(\n    (0): Unsqueeze(dim=1)\n    (1): Conv2dSame(\n      (conv2d_same): Conv2d(1, 128, kernel_size=(1, 51), stride=(1, 1))\n    )\n    (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (3): ReLU()\n  )\n  (conv2d1x1block): Sequential(\n    (0): Conv2d(128, 1, kernel_size=(1, 1), stride=(1, 1))\n    (1): ReLU()\n    (2): Squeeze(dim=1)\n  )\n  (conv1dblock): Sequential(\n    (0): Conv1d(24, 128, kernel_size=(51,), stride=(1,), padding=(25,))\n    (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (conv1d1x1block): Sequential(\n    (0): Conv1d(128, 1, kernel_size=(1,), stride=(1,))\n    (1): ReLU()\n  )\n  (concat): Concat(dim=1)\n  (conv1d): Sequential(\n    (0): Conv1d(25, 128, kernel_size=(51,), stride=(1,), padding=(25,))\n    (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (head): Sequential(\n    (0): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Reshape(bs)\n    )\n    (1): LinBnDrop(\n      (0): Linear(in_features=128, out_features=6, bias=True)\n    )\n  )\n)\n\n\n\nmodel.show_gradcam(xb, yb)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel.show_gradcam(xb[0], yb[0])\n\n[W NNPACK.cpp:53] Could not initialize NNPACK! Reason: Unsupported hardware.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 10\nxb = torch.rand(bs, n_vars, seq_len)\nnew_head = partial(conv_lin_nd_head, d=(5, 2))\nnet = XCM(n_vars, c_out, seq_len, custom_head=new_head)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([16, 5, 2, 10])\n\n\ncreate_conv_lin_nd_head(\n  (0): Conv1d(128, 10, kernel_size=(1,), stride=(1,))\n  (1): Linear(in_features=12, out_features=10, bias=True)\n  (2): Transpose(-1, -2)\n  (3): Reshape(bs, 5, 2, 10)\n)\n\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\nnet = XCM(n_vars, c_out, seq_len)\nchange_model_head(net, create_pool_plus_head, concat_pool=False)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([16, 2])\n\n\nSequential(\n  (0): AdaptiveAvgPool1d(output_size=1)\n  (1): Reshape(bs)\n  (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (3): Linear(in_features=128, out_features=512, bias=False)\n  (4): ReLU(inplace=True)\n  (5): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (6): Linear(in_features=512, out_features=2, bias=False)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "XCM"
    ]
  },
  {
    "objectID": "models.transformerrnnplus.html",
    "href": "models.transformerrnnplus.html",
    "title": "TransformerRNNPlus",
    "section": "",
    "text": "These is a Pytorch implementation of a Transformer + RNN created by Ignacio Oguiza - oguiza@timeseriesAI.co inspired by the code created by Baurzhan Urazalinov (https://www.kaggle.com/baurzhanurazalinov).\nBaurzhan Urazalinov won a Kaggle competition (Parkinson’s Freezing of Gait Prediction: Event detection from wearable sensor data - 2023) using the following original tensorflow code:\n\nhttps://www.kaggle.com/code/baurzhanurazalinov/parkinson-s-freezing-defog-training-code\nhttps://www.kaggle.com/code/baurzhanurazalinov/parkinson-s-freezing-tdcsfog-training-code\nhttps://www.kaggle.com/code/baurzhanurazalinov/parkinson-s-freezing-submission-code\n\nI’d like to congratulate Baurzhan for winning this competition, and for sharing the code he used.\n\nfrom tsai.models.utils import count_parameters\n\n\nt = torch.rand(4, 864, 54)\nencoder_layer = torch.nn.TransformerEncoderLayer(54, 6, dim_feedforward=2048, dropout=0.1, \n                                                 activation=\"relu\", layer_norm_eps=1e-05, \n                                                 batch_first=True, norm_first=False)\nprint(encoder_layer(t).shape)\nprint(count_parameters(encoder_layer))\n\ntorch.Size([4, 864, 54])\n235382\n\n\n\nbs = 4\nc_in = 5\nseq_len = 50\n\nencoder = _TransformerRNNEncoder(nn.LSTM, c_in=c_in, seq_len=seq_len, d_model=128, nhead=4, num_encoder_layers=1, dim_feedforward=None, proj_dropout=0.1, dropout=0.1, num_rnn_layers=3, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nprint(encoder(t).shape)\n\ntorch.Size([4, 1024, 50])\n\n\n\nsource\n\nTransformerGRUPlus\n\n TransformerGRUPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                     d_model:int=128, nhead:int=16,\n                     proj_dropout:float=0.1, num_encoder_layers:int=1,\n                     dim_feedforward:int=2048, dropout:float=0.1,\n                     num_rnn_layers:int=1, bidirectional:bool=True,\n                     custom_head=None, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nNumber of channels in the input tensor.\n\n\nc_out\nint\n\nNumber of output channels.\n\n\nseq_len\nint\n\nNumber of time steps in the input tensor.\n\n\nd\ntuple\nNone\nint or tuple with shape of the output tensor\n\n\nd_model\nint\n128\nTotal dimension of the model.\n\n\nnhead\nint\n16\nNumber of parallel attention heads (d_model will be split across nhead - each head will have dimension d_model // nhead).\n\n\nproj_dropout\nfloat\n0.1\nDropout probability after the first linear layer. Default: 0.1.\n\n\nnum_encoder_layers\nint\n1\nNumber of transformer encoder layers. Default: 1.\n\n\ndim_feedforward\nint\n2048\nThe dimension of the feedforward network model. Default: 2048.\n\n\ndropout\nfloat\n0.1\nTransformer encoder layers dropout. Default: 0.1.\n\n\nnum_rnn_layers\nint\n1\nNumber of RNN layers in the encoder. Default: 1.\n\n\nbidirectional\nbool\nTrue\nIf True, becomes a bidirectional RNN. Default: True.\n\n\ncustom_head\nNoneType\nNone\nCustom head that will be applied to the model. If None, a head with c_out outputs will be used. Default: None.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nsource\n\n\nTransformerLSTMPlus\n\n TransformerLSTMPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                      d_model:int=128, nhead:int=16,\n                      proj_dropout:float=0.1, num_encoder_layers:int=1,\n                      dim_feedforward:int=2048, dropout:float=0.1,\n                      num_rnn_layers:int=1, bidirectional:bool=True,\n                      custom_head=None, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nNumber of channels in the input tensor.\n\n\nc_out\nint\n\nNumber of output channels.\n\n\nseq_len\nint\n\nNumber of time steps in the input tensor.\n\n\nd\ntuple\nNone\nint or tuple with shape of the output tensor\n\n\nd_model\nint\n128\nTotal dimension of the model.\n\n\nnhead\nint\n16\nNumber of parallel attention heads (d_model will be split across nhead - each head will have dimension d_model // nhead).\n\n\nproj_dropout\nfloat\n0.1\nDropout probability after the first linear layer. Default: 0.1.\n\n\nnum_encoder_layers\nint\n1\nNumber of transformer encoder layers. Default: 1.\n\n\ndim_feedforward\nint\n2048\nThe dimension of the feedforward network model. Default: 2048.\n\n\ndropout\nfloat\n0.1\nTransformer encoder layers dropout. Default: 0.1.\n\n\nnum_rnn_layers\nint\n1\nNumber of RNN layers in the encoder. Default: 1.\n\n\nbidirectional\nbool\nTrue\nIf True, becomes a bidirectional RNN. Default: True.\n\n\ncustom_head\nNoneType\nNone\nCustom head that will be applied to the model. If None, a head with c_out outputs will be used. Default: None.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nsource\n\n\nTransformerRNNPlus\n\n TransformerRNNPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                     d_model:int=128, nhead:int=16,\n                     proj_dropout:float=0.1, num_encoder_layers:int=1,\n                     dim_feedforward:int=2048, dropout:float=0.1,\n                     num_rnn_layers:int=1, bidirectional:bool=True,\n                     custom_head=None, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nNumber of channels in the input tensor.\n\n\nc_out\nint\n\nNumber of output channels.\n\n\nseq_len\nint\n\nNumber of time steps in the input tensor.\n\n\nd\ntuple\nNone\nint or tuple with shape of the output tensor\n\n\nd_model\nint\n128\nTotal dimension of the model.\n\n\nnhead\nint\n16\nNumber of parallel attention heads (d_model will be split across nhead - each head will have dimension d_model // nhead).\n\n\nproj_dropout\nfloat\n0.1\nDropout probability after the first linear layer. Default: 0.1.\n\n\nnum_encoder_layers\nint\n1\nNumber of transformer encoder layers. Default: 1.\n\n\ndim_feedforward\nint\n2048\nThe dimension of the feedforward network model. Default: 2048.\n\n\ndropout\nfloat\n0.1\nTransformer encoder layers dropout. Default: 0.1.\n\n\nnum_rnn_layers\nint\n1\nNumber of RNN layers in the encoder. Default: 1.\n\n\nbidirectional\nbool\nTrue\nIf True, becomes a bidirectional RNN. Default: True.\n\n\ncustom_head\nNoneType\nNone\nCustom head that will be applied to the model. If None, a head with c_out outputs will be used. Default: None.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nbs = 4\nc_in = 5\nc_out = 1\nseq_len = 50\nd = None\n\nmodel = TransformerRNNPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == torch.Size([4]) \nprint(model(t).shape)\n\nmodel = TransformerLSTMPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == torch.Size([4])\nprint(model(t).shape)\n\nmodel = TransformerGRUPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == torch.Size([4])\nprint(model(t).shape)\n\ntorch.Size([4])\ntorch.Size([4])\ntorch.Size([4])\n\n\n\nbs = 4\nc_in = 5\nc_out = 3\nseq_len = 50\nd = None\n\nmodel = TransformerRNNPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == (bs, c_out)\nprint(model(t).shape)\n\nmodel = TransformerLSTMPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == (bs, c_out)\nprint(model(t).shape)\n\nmodel = TransformerGRUPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == (bs, c_out)\nprint(model(t).shape)\n\ntorch.Size([4, 3])\ntorch.Size([4, 3])\ntorch.Size([4, 3])\n\n\n\nbs = 4\nc_in = 5\nc_out = 3\nseq_len = 50\nd = 50\n\nmodel = TransformerRNNPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == (bs, d, c_out)\nprint(model(t).shape)\n\nmodel = TransformerLSTMPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == (bs, d, c_out)\nprint(model(t).shape)\n\nmodel = TransformerGRUPlus(c_in=c_in, c_out=c_out, seq_len=seq_len, d=d, proj_dropout=0.1, d_model=128, nhead=4, num_encoder_layers=2, dropout=0.1, num_rnn_layers=1, bidirectional=True)\nt = torch.randn(bs, c_in, seq_len)\nassert model(t).shape == (bs, d, c_out)\nprint(model(t).shape)\n\ntorch.Size([4, 50, 3])\ntorch.Size([4, 50, 3])\ntorch.Size([4, 50, 3])",
    "crumbs": [
      "Models",
      "Hybrid models",
      "TransformerRNNPlus"
    ]
  },
  {
    "objectID": "callback.mvp.html",
    "href": "callback.mvp.html",
    "title": "MVP (aka TSBERT)",
    "section": "",
    "text": "Self-Supervised Pretraining of Time Series Models\n\nMasked Value Predictor callback used to predict time series step values after a binary mask has been applied.\n\nsource\n\nself_mask\n\n self_mask (o)\n\n\nsource\n\n\ncreate_future_mask\n\n create_future_mask (o, r=0.15, sync=False)\n\n\nsource\n\n\ncreate_variable_mask\n\n create_variable_mask (o, r=0.15)\n\n\nsource\n\n\ncreate_subsequence_mask\n\n create_subsequence_mask (o, r=0.15, lm=3, stateful=True, sync=False)\n\n\nt = torch.rand(16, 3, 100)\nmask = create_subsequence_mask(t, sync=False)\ntest_eq(mask.shape, t.shape)\nmask = create_subsequence_mask(t, sync=True)\ntest_eq(mask.shape, t.shape)\nmask = create_variable_mask(t)\ntest_eq(mask.shape, t.shape)\nmask = create_future_mask(t)\ntest_eq(mask.shape, t.shape)\n\n\no = torch.randn(2, 3, 4)\no[o&gt;.5] = np.nan\ntest_eq(torch.isnan(self_mask(o)).sum(), 0)\n\n\nt = torch.rand(16, 30, 100)\nmask = create_subsequence_mask(t, r=.15) # default settings\ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'sample 0 subsequence mask (sync=False) - default mean: {mask[0].float().mean().item():.3f}')\nplt.show()\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[1], cmap='cool')\nplt.title(f'sample 1 subsequence mask (sync=False) - default mean: {mask[1].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nt = torch.rand(16, 30, 100)\nmask = create_subsequence_mask(t, r=.5) # 50% of values masked\ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'sample 0 subsequence mask (r=.5) mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nt = torch.rand(16, 30, 100)\nmask = create_subsequence_mask(t, lm=5) # average length of mask = 5 \ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'sample 0 subsequence mask (lm=5) mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nt = torch.rand(16, 30, 100)\nmask = create_subsequence_mask(t, stateful=False) # individual time steps masked \ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'per sample subsequence mask (stateful=False) mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nt = torch.rand(1, 30, 100)\nmask = create_subsequence_mask(t, sync=True) # all time steps masked simultaneously\ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'per sample subsequence mask (sync=True) mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nt = torch.rand(1, 30, 100)\nmask = create_variable_mask(t) # masked variables\ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'per sample variable mask mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nt = torch.rand(1, 30, 100)\nmask = create_future_mask(t, r=.15, sync=True) # masked steps\ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'future mask mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nt = torch.rand(1, 30, 100)\nmask = create_future_mask(t, r=.15, sync=False) # masked steps\nmask = create_future_mask(t, r=.15, sync=True) # masked steps\ntest_eq(mask.dtype, torch.bool)\nplt.figure(figsize=(10, 3))\nplt.pcolormesh(mask[0], cmap='cool')\nplt.title(f'future mask mean: {mask[0].float().mean().item():.3f}')\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\ncreate_mask\n\n create_mask (o, r=0.15, lm=3, stateful=True, sync=False,\n              subsequence_mask=True, variable_mask=False,\n              future_mask=False)\n\n\nsource\n\n\nMVP\n\n MVP (r:float=0.15, subsequence_mask:bool=True, lm:float=3.0,\n      stateful:bool=True, sync:bool=False, variable_mask:bool=False,\n      future_mask:bool=False, custom_mask:Optional=None,\n      sel_vars:Optional[list]=None, nan_to_num:int=0,\n      window_size:Optional[tuple]=None, dropout:float=0.1, crit:&lt;built-\n      infunctioncallable&gt;=None, weights_path:Optional[str]=None,\n      target_dir:str='./models/MVP', fname:str='model',\n      save_best:bool=True, verbose:bool=False)\n\nBasic class handling tweaks of the training loop by changing a Learner in various events\n\n\nExperiments\n\nfrom tsai.data.external import get_UCR_data, check_data\nfrom tsai.data.preprocessing import TSStandardize, TSNan2Value\nfrom tsai.data.core import TSCategorize, get_ts_dls\nfrom tsai.learner import ts_learner\nfrom tsai.models.InceptionTimePlus import InceptionTimePlus\n\n\ndsid = 'MoteStrain'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ncheck_data(X, y, splits, False)\nX[X&lt;-1] = np.nan # This is to test the model works well even if nan values are passed through the dataloaders.\n\nX      - shape: [1272 samples x 1 features x 84 timesteps]  type: memmap  dtype:float32  isnan: 0\ny      - shape: (1272,)  type: memmap  dtype:&lt;U1  n_classes: 2 (636 samples per class) ['1', '2']  isnan: False\nsplits - n_splits: 2 shape: [20, 1252]  overlap: False\n\n\n\n# Pre-train\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = [TSStandardize(by_var=True)]\nunlabeled_dls = get_ts_dls(X, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nlearn = ts_learner(unlabeled_dls, InceptionTimePlus, cbs=[MVP(fname=f'{dsid}', window_size=(.5, 1))]) # trained on variable window size\nlearn.fit_one_cycle(1, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.270972\n1.194974\n00:06\n\n\n\n\n\n\nlearn = ts_learner(unlabeled_dls, InceptionTimePlus, cbs=[MVP(weights_path=f'models/MVP/{dsid}.pth')])\nlearn.fit_one_cycle(1, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n0.837741\n1.200484\n00:07\n\n\n\n\n\n\nlearn.MVP.show_preds(sharey=True) # these preds are highly inaccurate as the model's been trained for just 1 epoch for testing purposes\n\n\n\n\n\n\n\n\n\n# Fine-tune\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = [TSStandardize(by_var=True), TSNan2Value()]\nlabeled_dls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=64)\nlearn = ts_learner(labeled_dls, InceptionTimePlus, pretrained=True, weights_path=f'models/MVP/{dsid}.pth', metrics=accuracy)\nlearn.fit_one_cycle(1)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.773015\n0.744267\n0.460863\n00:09\n\n\n\n\n\n\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = [TSStandardize(by_var=True), TSNan2Value()]\nunlabeled_dls = get_ts_dls(X, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=64)\nfname = f'{dsid}_test'\nmvp = MVP(subsequence_mask=True, sync='random', variable_mask=True, future_mask=True, fname=fname)\nlearn = ts_learner(unlabeled_dls, InceptionTimePlus, metrics=accuracy, cbs=mvp) # Metrics will not be used!\n\n/Users/nacho/opt/anaconda3/envs/py37torch113/lib/python3.7/site-packages/ipykernel_launcher.py:42: UserWarning: Only future_mask will be used\n\n\n\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = [TSStandardize(by_var=True)]\nunlabeled_dls = get_ts_dls(X, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=64)\nfname = f'{dsid}_test'\nmvp = MVP(subsequence_mask=True, sync='random', variable_mask=True, future_mask=True, custom_mask=partial(create_future_mask, r=.15),\n                fname=fname)\nlearn = ts_learner(unlabeled_dls, InceptionTimePlus, metrics=accuracy, cbs=mvp) # Metrics will not be used!\n\n/Users/nacho/opt/anaconda3/envs/py37torch113/lib/python3.7/site-packages/ipykernel_launcher.py:40: UserWarning: Only custom_mask will be used\n\n\n\ntry: os.remove(\"models/MVP/MoteStrain.pth\")\nexcept OSError: pass\ntry: os.remove(\"models/MVP/model.pth\")\nexcept OSError: pass",
    "crumbs": [
      "Training",
      "Callbacks",
      "MVP (aka TSBERT)"
    ]
  },
  {
    "objectID": "models.minirocketplus_pytorch.html",
    "href": "models.minirocketplus_pytorch.html",
    "title": "MINIROCKETPlus Pytorch",
    "section": "",
    "text": "This is a modified Pytorch implementation of MiniRocket originally developed by Malcolm McLean and Ignacio Oguiza and based on:\nDempster, A., Schmidt, D. F., & Webb, G. I. (2020). MINIROCKET: A Very Fast (Almost) Deterministic Transform for Time Series Classification. arXiv preprint arXiv:2012.08791.\nOriginal paper: https://arxiv.org/abs/2012.08791\nOriginal code: https://github.com/angus924/minirocket\n\nsource\n\nMiniRocketFeaturesPlus\n\n MiniRocketFeaturesPlus (c_in, seq_len, num_features=10000,\n                         max_dilations_per_kernel=32, kernel_size=9,\n                         max_num_channels=9, max_num_kernels=84,\n                         add_lsaz=False)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nMiniRocketPlus\n\n MiniRocketPlus (c_in, c_out, seq_len, num_features=10000,\n                 max_dilations_per_kernel=32, kernel_size=9,\n                 max_num_channels=None, max_num_kernels=84, bn=True,\n                 fc_dropout=0, add_lsaz=False, custom_head=None,\n                 zero_init=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nFlatten\n\n Flatten (*args, **kwargs)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nget_minirocket_features\n\n get_minirocket_features (o, model, chunksize=1024, use_cuda=None,\n                          to_np=False)\n\nFunction used to split a large dataset into chunks, avoiding OOM error.\n\nsource\n\n\nMiniRocketHead\n\n MiniRocketHead (c_in, c_out, seq_len=1, bn=True, fc_dropout=0.0)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom tsai.imports import default_device\nfrom fastai.metrics import accuracy\nfrom fastai.callback.tracker import ReduceLROnPlateau\nfrom tsai.data.all import *\nfrom tsai.learner import *\n\n\n# Offline feature calculation\ndsid = 'ECGFiveDays'\nX, y, splits = get_UCR_data(dsid, split_data=False)\nmrf = MiniRocketFeaturesPlus(c_in=X.shape[1], seq_len=X.shape[2]).to(default_device())\nX_train = X[splits[0]]  # X_train may either be a np.ndarray or a torch.Tensor\nmrf.fit(X_train)\nX_tfm = get_minirocket_features(X, mrf).cpu().numpy()\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize(by_var=True)\ndls = get_ts_dls(X_tfm, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=256)\nlearn = ts_learner(dls, MiniRocketHead, metrics=accuracy)\nlearn.fit(1, 1e-4, cbs=ReduceLROnPlateau(factor=0.5, min_lr=1e-8, patience=10))\n\n\n# Online feature calculation\ndsid = 'ECGFiveDays'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, bs=256)\nlearn = ts_learner(dls, MiniRocketPlus, kernel_size=7, metrics=accuracy)\nlearn.fit_one_cycle(1, 1e-2)\n\n\nfrom functools import partial\nfrom fastcore.test import *\nfrom tsai.models.utils import build_ts_model\nfrom tsai.models.layers import mlp_head, rocket_nd_head\n\n\nbs, c_in, seq_len = 8, 3, 50\nc_out = 2\nxb = torch.randn(bs, c_in, seq_len)\nmodel = build_ts_model(MiniRocketPlus, c_in=c_in, c_out=c_out, seq_len=seq_len)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = build_ts_model(MiniRocketPlus, c_in=c_in, c_out=c_out, seq_len=seq_len, add_lsaz=True)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = build_ts_model(MiniRocketPlus, c_in=c_in, c_out=c_out, seq_len=seq_len, custom_head=mlp_head)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\n\n\nX = np.random.rand(8, 10, 100)\ny = np.random.rand(8, 1, 100)\nsplits = TimeSplitter(show_plot=False)(y)\ntfms = [None, TSRegression()]\nbatch_tfms = TSStandardize(by_sample=True)\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\ncustom_head = partial(rocket_nd_head, d=dls.d)\nmodel = MiniRocketPlus(dls.vars, dls.c, dls.len, custom_head=custom_head)\nxb,yb = dls.one_batch()\ntest_eq(model.to(xb.device)(xb).shape[1:], y.shape[1:])\n\n\nX = np.random.rand(16, 10, 100)\ny = np.random.randint(0, 4, (16, 1, 100))\nsplits = TimeSplitter(show_plot=False)(y)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize(by_sample=True)\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\ncustom_head = partial(rocket_nd_head, d=dls.d)\nmodel = MiniRocketPlus(dls.vars, dls.c, dls.len, custom_head=custom_head)\nxb,yb = dls.one_batch()\ntest_eq(model.to(xb.device)(xb).shape[1:], y.shape[1:]+(4,))\n\n\nsource\n\n\nInceptionRocketFeaturesPlus\n\n InceptionRocketFeaturesPlus (c_in, seq_len, num_features=10000,\n                              max_dilations_per_kernel=32,\n                              kernel_sizes=array([3, 5, 7, 9]),\n                              max_num_channels=None, max_num_kernels=84,\n                              add_lsaz=True, same_n_feats_per_ks=False)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nInceptionRocketPlus\n\n InceptionRocketPlus (c_in, c_out, seq_len, num_features=10000,\n                      max_dilations_per_kernel=32, kernel_sizes=[3, 5, 7,\n                      9], max_num_channels=None, max_num_kernels=84,\n                      same_n_feats_per_ks=False, add_lsaz=False, bn=True,\n                      fc_dropout=0, custom_head=None, zero_init=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom fastcore.test import *\nfrom tsai.models.utils import build_ts_model\n\n\nbs, c_in, seq_len = 8, 3, 50\nc_out = 2\nxb = torch.randn(bs, c_in, seq_len)\nmodel = build_ts_model(InceptionRocketPlus, c_in=c_in, c_out=c_out, seq_len=seq_len)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = build_ts_model(InceptionRocketPlus, c_in=c_in, c_out=c_out, seq_len=seq_len, add_lsaz=True)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\n\n\nX = np.random.rand(8, 10, 100)\ny = np.random.rand(8, 1, 100)\nsplits = TimeSplitter(show_plot=False)(y)\ntfms = [None, TSRegression()]\nbatch_tfms = TSStandardize(by_sample=True)\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\ncustom_head = partial(rocket_nd_head, d=dls.d)\nmodel = InceptionRocketPlus(dls.vars, dls.c, dls.len, custom_head=custom_head)\nxb,yb = dls.one_batch()\ntest_eq(model.to(xb.device)(xb).shape[1:], y.shape[1:])\n\n\nX = np.random.rand(16, 10, 100)\ny = np.random.randint(0, 4, (16, 1, 100))\nsplits = TimeSplitter(show_plot=False)(y)\ntfms = [None, TSClassification()]\nbatch_tfms = TSStandardize(by_sample=True)\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\ncustom_head = partial(rocket_nd_head, d=dls.d)\nmodel = MiniRocketPlus(dls.vars, dls.c, dls.len, custom_head=custom_head)\nxb,yb = dls.one_batch()\ntest_eq(model.to(xb.device)(xb).shape[1:], y.shape[1:]+(4,))",
    "crumbs": [
      "Models",
      "ROCKETs",
      "MINIROCKETPlus Pytorch"
    ]
  },
  {
    "objectID": "data.mixed_augmentation.html",
    "href": "data.mixed_augmentation.html",
    "title": "Label-mixing transforms",
    "section": "",
    "text": "Callbacks that perform data augmentation by mixing samples in different ways.\n\n\nsource\n\nMixHandler1d\n\n MixHandler1d (alpha=0.5)\n\nA handler class for implementing mixed sample data augmentation\n\nsource\n\n\nMixUp1d\n\n MixUp1d (alpha=0.4)\n\nImplementation of https://arxiv.org/abs/1710.09412\n\nfrom fastai.learner import *\nfrom tsai.models.InceptionTime import *\nfrom tsai.data.external import get_UCR_data\nfrom tsai.data.core import get_ts_dls, TSCategorize\nfrom tsai.data.preprocessing import TSStandardize\nfrom tsai.learner import ts_learner\n\n\nX, y, splits = get_UCR_data('NATOPS', return_split=False)\ntfms = [None, TSCategorize()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits, batch_tfms=batch_tfms)\nlearn = ts_learner(dls, InceptionTime, cbs=MixUp1d(0.4))\nlearn.fit_one_cycle(1)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.908455\n1.811908\n00:03\n\n\n\n\n\n\nsource\n\n\nCutMix1d\n\n CutMix1d (alpha=1.0)\n\nImplementation of https://arxiv.org/abs/1905.04899\n\nsource\n\n\nIntraClassCutMix1d\n\n IntraClassCutMix1d (alpha=1.0)\n\nImplementation of CutMix applied to examples of the same class\n\nX, y, splits = get_UCR_data('NATOPS', split_data=False)\ntfms = [None, TSCategorize()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits, batch_tfms=batch_tfms)\nlearn = ts_learner(dls, InceptionTime, cbs=IntraClassCutMix1d())\nlearn.fit_one_cycle(1)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.813483\n1.792010\n00:03\n\n\n\n\n\n\nX, y, splits = get_UCR_data('NATOPS', split_data=False)\ntfms = [None, TSCategorize()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits, batch_tfms=batch_tfms)\nlearn = ts_learner(dls, cbs=CutMix1d(1.))\nlearn.fit_one_cycle(1)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.824509\n1.774964\n00:04",
    "crumbs": [
      "Data",
      "Label-mixing transforms"
    ]
  },
  {
    "objectID": "optuna.html",
    "href": "optuna.html",
    "title": "Optuna",
    "section": "",
    "text": "A hyperparameter optimization framework\n\nOptuna is an automatic hyperparameter optimization software framework, particularly designed for machine learning. It features an imperative, define-by-run style user API. Thanks to our define-by-run API, the code written with Optuna enjoys high modularity, and the user of Optuna can dynamically construct the search spaces for the hyperparameters.\n\nsource\n\nrun_optuna_study\n\n run_optuna_study (objective, resume=None, study_type=None,\n                   multivariate=True, search_space=None, evaluate=None,\n                   seed=None, sampler=None, pruner=None, study_name=None,\n                   direction='maximize', n_trials=None, timeout=None,\n                   gc_after_trial=False, show_progress_bar=True,\n                   save_study=True, path='optuna', show_plots=True)\n\n*Creates and runs an optuna study.\nArgs: objective: A callable that implements objective function. resume: Path to a previously saved study. study_type: Type of study selected (bayesian, gridsearch, randomsearch). Based on this a sampler will be build if sampler is None. If a sampler is passed, this has no effect. multivariate: If this is True, the multivariate TPE is used when suggesting parameters. The multivariate TPE is reported to outperform the independent TPE. search_space: Search space required when running a gridsearch (if you don’t pass a sampler). evaluate: Allows you to pass a specific set of hyperparameters that will be evaluated. seed: Fixed seed used by samplers. sampler: A sampler object that implements background algorithm for value suggestion. If None is specified, TPESampler is used during single-objective optimization and NSGAIISampler during multi-objective optimization. See also samplers. pruner: A pruner object that decides early stopping of unpromising trials. If None is specified, MedianPruner is used as the default. See also pruners. study_name: Study’s name. If this argument is set to None, a unique name is generated automatically. direction: A sequence of directions during multi-objective optimization. n_trials: The number of trials. If this argument is set to None, there is no limitation on the number of trials. If timeout is also set to None, the study continues to create trials until it receives a termination signal such as Ctrl+C or SIGTERM. timeout: Stop study after the given number of second(s). If this argument is set to None, the study is executed without time limitation. If n_trials is also set to None, the study continues to create trials until it receives a termination signal such as Ctrl+C or SIGTERM. gc_after_trial: Flag to execute garbage collection at the end of each trial. By default, garbage collection is enabled, just in case. You can turn it off with this argument if memory is safely managed in your objective function. show_progress_bar: Flag to show progress bars or not. To disable progress bar, set this False. save_study: Save your study when finished/ interrupted. path: Folder where the study will be saved. show_plots: Flag to control whether plots are shown at the end of the study.*\n\n\nExported source\ndef run_optuna_study(objective, resume=None, study_type=None, multivariate=True, search_space=None, evaluate=None, seed=None, sampler=None, pruner=None, \n                     study_name=None, direction='maximize', n_trials=None, timeout=None, gc_after_trial=False, show_progress_bar=True, \n                     save_study=True, path='optuna', show_plots=True):\n    r\"\"\"Creates and runs an optuna study.\n\n    Args: \n        objective:          A callable that implements objective function.\n        resume:             Path to a previously saved study.\n        study_type:         Type of study selected (bayesian, gridsearch, randomsearch). Based on this a sampler will be build if sampler is None. \n                            If a sampler is passed, this has no effect.\n        multivariate:       If this is True, the multivariate TPE is used when suggesting parameters. The multivariate TPE is reported to outperform \n                            the independent TPE.\n        search_space:       Search space required when running a gridsearch (if you don't pass a sampler).\n        evaluate:           Allows you to pass a specific set of hyperparameters that will be evaluated.\n        seed:               Fixed seed used by samplers.\n        sampler:            A sampler object that implements background algorithm for value suggestion. If None is specified, TPESampler is used during \n                            single-objective optimization and NSGAIISampler during multi-objective optimization. See also samplers.\n        pruner:             A pruner object that decides early stopping of unpromising trials. If None is specified, MedianPruner is used as the default. \n                            See also pruners.\n        study_name:         Study’s name. If this argument is set to None, a unique name is generated automatically.\n        direction:          A sequence of directions during multi-objective optimization.\n        n_trials:           The number of trials. If this argument is set to None, there is no limitation on the number of trials. If timeout is also set to \n                            None, the study continues to create trials until it receives a termination signal such as Ctrl+C or SIGTERM.\n        timeout:            Stop study after the given number of second(s). If this argument is set to None, the study is executed without time limitation. \n                            If n_trials is also set to None, the study continues to create trials until it receives a termination signal such as \n                            Ctrl+C or SIGTERM.\n        gc_after_trial:     Flag to execute garbage collection at the end of each trial. By default, garbage collection is enabled, just in case. \n                            You can turn it off with this argument if memory is safely managed in your objective function.\n        show_progress_bar:  Flag to show progress bars or not. To disable progress bar, set this False.\n        save_study:         Save your study when finished/ interrupted.\n        path:               Folder where the study will be saved.\n        show_plots:         Flag to control whether plots are shown at the end of the study.\n    \"\"\"\n    \n    try: import optuna\n    except ImportError: raise ImportError('You need to install optuna to use run_optuna_study')\n\n    # Sampler\n    if sampler is None:\n        if study_type is None or \"bayes\" in study_type.lower(): \n            sampler = optuna.samplers.TPESampler(seed=seed, multivariate=multivariate)\n        elif \"grid\" in study_type.lower():\n            assert search_space, f\"you need to pass a search_space dict to run a gridsearch\"\n            sampler = optuna.samplers.GridSampler(search_space)\n        elif \"random\" in study_type.lower(): \n            sampler = optuna.samplers.RandomSampler(seed=seed)\n    assert sampler, \"you need to either select a study type (bayesian, gridsampler, randomsampler) or pass a sampler\"\n\n    # Study\n    if resume: \n        try:\n            study = joblib.load(resume)\n        except: \n            print(f\"joblib.load({resume}) couldn't recover any saved study. Check the path.\")\n            return\n        print(\"Best trial until now:\")\n        print(\" Value: \", study.best_trial.value)\n        print(\" Params: \")\n        for key, value in study.best_trial.params.items():\n            print(f\"    {key}: {value}\")\n    else: \n        study = optuna.create_study(sampler=sampler, pruner=pruner, study_name=study_name, direction=direction)\n    if evaluate: study.enqueue_trial(evaluate)\n    try:\n        study.optimize(objective, n_trials=n_trials, timeout=timeout, gc_after_trial=gc_after_trial, show_progress_bar=show_progress_bar)\n    except KeyboardInterrupt:\n        pass\n\n    # Save\n    if save_study:\n        full_path = Path(path)/f'{study.study_name}.pkl'\n        full_path.parent.mkdir(parents=True, exist_ok=True)\n        joblib.dump(study, full_path)\n        print(f'\\nOptuna study saved to {full_path}')\n        print(f\"To reload the study run: study = joblib.load('{full_path}')\")\n\n    # Plots\n    if show_plots and len(study.trials) &gt; 1:\n        try: display(optuna.visualization.plot_optimization_history(study))\n        except: pass\n        try: display(optuna.visualization.plot_param_importances(study))\n        except: pass\n        try: display(optuna.visualization.plot_slice(study))\n        except: pass\n        try: display(optuna.visualization.plot_parallel_coordinate(study))\n        except: pass\n\n    # Study stats\n    try:\n        pruned_trials = [t for t in study.trials if t.state == optuna.trial.TrialState.PRUNED]\n        complete_trials = [t for t in study.trials if t.state == optuna.trial.TrialState.COMPLETE]\n        print(f\"\\nStudy statistics    : \")\n        print(f\"  Study name        : {study.study_name}\")\n        print(f\"  # finished trials : {len(study.trials)}\")\n        print(f\"  # pruned trials   : {len(pruned_trials)}\")\n        print(f\"  # complete trials : {len(complete_trials)}\")\n        \n        print(f\"\\nBest trial          :\")\n        trial = study.best_trial\n        print(f\"  value             : {trial.value}\")\n        print(f\"  best_params = {trial.params}\\n\")\n    except:\n        print('\\nNo finished trials yet.')\n    return study",
    "crumbs": [
      "HPO & experiment tracking",
      "Optuna"
    ]
  },
  {
    "objectID": "callback.experimental.html",
    "href": "callback.experimental.html",
    "title": "Experimental Callbacks",
    "section": "",
    "text": "Miscellaneous experimental callbacks for timeseriesAI.",
    "crumbs": [
      "Training",
      "Callbacks",
      "Experimental Callbacks"
    ]
  },
  {
    "objectID": "callback.experimental.html#gamblers-loss-noisy-labels",
    "href": "callback.experimental.html#gamblers-loss-noisy-labels",
    "title": "Experimental Callbacks",
    "section": "Gambler’s loss: noisy labels",
    "text": "Gambler’s loss: noisy labels\n\nsource\n\ngambler_loss\n\n gambler_loss (reward=2)\n\n\nsource\n\n\nGamblersCallback\n\n GamblersCallback (after_create=None, before_fit=None, before_epoch=None,\n                   before_train=None, before_batch=None, after_pred=None,\n                   after_loss=None, before_backward=None,\n                   after_cancel_backward=None, after_backward=None,\n                   before_step=None, after_cancel_step=None,\n                   after_step=None, after_cancel_batch=None,\n                   after_batch=None, after_cancel_train=None,\n                   after_train=None, before_validate=None,\n                   after_cancel_validate=None, after_validate=None,\n                   after_cancel_epoch=None, after_epoch=None,\n                   after_cancel_fit=None, after_fit=None)\n\nA callback to use metrics with gambler’s loss\n\nfrom tsai.data.external import *\nfrom tsai.data.core import *\nfrom tsai.models.InceptionTime import *\nfrom tsai.models.layers import *\nfrom tsai.learner import *\nfrom fastai.metrics import *\nfrom tsai.metrics import *\n\n\nX, y, splits = get_UCR_data('NATOPS', return_split=False)\ntfms = [None, TSCategorize()]\ndsets = TSDatasets(X, y, tfms=tfms, splits=splits)\ndls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=[64, 128])\nloss_func = gambler_loss()\nlearn = ts_learner(dls, InceptionTime(dls.vars, dls.c + 1), loss_func=loss_func, cbs=GamblersCallback, metrics=[accuracy])\nlearn.fit_one_cycle(1)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.840055\n1.945397\n0.166667\n00:05",
    "crumbs": [
      "Training",
      "Callbacks",
      "Experimental Callbacks"
    ]
  },
  {
    "objectID": "callback.experimental.html#uncertainty-based-data-augmentation",
    "href": "callback.experimental.html#uncertainty-based-data-augmentation",
    "title": "Experimental Callbacks",
    "section": "Uncertainty-based data augmentation",
    "text": "Uncertainty-based data augmentation\n\nsource\n\nUBDAug\n\n UBDAug (batch_tfms:list, N:int=2, C:int=4, S:int=1)\n\nA callback to implement the uncertainty-based data augmentation.\n\nfrom tsai.models.utils import *\n\n\nX, y, splits = get_UCR_data('NATOPS', return_split=False)\ntfms = [None, TSCategorize()]\ndsets = TSDatasets(X, y, tfms=tfms, splits=splits)\ndls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, batch_tfms=[TSStandardize()])\nmodel = build_ts_model(InceptionTime, dls=dls)\nTS_tfms = [TSMagScale(.75, p=.5), TSMagWarp(.1, p=0.5),  TSWindowWarp(.25, p=.5), \n           TSSmooth(p=0.5), TSRandomResizedCrop(.1, p=.5), \n           TSRandomCropPad(.3, p=0.5), \n           TSMagAddNoise(.5, p=.5)]\n\nubda_cb = UBDAug(TS_tfms, N=2, C=4, S=2)\nlearn = ts_learner(dls, model, cbs=ubda_cb, metrics=accuracy)\nlearn.fit_one_cycle(1)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.817080\n1.791119\n0.077778\n00:14",
    "crumbs": [
      "Training",
      "Callbacks",
      "Experimental Callbacks"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorial notebooks",
    "section": "",
    "text": "A number of tutorials have been created to help you get started to use tsai with time series data. Please, feel free to open the notebooks (you can open them in Colab if you want) and tweak them to do your own experiments.",
    "crumbs": [
      "Tutorial notebooks"
    ]
  },
  {
    "objectID": "tutorials.html#time-series-classification-using-raw-data",
    "href": "tutorials.html#time-series-classification-using-raw-data",
    "title": "Tutorial notebooks",
    "section": "Time series classification (using raw data)",
    "text": "Time series classification (using raw data)\nI’d recommend you to start with:\n\nIntroduction to Time Series Classification. This notebook contains a detailed walk through the steps to perform time series classification.\n\n\nData preparation:\nIf you need help preparing your data you may find the following tutorials useful:\n\nTime Series data preparation: this will show how you can do classify both univariate or multivariate time series.\nHow to work with (very) large numpy arrays in tsai?\nHow to use numpy arrays in tsai?\n\nThese last 2 provide more details in case you need them. They explain how datasets and dataloaders are created.\n\n\nTypes of architectures:\nOnce you feel comfortable, you can start exploring different types of architectures:\n\nYou can use the Time Series data preparation notebook and replace the InceptionTime architecture by any other of your choice:\n\nMLPs\nRNNs (LSTM, GRU)\nCNNs (FCN, ResNet, XResNet)\nWavelet-based architectures\nTransformers (like TST - 2020)\nThey all (except ROCKET) work in the same way, for univariate or multivariate time series.\n\nHow to use Transformers with Time Series? may also help you understand how to successfully apply this new type of architecture to time series.\nYou can also use Time Series Classification Benchmark to perform bechmarks with different architectures and/ or configurations.\n\nROCKET (2019) is a new technique used to generate 10-20k features from time series. These features are used in a different classifier. This is the only implementation I’m aware of that uses GPU and allows both univariate and multivariate time series. To explain this method that works very well in many cases you can use the following notebook:\n\nROCKET: a new state-of-the-art time series classifier\n\nThere are many types of classifiers as you can see, and it’s very difficult to know in advance which one will perform well in our task. However, the ones that have consistently deliver the best results in recent benchmark studies are Inceptiontime (Fawaz, 2019) and ROCKET (Dempster, 2019). Transformers, like TST (Zerveas, 2020), also show a lot of promise, but the application to time series data is so new that they have not been benchmarked against other architectures. But I’d say these are 3 architectures you should know well.",
    "crumbs": [
      "Tutorial notebooks"
    ]
  },
  {
    "objectID": "tutorials.html#time-series-classification-using-time-series-images",
    "href": "tutorials.html#time-series-classification-using-time-series-images",
    "title": "Tutorial notebooks",
    "section": "Time series classification (using time series images)",
    "text": "Time series classification (using time series images)\nIn these tutorials, I’ve also included a section on how to transform time series into images. This will allow you to then use DL vision models like ResNet50 for example. This approach works very well in some cases, even if you have limited data. You can learn about this technique in this notebook:\n\nImaging time series",
    "crumbs": [
      "Tutorial notebooks"
    ]
  },
  {
    "objectID": "tutorials.html#time-series-regression",
    "href": "tutorials.html#time-series-regression",
    "title": "Tutorial notebooks",
    "section": "Time series regression",
    "text": "Time series regression\nI’ve also included an example of how you can perform time series regression with your time series using tsai. In this case, the label will be continuous, instead of a category. But as you will see, the use is almost identical to time series classification. You can learn more about this here:\n\nTime series regression",
    "crumbs": [
      "Tutorial notebooks"
    ]
  },
  {
    "objectID": "tutorials.html#visualization",
    "href": "tutorials.html#visualization",
    "title": "Tutorial notebooks",
    "section": "Visualization",
    "text": "Visualization\nI’ve also created PredictionDynamics callback that allows you to visualize the model’s predictions while it’s training. It can provide you some additional insights that may be useful to improve your model. Here’s the notebook:\n\nPredictionDynamics\n\nI hope you will find these tutorial useful. I’m planning to add more tutorials to demonstrate new techniques, models, etc when they become available. So stay tuned!",
    "crumbs": [
      "Tutorial notebooks"
    ]
  },
  {
    "objectID": "models.rnn_fcn.html",
    "href": "models.rnn_fcn.html",
    "title": "RNN_FCN",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\nMGRU_FCN\n\n MGRU_FCN (*args, se=16, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nMLSTM_FCN\n\n MLSTM_FCN (*args, se=16, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nMRNN_FCN\n\n MRNN_FCN (*args, se=16, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nGRU_FCN\n\n GRU_FCN (c_in, c_out, seq_len=None, hidden_size=100, rnn_layers=1,\n          bias=True, cell_dropout=0, rnn_dropout=0.8, bidirectional=False,\n          shuffle=True, fc_dropout=0.0, conv_layers=[128, 256, 128],\n          kss=[7, 5, 3], se=0)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nLSTM_FCN\n\n LSTM_FCN (c_in, c_out, seq_len=None, hidden_size=100, rnn_layers=1,\n           bias=True, cell_dropout=0, rnn_dropout=0.8,\n           bidirectional=False, shuffle=True, fc_dropout=0.0,\n           conv_layers=[128, 256, 128], kss=[7, 5, 3], se=0)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nRNN_FCN\n\n RNN_FCN (c_in, c_out, seq_len=None, hidden_size=100, rnn_layers=1,\n          bias=True, cell_dropout=0, rnn_dropout=0.8, bidirectional=False,\n          shuffle=True, fc_dropout=0.0, conv_layers=[128, 256, 128],\n          kss=[7, 5, 3], se=0)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\ntest_eq(RNN_FCN(n_vars, c_out, seq_len)(xb).shape, [bs, c_out])\ntest_eq(LSTM_FCN(n_vars, c_out, seq_len)(xb).shape, [bs, c_out])\ntest_eq(MLSTM_FCN(n_vars, c_out, seq_len)(xb).shape, [bs, c_out])\ntest_eq(GRU_FCN(n_vars, c_out, shuffle=False)(xb).shape, [bs, c_out])\ntest_eq(GRU_FCN(n_vars, c_out, seq_len, shuffle=False)(xb).shape, [bs, c_out])\n\n\nLSTM_FCN(n_vars, seq_len, c_out, se=8)\n\nLSTM_FCN(\n  (rnn): LSTM(2, 100, batch_first=True)\n  (rnn_dropout): Dropout(p=0.8, inplace=False)\n  (convblock1): ConvBlock(\n    (0): Conv1d(3, 128, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n    (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (se1): SqueezeExciteBlock(\n    (avg_pool): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Flatten(full=False)\n    )\n    (fc): Sequential(\n      (0): Linear(in_features=128, out_features=16, bias=False)\n      (1): ReLU()\n      (2): Linear(in_features=16, out_features=128, bias=False)\n      (3): Sigmoid()\n    )\n  )\n  (convblock2): ConvBlock(\n    (0): Conv1d(128, 256, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n    (1): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (se2): SqueezeExciteBlock(\n    (avg_pool): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Flatten(full=False)\n    )\n    (fc): Sequential(\n      (0): Linear(in_features=256, out_features=32, bias=False)\n      (1): ReLU()\n      (2): Linear(in_features=32, out_features=256, bias=False)\n      (3): Sigmoid()\n    )\n  )\n  (convblock3): ConvBlock(\n    (0): Conv1d(256, 128, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n    (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (2): ReLU()\n  )\n  (gap): GAP1d(\n    (gap): AdaptiveAvgPool1d(output_size=1)\n    (flatten): Flatten(full=False)\n  )\n  (concat): Concat(dim=1)\n  (fc): Linear(in_features=228, out_features=12, bias=True)\n)",
    "crumbs": [
      "Models",
      "Hybrid models",
      "RNN_FCN"
    ]
  },
  {
    "objectID": "models.resnetplus.html",
    "href": "models.resnetplus.html",
    "title": "ResNetPlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\nResNetPlus\n\n ResNetPlus (c_in, c_out, seq_len=None, nf=64, sa=False, se=None,\n             fc_dropout=0.0, concat_pool=False, flatten=False,\n             custom_head=None, y_range=None, ks=[7, 5, 3], coord=False,\n             separable=False, bn_1st=True, zero_norm=False, act=&lt;class\n             'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nResBlockPlus\n\n ResBlockPlus (ni, nf, ks=[7, 5, 3], coord=False, separable=False,\n               bn_1st=True, zero_norm=False, sa=False, se=None, act=&lt;class\n               'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={})\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.models.layers import Swish\n\n\nxb = torch.rand(2, 3, 4)\ntest_eq(ResNetPlus(3,2)(xb).shape, [xb.shape[0], 2])\ntest_eq(ResNetPlus(3,2,coord=True, separable=True, bn_1st=False, zero_norm=True, act=Swish, act_kwargs={}, fc_dropout=0.5)(xb).shape, [xb.shape[0], 2])\ntest_eq(count_parameters(ResNetPlus(3, 2)), 479490) # for (3,2)\n\n\nfrom tsai.models.ResNet import *\n\n\ntest_eq(count_parameters(ResNet(3, 2)), count_parameters(ResNetPlus(3, 2))) # for (3,2)\n\n\nm = ResNetPlus(3, 2, zero_norm=True, coord=True, separable=True)\nprint('n_params:', count_parameters(m))\nprint(m)\nprint(check_weight(m, is_bn)[0])\n\nn_params: 114820\nResNetPlus(\n  (backbone): Sequential(\n    (0): ResBlockPlus(\n      (convblock1): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(4, 4, kernel_size=(7,), stride=(1,), padding=(3,), groups=4, bias=False)\n          (pointwise_conv): Conv1d(4, 64, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (3): ReLU()\n      )\n      (convblock2): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(65, 65, kernel_size=(5,), stride=(1,), padding=(2,), groups=65, bias=False)\n          (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (3): ReLU()\n      )\n      (convblock3): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(65, 65, kernel_size=(3,), stride=(1,), padding=(1,), groups=65, bias=False)\n          (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (shortcut): ConvBlock(\n        (0): AddCoords1d()\n        (1): Conv1d(4, 64, kernel_size=(1,), stride=(1,), bias=False)\n        (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (add): Add\n      (act): ReLU()\n    )\n    (1): ResBlockPlus(\n      (convblock1): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(65, 65, kernel_size=(7,), stride=(1,), padding=(3,), groups=65, bias=False)\n          (pointwise_conv): Conv1d(65, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (3): ReLU()\n      )\n      (convblock2): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(129, 129, kernel_size=(5,), stride=(1,), padding=(2,), groups=129, bias=False)\n          (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (3): ReLU()\n      )\n      (convblock3): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(129, 129, kernel_size=(3,), stride=(1,), padding=(1,), groups=129, bias=False)\n          (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (shortcut): ConvBlock(\n        (0): AddCoords1d()\n        (1): Conv1d(65, 128, kernel_size=(1,), stride=(1,), bias=False)\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (add): Add\n      (act): ReLU()\n    )\n    (2): ResBlockPlus(\n      (convblock1): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(129, 129, kernel_size=(7,), stride=(1,), padding=(3,), groups=129, bias=False)\n          (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (3): ReLU()\n      )\n      (convblock2): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(129, 129, kernel_size=(5,), stride=(1,), padding=(2,), groups=129, bias=False)\n          (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (3): ReLU()\n      )\n      (convblock3): ConvBlock(\n        (0): AddCoords1d()\n        (1): SeparableConv1d(\n          (depthwise_conv): Conv1d(129, 129, kernel_size=(3,), stride=(1,), padding=(1,), groups=129, bias=False)\n          (pointwise_conv): Conv1d(129, 128, kernel_size=(1,), stride=(1,), bias=False)\n        )\n        (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n      (shortcut): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (add): Add\n      (act): ReLU()\n    )\n  )\n  (head): Sequential(\n    (0): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Reshape(bs)\n    )\n    (1): Linear(in_features=128, out_features=2, bias=True)\n  )\n)\n[1. 1. 0. 1. 1. 1. 0. 1. 1. 1. 0. 1.]",
    "crumbs": [
      "Models",
      "CNNs",
      "ResNetPlus"
    ]
  },
  {
    "objectID": "data.core.html",
    "href": "data.core.html",
    "title": "Data Core",
    "section": "",
    "text": "Main Numpy and Times Series functions used throughout the library.\n\n\nfrom tsai.data.external import get_UCR_data\n\n\ndsid = 'OliveOil'\nX_train, y_train, X_valid, y_valid = get_UCR_data(dsid, on_disk=True, force_download=True)\nX_on_disk, y_on_disk, splits = get_UCR_data(dsid, on_disk=True, return_split=False, force_download=True)\nX_in_memory, y_in_memory, splits = get_UCR_data(dsid, on_disk=False, return_split=False, force_download=True)\ny_tensor = cat2int(y_on_disk)\ny_array = y_tensor.numpy()\n\n\nsource\n\nToNumpyTensor\n\n ToNumpyTensor (enc=None, dec=None, split_idx=None, order=None)\n\nTransforms an object into NumpyTensor\n\nsource\n\n\nNumpyTensor\n\n NumpyTensor (o, dtype=None, device=None, copy=None, requires_grad=False,\n              **kwargs)\n\nReturns a tensor with subclass NumpyTensor that has a show method\n\nsource\n\n\nTSTensor\n\n TSTensor (o, dtype=None, device=None, copy=None, requires_grad=False,\n           **kwargs)\n\nReturns a tensor with subclass TSTensor that has a show method\n\nsource\n\n\nshow_tuple\n\n show_tuple (tup, nrows:int=1, ncols:int=1,\n             sharex:\"bool|Literal['none','all','row','col']\"=False,\n             sharey:\"bool|Literal['none','all','row','col']\"=False,\n             squeeze:bool=True, width_ratios:Sequence[float]|None=None,\n             height_ratios:Sequence[float]|None=None,\n             subplot_kw:dict[str,Any]|None=None,\n             gridspec_kw:dict[str,Any]|None=None)\n\nDisplay a timeseries plot from a decoded tuple\n\nsource\n\n\nToTSTensor\n\n ToTSTensor (enc=None, dec=None, split_idx=None, order=None)\n\nTransforms an object into TSTensor\n\na = np.random.randn(2, 3, 4).astype(np.float16)\nassert np.shares_memory(a, NumpyTensor(a))\nassert np.shares_memory(a, TSTensor(a))\n\n\na = np.random.randn(2, 3, 4).astype(np.float32)\nassert np.shares_memory(a, NumpyTensor(a))\nassert np.shares_memory(a, TSTensor(a))\n\n\na = np.random.randint(10, size=10).astype(np.int64)\nassert np.shares_memory(a, NumpyTensor(a))\nassert np.shares_memory(a, TSTensor(a))\n\n\na = np.random.randint(10, size=10).astype(np.int32)\nassert np.shares_memory(a, NumpyTensor(a))\nassert np.shares_memory(a, TSTensor(a))\n\n\na = torch.rand(2, 3, 4).float()\nassert np.shares_memory(a, NumpyTensor(a))\nassert np.shares_memory(a, TSTensor(a))\n\n\na = torch.randint(3, (10,))\nassert np.shares_memory(a, NumpyTensor(a))\nassert np.shares_memory(a, TSTensor(a))\n\n\nt = TSTensor(torch.randn(2, 3, 4))\np = torch.tensor(3., requires_grad=True)\ntest = torch.add(t, p)\ntest_eq(test.requires_grad, True)\ntest_eq(type(t.data), torch.Tensor)\ntest_eq(type(t), TSTensor)\n\n\nl = L([0,1,2,3], [4,5,6,7], [8, 9, 10, 11])\nTSTensor(l), TSTensor(l).data\n\n(TSTensor(vars:3, len:4, device=cpu, dtype=torch.int64),\n tensor([[ 0,  1,  2,  3],\n         [ 4,  5,  6,  7],\n         [ 8,  9, 10, 11]]))\n\n\n\nt = TSTensor(X_train)\nfor i in range(4):\n    print(t, t.ndim, torch.is_tensor(t))\n    if i &lt; 3: t = t[0]\n\nTSTensor(samples:30, vars:1, len:570, device=cpu, dtype=torch.float32) 3 True\nTSTensor(vars:1, len:570, device=cpu, dtype=torch.float32) 2 True\nTSTensor(len:570, device=cpu, dtype=torch.float32) 1 True\nTSTensor([-0.6113752722740173], device=cpu, dtype=torch.float32) 0 True\n\n\n\nTSTensor(X_on_disk)\n\nTSTensor(samples:60, vars:1, len:570, device=cpu, dtype=torch.float32)\n\n\n\nToTSTensor()(X_on_disk)\n\nTSTensor(samples:60, vars:1, len:570, device=cpu, dtype=torch.float32)\n\n\n\nTSTensor(X_train).show();\n\n\n\n\n\n\n\n\n\nTSTensor(X_train).show(title='1');\n\n\n\n\n\n\n\n\n\nshow_tuple((TSTensor(X_train), ['1', '2']))\n\n\n\n\n\n\n\n\n\nshow_tuple((TSTensor(np.arange(10).reshape(2,5)), 1))\n\n\n\n\n\n\n\n\n\nshow_tuple((TSTensor(np.arange(10).reshape(2,5)), '1'))\n\n\n\n\n\n\n\n\n\nshow_tuple((TSTensor(np.arange(10).reshape(2,5)), [1,2]))\n\n\n\n\n\n\n\n\n\nshow_tuple((TSTensor(np.arange(10).reshape(2,5)), ['1', '2']))\n\n\n\n\n\n\n\n\n\nsource\n\n\nTSMaskTensor\n\n TSMaskTensor (o, dtype=None, device=None, copy=None, requires_grad=False,\n               **kwargs)\n\nReturns a tensor with subclass NumpyTensor that has a show method\n\nsource\n\n\nTSLabelTensor\n\n TSLabelTensor (o, dtype=None, device=None, copy=None,\n                requires_grad=False, **kwargs)\n\nReturns a tensor with subclass NumpyTensor that has a show method\n\nt = TSLabelTensor(torch.randint(0,10,(1, 2, 3)))\nt, t[0], t[0][0], t[0][0][0]\n\n(TSLabelTensor(shape:(1, 2, 3), device=cpu, dtype=torch.int64),\n TSLabelTensor(shape:(2, 3), device=cpu, dtype=torch.int64),\n TSLabelTensor(shape:(3,), device=cpu, dtype=torch.int64),\n 3)\n\n\n\nt = TSMaskTensor(torch.randint(0,10,(1, 2, 3)))\nt, t[0], t[0][0], t[0][0][0]\n\n(TSMaskTensor(shape:(1, 2, 3), device=cpu, dtype=torch.int64),\n TSMaskTensor(shape:(2, 3), device=cpu, dtype=torch.int64),\n TSMaskTensor(shape:(3,), device=cpu, dtype=torch.int64),\n 6)\n\n\n\nsource\n\n\nTSClassification\n\n TSClassification (vocab=None, sort=True)\n\nVectorized, reversible transform of category string to vocab id\n\nsource\n\n\nToInt\n\n ToInt (enc=None, dec=None, split_idx=None, order=None)\n\nTransforms an object dtype to int\n\nsource\n\n\nToFloat\n\n ToFloat (enc=None, dec=None, split_idx=None, order=None)\n\nTransforms an object dtype to float (vectorized)\n\na = np.random.randint(0, 2, 10)\nb = np.array(['1', '2', '3'])\nc = np.array(['1.0', '2.0', '3.0'])\nt = torch.randint(0, 2, (10, ))\ntest_eq(ToFloat()(a).dtype, 'float32')\ntest_eq(ToFloat()(b).dtype, 'float32')\ntest_eq(ToFloat()(c).dtype, 'float32')\ntest_eq(ToFloat()(t).dtype, torch.float32)\n\n\na = np.random.rand(10)*10\nb = np.array(['1.0', '2.0', '3.0'])\nt = torch.rand(10)*10\ntest_eq(ToInt()(a).dtype, 'int64')\ntest_eq(ToInt()(b).dtype, 'int64')\ntest_eq(ToInt()(t).dtype, torch.long)\n\n\nt = TSClassification()\nt.setup(y_on_disk[splits[0]])\ny_encoded = t(y_on_disk)\nprint(y_encoded)\ntest_eq(t.decodes(y_encoded), y_on_disk)\n\nTensorCategory([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,\n                3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,\n                1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])\n\n\n\ny_multi= np.random.randint(0,3,20)\ny_multi = np.asarray(alphabet[y_multi]).reshape(4,5)\ntfm = TSClassification()\ntfm.setup(y_multi)\nenc_y_multi = tfm(y_multi)\ntest_eq(y_multi, tfm.decode(enc_y_multi))\nenc_y_multi\n\nTensorCategory([[2, 1, 0, 0, 1],\n                [0, 0, 2, 1, 2],\n                [0, 2, 0, 0, 0],\n                [1, 1, 0, 0, 1]])\n\n\n\nsource\n\n\nTSMultiLabelClassification\n\n TSMultiLabelClassification (c=None, vocab=None, add_na=False, sort=True)\n\nReversible combined transform of multi-category strings to one-hot encoded vocab id\n\nsource\n\n\nTSTensorBlock\n\n TSTensorBlock (type_tfms=None, item_tfms=None, batch_tfms=None,\n                dl_type=None, dls_kwargs=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nNumpyTensorBlock\n\n NumpyTensorBlock (type_tfms=None, item_tfms=None, batch_tfms=None,\n                   dl_type=None, dls_kwargs=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\ntest_eq(NumpyTensorBlock().item_tfms[0].__name__, 'ToNumpyTensor')\ntest_eq(TSTensorBlock().item_tfms[0].__name__, 'ToTSTensor')\n\n\nsource\n\n\nTSDataset\n\n TSDataset (X, y=None, split=None, sel_vars=None, sel_steps=None,\n            types=None, dtype=None, device=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nNumpyDataset\n\n NumpyDataset (X, y=None, types=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nTorchDataset\n\n TorchDataset (X, y=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\na = np.random.rand(5,6,7)\nb = np.random.rand(5)\nds = NumpyDataset(a,b)\nxb, yb = ds[[0,4]]\ntest_eq(xb.shape, (2,6,7))\ntest_eq(yb.shape, (2,))\n\n\nsource\n\n\nTSTfmdLists\n\n TSTfmdLists (items=None, *rest, use_list=False, match=None)\n\nA Pipeline of tfms applied to a collection of items\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nitems\nlist\n\nItems to apply Transforms to\n\n\nuse_list\nbool\nNone\nUse list in L\n\n\n\n\nsource\n\n\nNoTfmLists\n\n NoTfmLists (items=None, *rest, use_list=False, match=None)\n\nA Pipeline of tfms applied to a collection of items\n\nitems = X_on_disk\ntl = TfmdLists(items, tfms=None, splits=splits)\ntest_eq(len(tl), len(X_on_disk))\ntest_eq(len(tl.train), len(splits[0]))\ntest_eq(len(tl.valid), len(splits[1]))\ntest_eq(tl[[0,4,7]], X_on_disk[[0,4,7]])\ntest_eq(tl.train[[0,4,7]], X_on_disk[splits[0][0,4,7]])\ntest_eq(tl.valid[[0,4,7]], X_on_disk[splits[1][0,4,7]])\ntest_eq(tl[0], items[0])\ntest_eq(tl[[0,1]], items[[0,1]])\ntest_eq(tl.decode(tl[0]), tl[0])\ntest_eq((tl.split_idx, tl.train.split_idx, tl.valid.split_idx), (None, 0, 1))\n\n\nitems = X_on_disk\ntl = TSTfmdLists(items, tfms=None, splits=splits)\ntest_eq(len(tl), len(X_on_disk))\ntest_eq(len(tl.train), len(splits[0]))\ntest_eq(len(tl.valid), len(splits[1]))\ntest_eq(tl[[0,4,7]], X_on_disk[[0,4,7]])\ntest_eq(tl.train[[0,4,7]], X_on_disk[splits[0][0,4,7]])\ntest_eq(tl.valid[[0,4,7]], X_on_disk[splits[1][0,4,7]])\ntest_eq(tl[0], items[0])\ntest_eq(tl[[0,1]], items[[0,1]])\ntest_eq(tl.decode(tl[0]), tl[0])\ntest_eq((tl.split_idx, tl.train.split_idx, tl.valid.split_idx), (None, 0, 1))\n\n\nitems = X_on_disk\nntl = NoTfmLists(items, splits=splits)\ntest_eq(len(ntl), len(X_on_disk))\ntest_eq(len(ntl.train), len(splits[0]))\ntest_eq(len(ntl.valid), len(splits[1]))\ntest_eq(ntl._splits, np.arange(len(X_on_disk)))\ntest_eq(ntl.train._splits, np.arange(len(splits[0])))\ntest_eq(ntl.valid._splits, np.arange(len(splits[0]), len(X_on_disk)))\nprint(ntl)\nprint(ntl.train)\nprint(ntl.valid)\ntest_eq(ntl[[0,4,7]], X_on_disk[[0,4,7]])\ntest_eq(ntl.train[[0,4,7]], X_on_disk[splits[0][0,4,7]])\ntest_eq(ntl.valid[[0,4,7]], X_on_disk[splits[1][0,4,7]])\ntest_eq(ntl[0], items[0])\ntest_eq(ntl[[0,1]], items[[0,1]])\ntest_eq(ntl[:], X_on_disk)\nntl[0].shape, stack(ntl[[0,1]]).shape\ntest_eq(ntl.decode(ntl[0]), ntl[0])\nassert id(items) == id(ntl.items) == id(ntl.train.items) == id(ntl.valid.items)\ntest_eq((ntl.split_idx, ntl.train.split_idx, ntl.valid.split_idx), (None, 0, 1))\n\nNoTfmLists: memmap(60, 1, 570)\nNoTfmLists: memmap(30, 1, 570)\nNoTfmLists: memmap(30, 1, 570)\n\n\n\nsubitems = X_on_disk\nnew_ntl = ntl._new(X_on_disk)\ntest_eq(new_ntl[:], X_on_disk)\n\n\nidxs = random_choice(len(X_on_disk), 10, False)\nnew_ntl = ntl._new(X_on_disk[idxs])\ntest_eq(new_ntl[:], X_on_disk[idxs])\n\n\nidxs = random_choice(len(X_on_disk), 10, False)\nnew_ntl = ntl.valid._new(X_on_disk[idxs])\ntest_eq(new_ntl[:], X_on_disk[idxs])\n\n\nsource\n\n\ntscoll_repr\n\n tscoll_repr (c, max_n=10)\n\nString repr of up to max_n items of (possibly lazy) collection c\n\nsource\n\n\nNumpyDatasets\n\n NumpyDatasets (items:list=None, tfms:MutableSequence|Pipeline=None,\n                tls:TfmdLists=None, n_inp:int=None, dl_type=None,\n                use_list:bool=None, do_setup:bool=True,\n                split_idx:int=None, train_setup:bool=True,\n                splits:list=None, types=None, verbose:bool=False)\n\nA dataset that creates tuples from X (and y) and applies tfms of type item_tfms\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nitems\nNoneType\nNone\n\n\n\ntfms\ncollections.abc.MutableSequence | fasttransform.transform.Pipeline\n\nTransform(s) or Pipeline to apply\n\n\ntls\nNoneType\nNone\n\n\n\nn_inp\nNoneType\nNone\n\n\n\ndl_type\nTfmdDL\nNone\nType of DataLoader\n\n\nuse_list\nbool\nNone\nUse list in L\n\n\ndo_setup\nbool\nTrue\nCall setup() for Transform\n\n\nsplit_idx\nint\nNone\nApply Transform(s) to training or validation set. 0 for training set and 1 for validation set\n\n\ntrain_setup\nbool\nTrue\nApply Transform(s) only on training DataLoader\n\n\nsplits\nlist\nNone\nIndices for training and validation sets\n\n\ntypes\nNoneType\nNone\nTypes of data in items\n\n\nverbose\nbool\nFalse\nPrint verbose output\n\n\n\n\nsource\n\n\nTSDatasets\n\n TSDatasets (items:list=None, tfms:MutableSequence|Pipeline=None,\n             tls:TfmdLists=None, n_inp:int=None, dl_type=None,\n             use_list:bool=None, do_setup:bool=True, split_idx:int=None,\n             train_setup:bool=True, splits:list=None, types=None,\n             verbose:bool=False)\n\nA dataset that creates tuples from X (and optionally y) and applies item_tfms\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nitems\nNoneType\nNone\n\n\n\ntfms\ncollections.abc.MutableSequence | fasttransform.transform.Pipeline\n\nTransform(s) or Pipeline to apply\n\n\ntls\nNoneType\nNone\n\n\n\nn_inp\nNoneType\nNone\n\n\n\ndl_type\nTfmdDL\nNone\nType of DataLoader\n\n\nuse_list\nbool\nNone\nUse list in L\n\n\ndo_setup\nbool\nTrue\nCall setup() for Transform\n\n\nsplit_idx\nint\nNone\nApply Transform(s) to training or validation set. 0 for training set and 1 for validation set\n\n\ntrain_setup\nbool\nTrue\nApply Transform(s) only on training DataLoader\n\n\nsplits\nlist\nNone\nIndices for training and validation sets\n\n\ntypes\nNoneType\nNone\nTypes of data in items\n\n\nverbose\nbool\nFalse\nPrint verbose output\n\n\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, splits=splits, tfms=[None, TSClassification()], inplace=True)\ni = random_choice(len(splits[0]), 10, False).tolist()\ntest_eq(dsets.subset(i), dsets.train.subset(i))\ndsets.valid.subset(i)\ndsets.valid.subset(i)[[0,6,8]]\ntest_eq(dsets.subset(i)[[0,6,8]], dsets.train.subset(i)[[0,6,8]])\ndsets.subset([0,7,3])\ndsets.subset(i), dsets.train.subset(i), dsets.valid.subset(i)\n\n((#10) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(2)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(2)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1))] ...],\n (#10) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(2)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(2)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1))] ...],\n (#10) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(2)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(2)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(3)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1))] ...])\n\n\n\ntfms = [None, TSClassification()]\ndsets = TSDatasets(X_on_disk, y_on_disk, splits=splits, tfms=tfms, inplace=False)\nassert id(X_on_disk) == id(dsets.ptls[0].items) == id(dsets.train.ptls[0].items) == id(dsets.valid.ptls[0].items)\n\ntfms = None\ndsets = TSDatasets(X_on_disk, splits=splits, tfms=tfms, inplace=False)\nassert id(X_on_disk) == id(dsets.ptls[0].items) == id(dsets.train.ptls[0].items) == id(dsets.valid.ptls[0].items)\n\n\nsource\n\n\nTSDatasets.add_unlabeled\n\n TSDatasets.add_unlabeled (X, inplace=True)\n\n\nsource\n\n\nTSDatasets.add_test\n\n TSDatasets.add_test (X, y=None, inplace=True)\n\n\nsource\n\n\nTSDatasets.add_dataset\n\n TSDatasets.add_dataset (X, y=None, inplace=True)\n\n\nsource\n\n\nNumpyDatasets.add_unlabeled\n\n NumpyDatasets.add_unlabeled (X, inplace=True)\n\n\nsource\n\n\nNumpyDatasets.add_test\n\n NumpyDatasets.add_test (X, y=None, inplace=True)\n\n\nsource\n\n\nNumpyDatasets.add_dataset\n\n NumpyDatasets.add_dataset (X, y=None, inplace=True)\n\n\nsource\n\n\nadd_ds\n\n add_ds (dsets, X, y=None, inplace=True)\n\nCreate test datasets from X (and y) using validation transforms of dsets\n\ndsets = TSDatasets(X_on_disk, y_on_disk, splits=splits, tfms=[None, TSClassification()], inplace=True)\nprint(dsets.train[0][0].shape, dsets.train[[0,1]][0].shape)\nprint(dsets.split_idx, dsets.train.split_idx, dsets.valid.split_idx)\nprint(dsets.new_empty())\ndsets\n\ntorch.Size([1, 570]) torch.Size([2, 1, 570])\nNone 0 1\n(#0) []\n\n\n(#60) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory(1))] ...]\n\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, splits=splits, tfms=[None, TSClassification()], inplace=False)\nprint(dsets.train[0][0].shape, dsets.train[[0,1]][0].shape)\nprint(dsets.split_idx, dsets.train.split_idx, dsets.valid.split_idx)\nprint(dsets.new_empty())\ndsets\n\ntorch.Size([1, 570]) torch.Size([2, 1, 570])\nNone 0 1\n(#0) []\n\n\n(#60) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([0])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([0])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([0])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([0])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([0])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([1])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([1])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([1])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([1])), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), TensorCategory([1]))] ...]\n\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, tfms=[None, TSClassification()], splits=splits, inplace=True)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\ntest_eq(dsets[idxs][1].numpy(), y_array[idxs])\n\nidxs = random_choice(len(dsets.train), 10, False)\ntest_eq(dsets.train[idxs][0].numpy(), X_on_disk[splits[0][idxs]])\ntest_eq(dsets.train[idxs][1].numpy(), y_array[splits[0][idxs]])\n\nidxs = random_choice(len(dsets.valid), 10, False)\ntest_eq(dsets.valid[idxs][0].numpy(), X_on_disk[splits[1][idxs]])\ntest_eq(dsets.valid[idxs][1].numpy(), y_array[splits[1][idxs]])\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, tfms=[None, TSClassification()], splits=splits, inplace=False)\nassert id(X_on_disk) == id(dsets.tls[0].items) == id(dsets.ptls[0].items)\nassert id(X_on_disk) == id(dsets.train.tls[0].items) == id(dsets.train.ptls[0].items)\nassert id(X_on_disk) == id(dsets.valid.tls[0].items) == id(dsets.valid.ptls[0].items)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\ntest_eq(dsets[idxs][1].numpy(), y_array[idxs])\n\n\nidxs = random_choice(len(dsets.train), 10, False)\ntest_eq(dsets.train[idxs][0].numpy(), X_on_disk[splits[0][idxs]])\ntest_eq(dsets.train[idxs][1].numpy(), y_array[splits[0][idxs]])\n\nidxs = random_choice(len(dsets.valid), 10, False)\ntest_eq(dsets.valid[idxs][0].numpy(), X_on_disk[splits[1][idxs]])\ntest_eq(dsets.valid[idxs][1].numpy(), y_array[splits[1][idxs]])\n\n\ndsets = TSDatasets(X_on_disk, splits=splits, inplace=True)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\n\nidxs = random_choice(len(dsets.train), 10, False)\ntest_eq(dsets.train[idxs][0].numpy(), X_on_disk[splits[0][idxs]])\n\nidxs = random_choice(len(dsets.valid), 10, False)\ntest_eq(dsets.valid[idxs][0].numpy(), X_on_disk[splits[1][idxs]])\n\n\ndsets = TSDatasets(X_on_disk, splits=splits, inplace=False)\nassert np.shares_memory(X_on_disk, dsets.tls[0].items)\nassert np.shares_memory(X_on_disk, dsets.ptls[0].items)\nassert np.shares_memory(X_on_disk, dsets.train.tls[0].items)\nassert np.shares_memory(X_on_disk, dsets.train.ptls[0].items)\nassert np.shares_memory(X_on_disk, dsets.valid.tls[0].items)\nassert np.shares_memory(X_on_disk, dsets.valid.ptls[0].items)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\n\nidxs = random_choice(len(dsets.train), 10, False)\ntest_eq(dsets.train[idxs][0].numpy(), X_on_disk[splits[0][idxs]])\n\nidxs = random_choice(len(dsets.valid), 10, False)\ntest_eq(dsets.valid[idxs][0].numpy(), X_on_disk[splits[1][idxs]])\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits, inplace=True)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\ntest_eq(dsets[idxs][1].numpy(), y_array[idxs])\n\nidxs = random_choice(len(dsets.train), 10, False)\ntest_eq(dsets.train[idxs][0].numpy(), X_on_disk[splits[0][idxs]])\ntest_eq(dsets.train[idxs][1].numpy(), y_array[splits[0][idxs]])\n\nidxs = random_choice(len(dsets.valid), 10, False)\ntest_eq(dsets.valid[idxs][0].numpy(), X_on_disk[splits[1][idxs]])\ntest_eq(dsets.valid[idxs][1].numpy(), y_array[splits[1][idxs]])\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits, inplace=False)\nassert np.shares_memory(X_on_disk, dsets.tls[0].items)\nassert np.shares_memory(X_on_disk, dsets.ptls[0].items)\nassert np.shares_memory(X_on_disk, dsets.train.tls[0].items)\nassert np.shares_memory(X_on_disk, dsets.train.ptls[0].items)\nassert np.shares_memory(X_on_disk, dsets.valid.tls[0].items)\nassert np.shares_memory(X_on_disk, dsets.valid.ptls[0].items)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\ntest_eq(dsets[idxs][1].numpy(), y_array[idxs])\n\nidxs = random_choice(len(dsets.train), 10, False)\ntest_eq(dsets.train[idxs][0].numpy(), X_on_disk[splits[0][idxs]])\ntest_eq(dsets.train[idxs][1].numpy(), y_array[splits[0][idxs]])\n\nidxs = random_choice(len(dsets.valid), 10, False)\ntest_eq(dsets.valid[idxs][0].numpy(), X_on_disk[splits[1][idxs]])\ntest_eq(dsets.valid[idxs][1].numpy(), y_array[splits[1][idxs]])\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, tfms=[None, TSClassification()], splits=None, inplace=True)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\ntest_eq(dsets[idxs][1].numpy(), y_array[idxs])\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, tfms=[None, TSClassification()], splits=None, inplace=False)\nassert id(X_on_disk) == id(dsets.tls[0].items) == id(dsets.ptls[0].items)\nassert id(X_on_disk) == id(dsets.train.tls[0].items) == id(dsets.train.ptls[0].items)\n\nidxs = random_choice(len(dsets), 10, False)\ntest_eq(dsets[idxs][0].numpy(), X_on_disk[idxs])\ntest_eq(dsets[idxs][1].numpy(), y_array[idxs])\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits)\ntest_eq(dsets.train[0:10], dsets.add_dataset(X_on_disk[0:10], y_array[0:10])[:])\ntest_eq(dsets.train[0:10][0], dsets.add_dataset(X_on_disk[0:10])[:][0])\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits)\ntorch.save(dsets, 'export/dsets.pth')\ndel dsets\ndsets = torch.load('export/dsets.pth', weights_only=False)\ndsets\n\n(#60) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1))] ...]\n\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits)\ntorch.save(dsets.train, 'export/dsets.pth')\ndel dsets\ndsets = torch.load('export/dsets.pth', weights_only=False)\ndsets\n\n(#30) [(TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(0)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1)), (TSTensor(vars:1, len:570, device=cpu, dtype=torch.float32), tensor(1))] ...]\n\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits)\ntest_eq(len(dsets.train), len(X_train))\ndsets = TSDatasets(X_on_disk, y_array, tfms=None, splits=splits)\ntest_eq(len(dsets.train), len(X_train))\ndsets = TSDatasets(X_on_disk, y_array, tfms=[add(1), TSCategorize()], splits=splits)\ntest_eq(len(dsets.train), len(X_train))\n# test_eq(dsets.train[0][0].data, tensor(X_train[0] + 1))\ntest_eq(dsets.train[0][1].item(), y_tensor[0])\n\n\ndsets = TSDatasets(X_on_disk, y_on_disk, tfms=[None, TSCategorize()], splits=splits)\ntest_eq(len(dsets.add_test(X_train, y_train)), len(X_train))\ntest_eq(len(dsets.add_unlabeled(X_train)), len(X_train))\n\n\nX_tensor = torch.randn(100, 4, 50)\ny_tensor = torch.randint(0, 2, size=(len(X_tensor),))\ntensor_splits = (np.arange(80), np.arange(80, 100))\ndsets = TSDatasets(X_tensor, y_tensor, tfms=[None, TSClassification()], splits=tensor_splits)\ntest_eq(type(dsets[0][0]), TSTensor)\n\n\nsource\n\n\nTSDataLoader\n\n TSDataLoader (dataset, bs=64, shuffle=False, drop_last=False,\n               num_workers=0, verbose=False, do_setup=True, vocab=None,\n               sort=False, weights=None, partial_n=None, sampler=None,\n               pin_memory=False, timeout=0, batch_size=None, indexed=None,\n               n=None, device=None, persistent_workers=False,\n               pin_memory_device='', wif=None, before_iter=None,\n               after_item=None, before_batch=None, after_batch=None,\n               after_iter=None, create_batches=None, create_item=None,\n               create_batch=None, retain=None, get_idxs=None, sample=None,\n               shuffle_fn=None, do_batch=None)\n\nTransformed DataLoader\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndataset\n\n\nMap- or iterable-style dataset from which to load the data\n\n\nbs\nint\n64\nSize of batch\n\n\nshuffle\nbool\nFalse\nWhether to shuffle data\n\n\ndrop_last\nbool\nFalse\n\n\n\nnum_workers\nint\nNone\nNumber of CPU cores to use in parallel (default: All available up to 16)\n\n\nverbose\nbool\nFalse\nWhether to print verbose logs\n\n\ndo_setup\nbool\nTrue\nWhether to run setup() for batch transform(s)\n\n\nvocab\nNoneType\nNone\n\n\n\nsort\nbool\nFalse\n\n\n\nweights\nNoneType\nNone\n\n\n\npartial_n\nNoneType\nNone\n\n\n\nsampler\nNoneType\nNone\n\n\n\npin_memory\nbool\nFalse\n\n\n\ntimeout\nint\n0\n\n\n\nbatch_size\nNoneType\nNone\n\n\n\nindexed\nNoneType\nNone\n\n\n\nn\nNoneType\nNone\n\n\n\ndevice\nNoneType\nNone\n\n\n\npersistent_workers\nbool\nFalse\n\n\n\npin_memory_device\nstr\n\n\n\n\nwif\nNoneType\nNone\n\n\n\nbefore_iter\nNoneType\nNone\n\n\n\nafter_item\nNoneType\nNone\n\n\n\nbefore_batch\nNoneType\nNone\n\n\n\nafter_batch\nNoneType\nNone\n\n\n\nafter_iter\nNoneType\nNone\n\n\n\ncreate_batches\nNoneType\nNone\n\n\n\ncreate_item\nNoneType\nNone\n\n\n\ncreate_batch\nNoneType\nNone\n\n\n\nretain\nNoneType\nNone\n\n\n\nget_idxs\nNoneType\nNone\n\n\n\nsample\nNoneType\nNone\n\n\n\nshuffle_fn\nNoneType\nNone\n\n\n\ndo_batch\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nNumpyDataLoader\n\n NumpyDataLoader (dataset, bs=64, shuffle=False, drop_last=False,\n                  num_workers=0, verbose=False, do_setup=True, vocab=None,\n                  sort=False, weights=None, partial_n=None, sampler=None,\n                  pin_memory=False, timeout=0, batch_size=None,\n                  indexed=None, n=None, device=None,\n                  persistent_workers=False, pin_memory_device='',\n                  wif=None, before_iter=None, after_item=None,\n                  before_batch=None, after_batch=None, after_iter=None,\n                  create_batches=None, create_item=None,\n                  create_batch=None, retain=None, get_idxs=None,\n                  sample=None, shuffle_fn=None, do_batch=None)\n\nTransformed DataLoader\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndataset\n\n\nMap- or iterable-style dataset from which to load the data\n\n\nbs\nint\n64\nSize of batch\n\n\nshuffle\nbool\nFalse\nWhether to shuffle data\n\n\ndrop_last\nbool\nFalse\n\n\n\nnum_workers\nint\nNone\nNumber of CPU cores to use in parallel (default: All available up to 16)\n\n\nverbose\nbool\nFalse\nWhether to print verbose logs\n\n\ndo_setup\nbool\nTrue\nWhether to run setup() for batch transform(s)\n\n\nvocab\nNoneType\nNone\n\n\n\nsort\nbool\nFalse\n\n\n\nweights\nNoneType\nNone\n\n\n\npartial_n\nNoneType\nNone\n\n\n\nsampler\nNoneType\nNone\n\n\n\npin_memory\nbool\nFalse\n\n\n\ntimeout\nint\n0\n\n\n\nbatch_size\nNoneType\nNone\n\n\n\nindexed\nNoneType\nNone\n\n\n\nn\nNoneType\nNone\n\n\n\ndevice\nNoneType\nNone\n\n\n\npersistent_workers\nbool\nFalse\n\n\n\npin_memory_device\nstr\n\n\n\n\nwif\nNoneType\nNone\n\n\n\nbefore_iter\nNoneType\nNone\n\n\n\nafter_item\nNoneType\nNone\n\n\n\nbefore_batch\nNoneType\nNone\n\n\n\nafter_batch\nNoneType\nNone\n\n\n\nafter_iter\nNoneType\nNone\n\n\n\ncreate_batches\nNoneType\nNone\n\n\n\ncreate_item\nNoneType\nNone\n\n\n\ncreate_batch\nNoneType\nNone\n\n\n\nretain\nNoneType\nNone\n\n\n\nget_idxs\nNoneType\nNone\n\n\n\nsample\nNoneType\nNone\n\n\n\nshuffle_fn\nNoneType\nNone\n\n\n\ndo_batch\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nTSDataLoaders\n\n TSDataLoaders (*loaders, path='.', device=None)\n\nBasic wrapper around several DataLoaders.\n\nsource\n\n\nNumpyDataLoaders\n\n NumpyDataLoaders (*loaders, path='.', device=None)\n\nBasic wrapper around several DataLoaders.\n\nsource\n\n\nStratifiedSampler\n\n StratifiedSampler (y, bs:int=64, shuffle:bool=False,\n                    drop_last:bool=False)\n\nSampler where batches preserve the percentage of samples for each class\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ny\n\n\nThe target variable for supervised learning problems. Stratification is done based on the y labels.\n\n\nbs\nint\n64\nBatch size\n\n\nshuffle\nbool\nFalse\nFlag to shuffle each class’s samples before splitting into batches.\n\n\ndrop_last\nbool\nFalse\nFlag to drop the last incomplete batch.\n\n\n\n\na = np.concatenate([np.zeros(90), np.ones(10)])\nsampler = StratifiedSampler(a, bs=32, shuffle=True, drop_last=True)\nidxs = np.array(list(iter(sampler)))\nprint(idxs[:32])\nprint(a[idxs][:32])\ntest_eq(a[idxs][:32].mean(), .1)\n\n[[ 1  2  5  8 10 14 16 17 26 27 31 33 34 35 38 39 50 51 53 54 55 56 58 62\n  68 69 74 76 77 86 90 93 95 97  4  6  7  9 13 15 18 20 23 24 28 29 30 37\n  41 43 44 45 60 64 70 71 75 78 79 80 81 82 84 88 92 94 98  0  3 11 12 19\n  21 22 25 32 36 40 42 46 47 48 49 52 57 59 61 63 65 66 67 72 73 83 85 87\n  89 91 96 99]]\n[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 1. 1. 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 1. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 1. 1. 1.]]\n\n\n\nsource\n\n\nget_c\n\n get_c (dls)\n\n\nsource\n\n\nget_best_dls_params\n\n get_best_dls_params (dls, n_iters=10, num_workers=[0, 1, 2, 4, 8],\n                      pin_memory=[True, False], prefetch_factor=[2, 4, 8],\n                      return_best=True, verbose=True)\n\n\nsource\n\n\nget_best_dl_params\n\n get_best_dl_params (dl, n_iters=10, num_workers=[0, 1, 2, 4, 8],\n                     pin_memory=[True, False], prefetch_factor=[2, 4, 8],\n                     return_best=True, verbose=True)\n\n\nsource\n\n\nget_ts_dls\n\n get_ts_dls (X, y=None, splits=None, sel_vars=None, sel_steps=None,\n             tfms=None, inplace=True, path='.', bs=64, batch_tfms=None,\n             num_workers=0, device=None, shuffle_train=True,\n             drop_last=True, weights=None, partial_n=None, sampler=None,\n             sort=False, **kwargs)\n\n\n# Tests\na = np.arange(10)\n\nfor s in [None, np.arange(10), np.arange(10).tolist(), L(np.arange(10).tolist()), (np.arange(10).tolist(), None), (np.arange(10).tolist(), L())]:\n    test_eq(_check_splits(a, s), (L(np.arange(10).tolist()), L()))\n\n\nsource\n\n\nget_subset_dl\n\n get_subset_dl (dl, idxs)\n\n\nsource\n\n\nget_ts_dl\n\n get_ts_dl (X, y=None, split=None, sel_vars=None, sel_steps=None,\n            tfms=None, inplace=True, path='.', bs=64, batch_tfms=None,\n            num_workers=0, device=None, shuffle_train=True,\n            drop_last=True, weights=None, partial_n=None, sampler=None,\n            sort=False, **kwargs)\n\n\nX, y, splits = get_UCR_data(dsid, on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], splits=splits, bs=8)\ndls = get_best_dls_params(dls, prefetch_factor=[2, 4, 8, 16])\n\n\nDataloader 0\n\n   num_workers:  0  pin_memory: True   prefetch_factor:  2  -  time:    0.834 ms/iter\n   num_workers:  0  pin_memory: False  prefetch_factor:  2  -  time:    0.472 ms/iter\n\n   best dl params:\n       best num_workers    : 0\n       best pin_memory     : False\n       best prefetch_factor: 2\n       return_best         : True\n\n\n\nDataloader 1\n\n   num_workers:  0  pin_memory: True   prefetch_factor:  2  -  time:    0.125 ms/iter\n   num_workers:  0  pin_memory: False  prefetch_factor:  2  -  time:    0.090 ms/iter\n\n   best dl params:\n       best num_workers    : 0\n       best pin_memory     : False\n       best prefetch_factor: 2\n       return_best         : True\n\n\n\n\n\ny_int = np.random.randint(0, 4, size=len(X))\ndls = get_ts_dls(X, y_int, splits=splits, bs=8)\ntest_eq(hasattr(dls, \"vocab\"), False)\n\ndls = get_ts_dls(X, y_int, splits=splits, bs=8, vocab=[0,1,2,3])\ntest_eq(dls.vocab, [0,1,2,3])\ntest_eq(dls.c, 4)\ntest_eq(dls.cat, True)\n\n\nX, y, splits = get_UCR_data(dsid, on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], splits=splits, bs=8)\nb=first(dls.train)\ndls.decode(b)\ntest_eq(X.shape[1], dls.vars)\ntest_eq(X.shape[-1], dls.len)\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], splits=splits, bs=64, inplace=True)\n\nidxs = random_choice(len(dls.valid_ds), 10, False)\nnew_dl = get_subset_dl(dls.train, idxs)\n\nidxs = random_choice(len(dls.valid_ds), 10, False)\nnew_dl = get_subset_dl(dls.valid, idxs)\ntest_eq(new_dl.one_batch()[0].cpu().numpy(), X[splits[1][idxs]])\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\nweights = np.random.rand(len(X))\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], splits=splits, bs=64, inplace=True, weights=weights)\nweights2 = weights[splits[0]] / weights[splits[0]].sum()\ntest_eq(dls.train.weights, weights2)\ntest_eq(dls.valid.weights, None)\n\n\npartial_n = 12\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, splits=splits, tfms=[None, TSClassification()], bs=64, inplace=True, partial_n=partial_n)\ntest_eq(len(dls.train.one_batch()[0]), partial_n)\n\npartial_n = .1\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], bs=64, inplace=True, partial_n=partial_n)\ntest_eq(len(dls.train.one_batch()[0]), int(round(len(dls.train.dataset) * partial_n)))\n\nYou’ll now be able to pass a sampler to a tsai dataloader.\nYou should use a sampler for the train set and a sampler for the validation set. You’ll need to pass an object with the same length as each dataset. For example, the splits like in the case below.\n⚠️ Remember to set shuffle=False when using a sampler since they a mutually exclusive. This means that when you use a sampler, you always need to set the shuffle in the dataloader to False. The sampler will control whether the indices are shuffled or not (you can set shuffle to True or False in the sampler).\ndrop_last is managed in the dataloder though.\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ntrain_sampler = torch.utils.data.sampler.RandomSampler(splits[0])\nvalid_sampler = torch.utils.data.sampler.SequentialSampler(splits[1])\ndls = get_ts_dls(X, y, splits=splits, tfms=[None, TSClassification()], bs=8, inplace=True,\n                 shuffle=False, drop_last=True, sampler=[train_sampler, valid_sampler])\nprint('train')\nfor _ in dls.train:\n    print(dls.train.idxs)\nprint('valid')\nfor _ in dls.valid:\n    print(dls.valid.idxs)\n\ntrain\n[np.int64(16), np.int64(5), np.int64(29), np.int64(23), np.int64(17), np.int64(3), np.int64(13), np.int64(26)]\n[np.int64(24), np.int64(22), np.int64(11), np.int64(28), np.int64(10), np.int64(25), np.int64(27), np.int64(4)]\n[np.int64(19), np.int64(0), np.int64(8), np.int64(18), np.int64(1), np.int64(20), np.int64(9), np.int64(7)]\nvalid\n[np.int64(0), np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(6), np.int64(7)]\n[np.int64(8), np.int64(9), np.int64(10), np.int64(11), np.int64(12), np.int64(13), np.int64(14), np.int64(15)]\n[np.int64(16), np.int64(17), np.int64(18), np.int64(19), np.int64(20), np.int64(21), np.int64(22), np.int64(23)]\n[np.int64(24), np.int64(25), np.int64(26), np.int64(27), np.int64(28), np.int64(29)]\n\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ntrain_sampler = torch.utils.data.sampler.SequentialSampler(splits[0])\nvalid_sampler = torch.utils.data.sampler.SequentialSampler(splits[1])\ndls = get_ts_dls(X, y, splits=splits, tfms=[None, TSClassification()], bs=64, inplace=True,\n                 shuffle=False, sampler=[train_sampler, valid_sampler])\ntest_eq(dls.get_idxs(), np.arange(len(splits[0])))\ntest_eq(dls.train.get_idxs(), np.arange(len(splits[0])))\ntest_eq(dls.valid.get_idxs(), np.arange(len(splits[1])))\nxb = dls.valid.one_batch()[0].cpu().numpy()\ntest_close(xb, X[dls.valid.split_idxs])\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ntrain_sampler = torch.utils.data.sampler.RandomSampler(splits[0])\nvalid_sampler = torch.utils.data.sampler.SequentialSampler(splits[0])\ndls = get_ts_dls(X, y, splits=splits, tfms=[None, TSClassification()], bs=32, inplace=True,\n                 shuffle=False, drop_last=True, sampler=[train_sampler, valid_sampler])\ntest_ne(dls.train.get_idxs(), np.arange(len(splits[0])))\ntest_eq(np.sort(dls.train.get_idxs()), np.arange(len(splits[0])))\ntest_eq(dls.valid.get_idxs(), np.arange(len(splits[1])))\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], splits=splits, bs=64, inplace=False)\n\nidxs = random_choice(len(dls.valid_ds), 10, False)\nnew_dl = get_subset_dl(dls.train, idxs)\n\nidxs = random_choice(len(dls.valid_ds), 10, False)\nnew_dl = get_subset_dl(dls.valid, idxs)\ntest_eq(new_dl.one_batch()[0].cpu().numpy(), X[splits[1][idxs]])\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSClassification()], splits=splits, bs=8)\nb = dls.one_batch()\ninput_idxs = dls.input_idxs\ntest_eq(b[0].cpu().numpy(), X[input_idxs])\nb = dls.train.one_batch()\ninput_idxs = dls.train.input_idxs\ntest_eq(b[0].cpu().numpy(), X[input_idxs])\nassert max(input_idxs) &lt; len(splits[0])\nb = dls.valid.one_batch()\ninput_idxs = dls.valid.input_idxs\ntest_eq(b[0].cpu().numpy(), X[input_idxs])\nassert min(input_idxs) &gt;= len(splits[0])\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSCategorize()], splits=splits, bs=8)\nb=first(dls.train)\ndls.decode(b)\ntest_eq(X.shape[1], dls.vars)\ntest_eq(X.shape[-1], dls.len)\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSCategorize()], splits=splits, bs=8, weights=np.random.randint(0, 3, len(y)))\nb=first(dls.train)\ndls.decode(b)\ntest_eq(X.shape[1], dls.vars)\ntest_eq(X.shape[-1], dls.len)\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndsets = TSDatasets(X, y, tfms=[None, TSCategorize()], splits=splits)\nts_dls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, device=default_device(), bs=4)\ntorch.save(ts_dls, 'export/ts_dls.pth')\ndel ts_dls\nts_dls = torch.load('export/ts_dls.pth', weights_only=False)\nfor xb,yb in ts_dls.train:\n    test_eq(tensor(X[ts_dls.train.idxs]), xb.cpu())\n\n\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSCategorize()], splits=splits, bs=4)\nfor xb,yb in dls.train:\n    test_eq(xb.cpu().numpy(), X[dls.train.input_idxs])\nfor xb,yb in dls.valid:\n    test_eq(xb.cpu().numpy(), X[dls.valid.input_idxs])\n\n\ntest_eq((ts_dls.train.shuffle, ts_dls.valid.shuffle, ts_dls.train.drop_last, ts_dls.valid.drop_last), (True, False, True, False))\n\n\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSCategorize()], splits=splits, bs=8, num_workers=0)\nxb, yb = first(dls.train)\ntest_eq(tensor(X[dls.train.idxs]), xb.cpu())\n\n\ntest_eq((dls.train.shuffle, dls.valid.shuffle, dls.train.drop_last, dls.valid.drop_last), (True, False, True, False))\n\n\n# multiclass\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, on_disk=True, split_data=False)\ndls = get_ts_dls(X, y, tfms=[None, TSCategorize()], splits=splits, inplace=True)\ndls.show_dist()\ndls.train.show_dist()\nxb,yb = first(dls.train)\ntest_eq((dls.cat, dls.c), (True, 4))\ntest_ne(dls.cws.cpu().numpy(), None)\ndls.decoder((xb, ))\ndls.decoder((xb[0], ))\ndls.decoder((xb, yb))\ndls.decoder((xb[0], yb[0]))\ndls.decoder(yb)\ndls.decoder(yb[0])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'2'\n\n\n\nnew_dl = dls.new_dl(X)\nfirst(new_dl)\n\n(TSTensor(samples:60, vars:1, len:570, device=mps:0, dtype=torch.float32),)\n\n\n\nnew_dl = dls.new_dl(X, y=y)\nfirst(new_dl)\n\n(TSTensor(samples:60, vars:1, len:570, device=mps:0, dtype=torch.float32),\n TensorCategory([3, 3, 0, 0, 2, 3, 1, 0, 0, 3, 2, 2, 2, 3, 3, 1, 1, 2, 1, 3, 0,\n                 1, 1, 3, 3, 3, 1, 3, 1, 3, 3, 3, 3, 3, 0, 1, 3, 0, 0, 1, 3, 1,\n                 1, 1, 3, 3, 3, 3, 3, 1, 1, 0, 2, 2, 3, 3, 2, 1, 0, 1],\n                device='mps:0'))\n\n\n\ndls.train.dataset.split_idxs, dls.train.dataset.splits, dls.valid.split_idxs\n\n(array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29], dtype=int8),\n (#30) [np.int64(0),np.int64(1),np.int64(2),np.int64(3),np.int64(4),np.int64(5),np.int64(6),np.int64(7),np.int64(8),np.int64(9),np.int64(10),np.int64(11),np.int64(12),np.int64(13),np.int64(14),np.int64(15),np.int64(16),np.int64(17),np.int64(18),np.int64(19)...],\n array([30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n        47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], dtype=int8))\n\n\n\n# 2d input array and tfms == None return a NoTfmLists object\nX, y, splits = get_UCR_data('OliveOil', on_disk=False, split_data=False)\nX = X[:, 0]\ntfms=[None, TSCategorize()]\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, bs=8)\ntest_eq(1, dls.vars)\ntest_eq(X.shape[-1], dls.len)\ntest_eq(type(dls.tls[0]).__name__, 'NoTfmLists')\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, bs=8, inplace=False)\ntest_eq(1, dls.vars)\ntest_eq(X.shape[-1], dls.len)\ntest_eq(type(dls.tls[0]).__name__, 'NoTfmLists')\n\n\n# regression\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, on_disk=True, split_data=False)\ndls = get_ts_dls(X, np.random.rand(60, ), tfms=[None, ToNumpyTensor()], splits=splits)\ndls.show_dist()\ndls.train.show_dist()\nxb,yb = first(dls.train)\ndls.decoder((xb, ))\ndls.decoder((xb[0], ))\ndls.decoder((xb, yb))\ndls.decoder((xb[0], yb[0]))\ndls.decoder(yb)\ndls.decoder(yb[0])\ntest_eq((dls.cat, dls.c), (False, 1))\ntest_eq(dls.cws, None)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# regression, multilabel\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, on_disk=True, split_data=False)\ndls = get_ts_dls(X, np.random.rand(60, 3) * 5, tfms=[None, ToNumpyTensor], splits=splits)\ndls.show_dist()\ndls.train.show_dist()\nxb,yb = first(dls.train)\ndls.decoder((xb, ))\ndls.decoder((xb[0], ))\ndls.decoder((xb, yb))\ndls.decoder((xb[0], yb[0]))\ndls.decoder(yb)\ndls.decoder(yb[0])\ntest_eq((dls.cat, dls.c, dls.d),(False, 1, 3))\ntest_eq(dls.cws, None)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# multiclass, multilabel\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, on_disk=True, split_data=False)\ncm = {\n    '1':'A',\n    '2':['B', 'C'],\n    '3':['B', 'D'] ,\n    '4':'E',\n    }\nkeys = cm.keys()\nnew_cm = {k:v for k,v in zip(keys, [listify(v) for v in cm.values()])}\ny_multi = np.array([new_cm[yi] if yi in keys else listify(yi) for yi in y], dtype=object)\ndls = get_ts_dls(X, y_multi, tfms=[None, TSMultiLabelClassification()], splits=splits)\ndls.show_dist()\ndls.train.show_dist()\nxb,yb = first(dls.train)\ndls.decoder((xb, ))\ndls.decoder((xb[0], ))\ndls.decoder((xb, yb))\ndls.decoder((xb[0], yb[0]))\ndls.decoder(yb)\ndls.decoder(yb[0])\ntest_eq((dls.cat, dls.c), (True, 5))\ntest_ne(dls.cws.cpu().numpy(), None)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndsid = 'OliveOil'\nX, y, splits = get_UCR_data(dsid, on_disk=True, split_data=False)\ncm = {\n    '1':'A',\n    '2':['B', 'C'],\n    '3':['B', 'D'] ,\n    '4':'E',\n    }\nkeys = cm.keys()\nnew_cm = {k:v for k,v in zip(keys, [listify(v) for v in cm.values()])}\ny_multi = np.array([new_cm[yi] if yi in keys else listify(yi) for yi in y], dtype=object)\ndls = get_ts_dls(X, y_multi, tfms=[None, TSMultiLabelClassification()], splits=splits)\ntest_eq(dls.new(X[0]).one_batch().shape, (1, 570))\ntest_eq(dls.new(X[:15]).one_batch().shape, (15, 1, 570))\ntest_eq(dls.train.new(X[0]).one_batch().shape, (1, 570))\ntest_eq(dls.valid.new(X[:15]).one_batch().shape, (15, 1, 570))\n\n\nbs = 25\ndsets = TSDatasets(X, y, tfms=[None, TSCategorize()], splits=splits)\ndls   = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=[bs, bs*2], batch_tfms=add(1), num_workers=0)\nxb,yb = dls.train.one_batch()\ntest_eq(xb.cpu().data, tensor(X_on_disk[splits[0]][dls.train.idxs]) + 1)\n\n\ndsets = TSDatasets(X, y, tfms=[None, TSCategorize()], splits=splits)\ndls   = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=[bs, bs*2])\nxb,yb = dls.train.one_batch()\ntest_eq(xb.shape, (min(bs, len(splits[0])), X.shape[1], X.shape[-1]))\nit = iter(dls.valid)\nfor xb,yb in it:\n    test_close(xb.cpu(), TSTensor(X[splits[1]][dls.valid.idxs]))\n\n\nbs = 64\ndsets = TSDatasets(X, y, tfms=[add(1), TSCategorize()], splits=RandomSplitter(valid_pct=.3)(y_array))\ndls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=[bs, bs*2])\nxb,yb = dls.train.one_batch()\ntest_eq(xb.shape, (min(bs, len(dsets.train)), X_on_disk.shape[1], X_on_disk.shape[-1]))\nxb,yb = dls.valid.one_batch()\ntest_eq(xb.shape, (min(bs*2, len(dsets.valid)), X_on_disk.shape[1], X_on_disk.shape[-1]))\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=[None, TSCategorize()], splits=splits)\ndls   = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=[32, 64])\nfor i in range(10):\n    dl = dls.train if random.random() &lt; .5 else dls.valid\n    xb,yb = dl.one_batch()\n    torch.equal(xb.cpu(), TSTensor(X_on_disk[dl.input_idxs]))\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=[None, TSCategorize()])\ndls   = TSDataLoaders.from_dsets(dsets, bs=32)\nfor i in range(10):\n    xb,yb = dls.one_batch()\n    torch.equal(xb.cpu(), TSTensor(X_on_disk[dl.input_idxs]))\n\ndsets = TSDatasets(X_on_disk, tfms=None)\ndls   = TSDataLoaders.from_dsets(dsets, bs=32)\nfor i in range(10):\n    xb = dls.one_batch()\n    torch.equal(xb[0].cpu(), TSTensor(X_on_disk[dl.input_idxs]))\n\n\ndsets = TSDatasets(X_on_disk, y_array, tfms=[None, TSCategorize()])\ndls   = TSDataLoaders.from_dsets(dsets, bs=32)\ntest_eq(dls.split_idxs, L(np.arange(len(X_on_disk)).tolist()))\n\n\nX, y, splits = get_UCR_data('NATOPS', return_split=False)\ntfms  = [None, [TSCategorize()]]\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits, bs=[64, 128])\ndls.show_batch()\ndls.show_dist()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# test passing a list with categories instead of a numpy array\ndsid = 'NATOPS'\nbs = 64\nX2, y2, splits2 = get_UCR_data(dsid, return_split=False)\nvocab = sorted(set(y))\ntfms = [None, [TSCategorize(vocab=vocab)]]\ndsets = TSDatasets(X2, y2, tfms=tfms, splits=splits2)\ndls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=[bs, bs*2])\ndls.train.one_batch()\n\n(TSTensor(samples:64, vars:24, len:51, device=mps:0, dtype=torch.float32),\n TensorCategory([0, 2, 0, 3, 3, 0, 0, 4, 5, 1, 5, 5, 2, 0, 0, 4, 4, 5, 3, 2, 4,\n                 5, 0, 3, 0, 0, 1, 4, 3, 3, 2, 5, 0, 3, 0, 5, 3, 1, 1, 0, 2, 4,\n                 2, 5, 0, 4, 3, 3, 1, 2, 2, 0, 3, 1, 0, 2, 0, 3, 3, 2, 4, 5, 5,\n                 2], device='mps:0'))\n\n\n\n# MultiCategory\nbs = 64\nn_epochs = 100\ntfms = [None, [MultiCategorize()]]\ndsets = TSDatasets(X2, y2, tfms=tfms, splits=splits2)\ndls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=bs)\ndls.train.one_batch()\n\n(TSTensor(samples:64, vars:24, len:51, device=mps:0, dtype=torch.float32),\n TensorMultiCategory([[7, 0, 1],\n                      [3, 0, 1],\n                      [6, 0, 1],\n                      [3, 0, 1],\n                      [3, 0, 1],\n                      [2, 0, 1],\n                      [5, 0, 1],\n                      [6, 0, 1],\n                      [4, 0, 1],\n                      [5, 0, 1],\n                      [2, 0, 1],\n                      [6, 0, 1],\n                      [3, 0, 1],\n                      [5, 0, 1],\n                      [2, 0, 1],\n                      [6, 0, 1],\n                      [5, 0, 1],\n                      [5, 0, 1],\n                      [2, 0, 1],\n                      [6, 0, 1],\n                      [2, 0, 1],\n                      [2, 0, 1],\n                      [6, 0, 1],\n                      [5, 0, 1],\n                      [3, 0, 1],\n                      [6, 0, 1],\n                      [5, 0, 1],\n                      [2, 0, 1],\n                      [5, 0, 1],\n                      [2, 0, 1],\n                      [2, 0, 1],\n                      [4, 0, 1],\n                      [5, 0, 1],\n                      [7, 0, 1],\n                      [3, 0, 1],\n                      [7, 0, 1],\n                      [6, 0, 1],\n                      [4, 0, 1],\n                      [2, 0, 1],\n                      [3, 0, 1],\n                      [3, 0, 1],\n                      [3, 0, 1],\n                      [4, 0, 1],\n                      [7, 0, 1],\n                      [6, 0, 1],\n                      [2, 0, 1],\n                      [4, 0, 1],\n                      [2, 0, 1],\n                      [6, 0, 1],\n                      [5, 0, 1],\n                      [4, 0, 1],\n                      [2, 0, 1],\n                      [3, 0, 1],\n                      [5, 0, 1],\n                      [3, 0, 1],\n                      [5, 0, 1],\n                      [5, 0, 1],\n                      [6, 0, 1],\n                      [7, 0, 1],\n                      [2, 0, 1],\n                      [2, 0, 1],\n                      [7, 0, 1],\n                      [7, 0, 1],\n                      [6, 0, 1]], device='mps:0'))\n\n\nThe combination of splits, sel_vars and sel_steps is very powerful, as it allows you to perform advanced indexing of the array-like X.\n\nfrom tsai.data.validation import TSSplitter\n\n\nX = np.arange(16*5*50).reshape(16,5,50)\ny = alphabet[np.random.randint(0,3, 16)]\nsplits = TSSplitter(show_plot=False)(y)\ntfms = [None, TSCategorize()]\nbatch_tfms = None\ndls = get_ts_dls(X, y, splits=splits, sel_vars=[0, 1, 3], sel_steps=slice(-10, None), tfms=tfms, batch_tfms=batch_tfms)\nxb,yb=dls.train.one_batch()\ntest_close(X[dls.input_idxs][:, [0, 1, 3]][...,slice(-10, None)], xb.cpu().numpy())\nnew_dl = dls.train.new_dl(X[:5], y[:5])\nprint(new_dl.one_batch())\nnew_empty_dl = dls.new_empty() # when exported\ndl = new_empty_dl.new_dl(X[:10], y[:10], bs=64) # after export\ndl.one_batch()\n\n(TSTensor(samples:5, vars:3, len:10, device=mps:0, dtype=torch.int64), TensorCategory([0, 0, 0, 1, 0], device='mps:0'))\n\n\n(TSTensor(samples:10, vars:3, len:10, device=mps:0, dtype=torch.int64),\n TensorCategory([1, 0, 1, 2, 0, 0, 0, 1, 0, 0], device='mps:0'))\n\n\n\nsource\n\n\nget_dl_percent_per_epoch\n\n get_dl_percent_per_epoch (dl, model, n_batches=None)\n\n\nsource\n\n\nget_time_per_batch\n\n get_time_per_batch (dl, model=None, n_batches=None)\n\n\nX, y, splits = get_UCR_data('NATOPS', split_data=False)\ntfms  = [None, [TSCategorize()]]\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits)\ntrain_dl = dls.train\nxb, _ = train_dl.one_batch()\nmodel = nn.Linear(xb.shape[-1], 2).to(xb.device)\nt = get_dl_percent_per_epoch(train_dl, model, n_batches=10)\nprint(t)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n25.53%",
    "crumbs": [
      "Data",
      "Data Core"
    ]
  },
  {
    "objectID": "tslearner.html",
    "href": "tslearner.html",
    "title": "TSLearner",
    "section": "",
    "text": "New set of time series learners with a new sklearn-like API that simplifies the learner creation. The following classes are included:",
    "crumbs": [
      "Training",
      "TSLearner"
    ]
  },
  {
    "objectID": "tslearner.html#tsclassifier-api",
    "href": "tslearner.html#tsclassifier-api",
    "title": "TSLearner",
    "section": "TSClassifier API",
    "text": "TSClassifier API\n\nCommonly used arguments:\n\nX: array-like of shape (n_samples, n_steps) or (n_samples, n_features, n_steps) with the input time series samples. Internally, they will be converted to torch tensors.\ny: array-like of shape (n_samples), (n_samples, n_outputs) or (n_samples, n_features, n_outputs) with the target. Internally, they will be converted to torch tensors. Default=None. None is used for unlabeled datasets.\nsplits: lists of indices used to split data between train and validation. Default=None. If no splits are passed, data will be split 100:0 between train and test without shuffling.\ntfms: item transforms that will be applied to each sample individually. Default:None.\nbatch_tfms: transforms applied to each batch. Default=None.\npipelines: store sklearn-type pipelines that can then be applied to pandas dataframes with transform or inverse_transform methods. Default=None.\nbs: batch size (if batch_size is provided then batch_size will override bs). An int or a list of ints can be passed. Default=[64, 128]. If a list of ints, the first one will be used for training, and the second for the valid (batch size can be larger as it doesn’t require backpropagation which consumes more memory).\narch: indicates which architecture will be used. Alternatively, you can pass an instantiated model. Default: InceptionTimePlus.\narch_config: keyword arguments passed to the selected architecture. Default={}.\npretrained: indicates if pretrained model weights will be used. Default=False.\nweights_path: indicates the path to the pretrained weights in case they are used.\nloss_func: allows you to pass any loss function. Default=None (in which case CrossEntropyLossFlat() is applied).\nopt_func: allows you to pass an optimizer. Default=Adam.\nlr: learning rate. Default=0.001.\nmetrics: list of metrics passed to the Learner. Default=accuracy.\ncbs: list of callbacks passed to the Learner. Default=None.\nwd: is the default weight decay used when training the model. Default=None.\n\nLess frequently used arguments:\n\nsel_vars: used to select which of the features in multivariate datasets are used. Default=None means all features are used. If necessary a list-like of indices can be used (eg.[0,3,5]).\nsel_steps: used to select the steps used. Default=None means all steps are used. If necessary a list-like of indices can be used (eg. slice(-50, None) will select the last 50 steps from each time series).\ns_cat_idxs: list of indices for static categorical variables\ns_cat_embeddings: list of num_embeddings for each static categorical variable\ns_cat_embedding_dims: list of embedding dimensions for each static categorical variable\ns_cont_idxs: list of indices for static continuous variables\no_cat_idxs: list of indices for observed categorical variables\no_cat_embeddings: list of num_embeddings for each observed categorical variable\no_cat_embedding_dims: list of embedding dimensions for each observed categorical variable\no_cont_idxs: list of indices for observed continuous variables\npatch_len: Number of time steps in each patch.\npatch_stride: Stride of the patch.\nfusion_layers: list of layer dimensions for the fusion MLP\nfusion_act: activation function for the fusion MLP\nfusion_dropout: dropout probability for the fusion MLP\nfusion_use_bn: boolean indicating whether to use batch normalization in the fusion MLP\nweights: indicates a sample weight per instance. Used to pass pass a probability to the train dataloader sampler. Samples with more weight will be selected more often during training.\npartial_n: select randomly partial quantity of data at each epoch. Used to reduce the training size (for example for testing purposes). int or float can be used.\nvocab: vocabulary used to transform the target. Only required when transformed is not perform by a dataloader’s tfm (external transforms).\ntrain_metrics: flag used to display metrics in the training set. Defaults to False.\nvalid_metrics: flag used to display metrics in the validtion set. Defaults to True.\ninplace: indicates whether tfms are applied during instantiation or on-the-fly. Default=True, which means that tfms will be applied during instantiation. This results in a faster training, but it can only be used when data fits in memory. Otherwise set it to False.\nshuffle_train: indicates whether to shuffle the training set every time the dataloader is fully read/iterated or not. This doesn’t have an impact on the validation set which is never shuffled. Default=True.\ndrop_last: if True the last incomplete training batch is dropped (thus ensuring training batches of equal size). This doesn’t have an impact on the validation set where samples are never dropped. Default=True.\nnum_workers: num_workers (int): how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. Default=0.\ndo_setup: ndicates if the Pipeline.setup method should be called during initialization. Default=True.\ndevice: Defaults to default_device() which is CUDA by default. You can specify device as `torch.device(‘cpu’).\nseed: Set to an int to ensure reprodubibility. Default=None.\nverbose: controls the verbosity when fitting and predicting.\nexclude_head: indicates whether the head of the pretrained model needs to be removed or not. Default=True.\ncut: indicates the position where the pretrained model head needs to be cut. Defaults=-1.\ninit: allows you to set to None (no initialization applied), set to True (in which case nn.init.kaiming_normal_ will be applied) or pass an initialization. Default=None.\nsplitter: To do transfer learning, you need to pass a splitter to Learner. This should be a function taking the model and returning a collection of parameter groups, e.g. a list of list of parameters. Default=trainable_params. If the model has a backbone and a head, it will then be split in those 2 groups.\npath and model_dir: are used to save and/or load models. Often path will be inferred from dls, but you can override it or pass a Path object to model_dir.\nwd_bn_bias: controls if weight decay is applied to BatchNorm layers and bias. Default=False. train_bn=True\nmoms: the default momentums used in Learner.fit_one_cycle. Default=(0.95, 0.85, 0.95).\n\n\nsource\n\nTSClassifier\n\n TSClassifier (X, y=None, splits=None, tfms=None, inplace=True,\n               sel_vars=None, sel_steps=None, s_cat_idxs=None,\n               s_cat_embeddings=None, s_cat_embedding_dims=None,\n               s_cont_idxs=None, o_cat_idxs=None, o_cat_embeddings=None,\n               o_cat_embedding_dims=None, o_cont_idxs=None,\n               patch_len=None, patch_stride=None, fusion_layers=128,\n               fusion_act='relu', fusion_dropout=0.0, fusion_use_bn=True,\n               weights=None, partial_n=None, vocab=None,\n               train_metrics=False, valid_metrics=True, bs=[64, 128],\n               batch_size=None, batch_tfms=None, pipelines=None,\n               shuffle_train=True, drop_last=True, num_workers=0,\n               do_setup=True, device=None, seed=None, arch=None,\n               arch_config={}, pretrained=False, weights_path=None,\n               exclude_head=True, cut=-1, init=None, loss_func=None,\n               opt_func=&lt;function Adam&gt;, lr=0.001, metrics=&lt;function\n               accuracy&gt;, cbs=None, wd=None, wd_bn_bias=False,\n               train_bn=True, moms=(0.95, 0.85, 0.95), path='.',\n               model_dir='models', splitter=&lt;function trainable_params&gt;,\n               verbose=False)\n\nGroup together a model, some dls and a loss_func to handle training\n\nfrom tsai.data.external import *\nfrom tsai.data.preprocessing import *\nfrom tsai.models.InceptionTimePlus import *\n\n\n# With validation split\nX, y, splits = get_classification_data('OliveOil', split_data=False)\ntfms = [None, TSClassification()]\nbatch_tfms = [TSStandardize(by_sample=True)]\nlearn = TSClassifier(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, metrics=accuracy, arch=InceptionTimePlus, arch_config=dict(fc_dropout=.5),\n                     train_metrics=True)\nlearn.fit_one_cycle(1)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\ntrain_accuracy\nvalid_loss\nvalid_accuracy\ntime\n\n\n\n\n0\n1.620233\n0.200000\n1.466389\n0.300000\n00:00\n\n\n\n\n\n\n# Without validation split\nX, y, splits = get_classification_data('OliveOil', split_data=False)\nsplits = (splits[0], None)\ntfms = [None, TSClassification()]\nbatch_tfms = [TSStandardize(by_sample=True)]\nlearn = TSClassifier(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms, metrics=accuracy, arch=InceptionTimePlus, arch_config=dict(fc_dropout=.5),\n                     train_metrics=True)\nlearn.fit_one_cycle(1)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\naccuracy\ntime\n\n\n\n\n0\n1.362660\n0.333333\n00:00\n\n\n\n\n\n\nnum_classes = 2\nX = np.random.rand(16, 5, 128)\ny = np.random.randint(0, num_classes, (16, 3))\nsplits = RandomSplitter()(range_of(X))\narch = 'TSiTPlus'\nvocab = np.arange(num_classes)\nlearn = TSClassifier(X, y, splits=splits, arch=arch, metrics=accuracy, vocab=vocab, device=default_device())\nlearn.fit_one_cycle(1, 1e-3)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.792934\n0.762534\n0.444444\n00:00\n\n\n\n\n\n\nnum_classes = 5\nX = torch.rand(8, 2, 50)\ny = torch.randint(0, num_classes, (len(X), 7))\nprint(X.shape, y.shape)\nsplits = TimeSplitter(show_plot=False)(y)\nvocab = np.arange(num_classes)\n\nfail_test = []\nfor arch in all_arch_names:\n    if not \"plus\" in arch.lower(): continue\n    try:\n        learn = TSClassifier(X, y, splits=splits, arch=arch, metrics=accuracy, vocab=vocab, device=default_device())\n        with ContextManagers([learn.no_bar(), learn.no_logging()]):\n            learn.fit_one_cycle(1, 1e-3)\n        del learn\n        gc.collect()\n    except Exception as e:\n        fail_test.append(arch)\n        print(arch, e)\n\ntest_eq(fail_test, [])\n\ntorch.Size([8, 2, 50]) torch.Size([8, 7])",
    "crumbs": [
      "Training",
      "TSLearner"
    ]
  },
  {
    "objectID": "tslearner.html#tsregressor-api",
    "href": "tslearner.html#tsregressor-api",
    "title": "TSLearner",
    "section": "TSRegressor API",
    "text": "TSRegressor API\n\nCommonly used arguments:\n\nX: array-like of shape (n_samples, n_steps) or (n_samples, n_features, n_steps) with the input time series samples. Internally, they will be converted to torch tensors.\ny: array-like of shape (n_samples), (n_samples, n_outputs) or (n_samples, n_features, n_outputs) with the target. Internally, they will be converted to torch tensors. Default=None. None is used for unlabeled datasets.\nsplits: lists of indices used to split data between train and validation. Default=None. If no splits are passed, data will be split 100:0 between train and test without shuffling.\ntfms: item transforms that will be applied to each sample individually. Default=None.\nbatch_tfms: transforms applied to each batch. Default=None.\npipelines: store sklearn-type pipelines that can then be applied to pandas dataframes with transform or inverse_transform methods. Default=None.\nbs: batch size (if batch_size is provided then batch_size will override bs). An int or a list of ints can be passed. Default=[64, 128]. If a list of ints, the first one will be used for training, and the second for the valid (batch size can be larger as it doesn’t require backpropagation which consumes more memory).\narch: indicates which architecture will be used. Alternatively, you can pass an instantiated model. Default: InceptionTimePlus.\narch_config: keyword arguments passed to the selected architecture. Default={}.\npretrained: indicates if pretrained model weights will be used. Default=False.\nweights_path: indicates the path to the pretrained weights in case they are used.\nloss_func: allows you to pass any loss function. Default=None (in which case CrossEntropyLossFlat() is applied).\nopt_func: allows you to pass an optimizer. Default=Adam.\nlr: learning rate. Default=0.001.\nmetrics: list of metrics passed to the Learner. Default=None.\ncbs: list of callbacks passed to the Learner. Default=None.\nwd: is the default weight decay used when training the model. Default=None.\n\nLess frequently used arguments:\n\nsel_vars: used to select which of the features in multivariate datasets are used. Default=None means all features are used. If necessary a list-like of indices can be used (eg.[0,3,5]).\nsel_steps: used to select the steps used. Default=None means all steps are used. If necessary a list-like of indices can be used (eg. slice(-50, None) will select the last 50 steps from each time series).\ns_cat_idxs: list of indices for static categorical variables\ns_cat_embeddings: list of num_embeddings for each static categorical variable\ns_cat_embedding_dims: list of embedding dimensions for each static categorical variable\ns_cont_idxs: list of indices for static continuous variables\no_cat_idxs: list of indices for observed categorical variables\no_cat_embeddings: list of num_embeddings for each observed categorical variable\no_cat_embedding_dims: list of embedding dimensions for each observed categorical variable\no_cont_idxs: list of indices for observed continuous variables\npatch_len: Number of time steps in each patch.\npatch_stride: Stride of the patch.\nfusion_layers: list of layer dimensions for the fusion MLP\nfusion_act: activation function for the fusion MLP\nfusion_dropout: dropout probability for the fusion MLP\nfusion_use_bn: boolean indicating whether to use batch normalization in the fusion MLP\nweights: indicates a sample weight per instance. Used to pass pass a probability to the train dataloader sampler. Samples with more weight will be selected more often during training.\npartial_n: select randomly partial quantity of data at each epoch. Used to reduce the training size (for example for testing purposes). int or float can be used.\ntrain_metrics: flag used to display metrics in the training set. Defaults to False.\nvalid_metrics: flag used to display metrics in the validtion set. Defaults to True.\ninplace: indicates whether tfms are applied during instantiation or on-the-fly. Default=True, which means that tfms will be applied during instantiation. This results in a faster training, but it can only be used when data fits in memory. Otherwise set it to False.\nshuffle_train: indicates whether to shuffle the training set every time the dataloader is fully read/iterated or not. This doesn’t have an impact on the validation set which is never shuffled. Default=True.\ndrop_last: if True the last incomplete training batch is dropped (thus ensuring training batches of equal size). This doesn’t have an impact on the validation set where samples are never dropped. Default=True.\nnum_workers: num_workers (int): how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. Default=0.\ndo_setup: ndicates if the Pipeline.setup method should be called during initialization. Default=True.\ndevice: Defaults to default_device() which is CUDA by default. You can specify device as `torch.device(‘cpu’).\nseed: Set to an int to ensure reprodubibility. Default=None.\nverbose: controls the verbosity when fitting and predicting.\nexclude_head: indicates whether the head of the pretrained model needs to be removed or not. Default=True.\ncut: indicates the position where the pretrained model head needs to be cut. Defaults=-1.\ninit: allows you to set to None (no initialization applied), set to True (in which case nn.init.kaiming_normal_ will be applied) or pass an initialization. Default=None.\nsplitter: To do transfer learning, you need to pass a splitter to Learner. This should be a function taking the model and returning a collection of parameter groups, e.g. a list of list of parameters. Default=trainable_params. If the model has a backbone and a head, it will then be split in those 2 groups.\npath and model_dir: are used to save and/or load models. Often path will be inferred from dls, but you can override it or pass a Path object to model_dir.\nwd_bn_bias: controls if weight decay is applied to BatchNorm layers and bias. Default=False. train_bn=True\nmoms: the default momentums used in Learner.fit_one_cycle. Default=(0.95, 0.85, 0.95).\n\n\nsource\n\nTSRegressor\n\n TSRegressor (X, y=None, splits=None, tfms=None, inplace=True,\n              sel_vars=None, sel_steps=None, s_cat_idxs=None,\n              s_cat_embeddings=None, s_cat_embedding_dims=None,\n              s_cont_idxs=None, o_cat_idxs=None, o_cat_embeddings=None,\n              o_cat_embedding_dims=None, o_cont_idxs=None, patch_len=None,\n              patch_stride=None, fusion_layers=128, fusion_act='relu',\n              fusion_dropout=0.0, fusion_use_bn=True, weights=None,\n              partial_n=None, train_metrics=False, valid_metrics=True,\n              bs=[64, 128], batch_size=None, batch_tfms=None,\n              pipelines=None, shuffle_train=True, drop_last=True,\n              num_workers=0, do_setup=True, device=None, seed=None,\n              arch=None, arch_config={}, pretrained=False,\n              weights_path=None, exclude_head=True, cut=-1, init=None,\n              loss_func=None, opt_func=&lt;function Adam&gt;, lr=0.001,\n              metrics=None, cbs=None, wd=None, wd_bn_bias=False,\n              train_bn=True, moms=(0.95, 0.85, 0.95), path='.',\n              model_dir='models', splitter=&lt;function trainable_params&gt;,\n              verbose=False)\n\nGroup together a model, some dls and a loss_func to handle training\n\nX, y, splits = get_regression_data('AppliancesEnergy', split_data=False)\nif X is not None: # This is to prevent a test fail when the data server is not available\n    X = X.astype('float32')\n    y = y.astype('float32')\n    batch_tfms = [TSStandardize()]\n    learn = TSRegressor(X, y, splits=splits, batch_tfms=batch_tfms, arch=None, metrics=mae, bs=512, train_metrics=True, device=default_device())\n    learn.fit_one_cycle(1, 1e-4)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\ntrain_mae\nvalid_loss\nvalid_mae\ntime\n\n\n\n\n0\n215.481400\n14.030172\n202.221893\n13.798750\n00:00",
    "crumbs": [
      "Training",
      "TSLearner"
    ]
  },
  {
    "objectID": "tslearner.html#tsforecaster-api",
    "href": "tslearner.html#tsforecaster-api",
    "title": "TSLearner",
    "section": "TSForecaster API",
    "text": "TSForecaster API\n\nCommonly used arguments:\n\nX: array-like of shape (n_samples, n_steps) or (n_samples, n_features, n_steps) with the input time series samples. Internally, they will be converted to torch tensors.\ny: array-like of shape (n_samples), (n_samples, n_outputs) or (n_samples, n_features, n_outputs) with the target. Internally, they will be converted to torch tensors. Default=None. None is used for unlabeled datasets.\nsplits: lists of indices used to split data between train and validation. Default=None. If no splits are passed, data will be split 100:0 between train and test without shuffling.\ntfms: item transforms that will be applied to each sample individually. Default=None.\nbatch_tfms: transforms applied to each batch. Default=None.\npipelines: store sklearn-type pipelines that can then be applied to pandas dataframes with transform or inverse_transform methods. Default=None.\nbs: batch size (if batch_size is provided then batch_size will override bs). An int or a list of ints can be passed. Default=[64, 128]. If a list of ints, the first one will be used for training, and the second for the valid (batch size can be larger as it doesn’t require backpropagation which consumes more memory).\narch: indicates which architecture will be used. Alternatively, you can pass an instantiated model. Default: InceptionTimePlus.\narch_config: keyword arguments passed to the selected architecture. Default={}.\npretrained: indicates if pretrained model weights will be used. Default=False.\nweights_path: indicates the path to the pretrained weights in case they are used.\nloss_func: allows you to pass any loss function. Default=None (in which case CrossEntropyLossFlat() is applied).\nopt_func: allows you to pass an optimizer. Default=Adam.\nlr: learning rate. Default=0.001.\nmetrics: list of metrics passed to the Learner. Default=None.\ncbs: list of callbacks passed to the Learner. Default=None.\nwd: is the default weight decay used when training the model. Default=None.\n\nLess frequently used arguments:\n\nsel_vars: used to select which of the features in multivariate datasets are used. Default=None means all features are used. If necessary a list-like of indices can be used (eg.[0,3,5]).\nsel_steps: used to select the steps used. Default=None means all steps are used. If necessary a list-like of indices can be used (eg. slice(-50, None) will select the last 50 steps from each time series).\ns_cat_idxs: list of indices for static categorical variables\ns_cat_embeddings: list of num_embeddings for each static categorical variable\ns_cat_embedding_dims: list of embedding dimensions for each static categorical variable\ns_cont_idxs: list of indices for static continuous variables\no_cat_idxs: list of indices for observed categorical variables\no_cat_embeddings: list of num_embeddings for each observed categorical variable\no_cat_embedding_dims: list of embedding dimensions for each observed categorical variable\no_cont_idxs: list of indices for observed continuous variables\npatch_len: Number of time steps in each patch.\npatch_stride: Stride of the patch.\nfusion_layers: list of layer dimensions for the fusion MLP\nfusion_act: activation function for the fusion MLP\nfusion_dropout: dropout probability for the fusion MLP\nfusion_use_bn: boolean indicating whether to use batch normalization in the fusion MLP\nweights: indicates a sample weight per instance. Used to pass pass a probability to the train dataloader sampler. Samples with more weight will be selected more often during training.\npartial_n: select randomly partial quantity of data at each epoch. Used to reduce the training size (for example for testing purposes). int or float can be used.\ntrain_metrics: flag used to display metrics in the training set. Defaults to False.\nvalid_metrics: flag used to display metrics in the validtion set. Defaults to True.\ninplace: indicates whether tfms are applied during instantiation or on-the-fly. Default=True, which means that tfms will be applied during instantiation. This results in a faster training, but it can only be used when data fits in memory. Otherwise set it to False.\nshuffle_train: indicates whether to shuffle the training set every time the dataloader is fully read/iterated or not. This doesn’t have an impact on the validation set which is never shuffled. Default=True.\ndrop_last: if True the last incomplete training batch is dropped (thus ensuring training batches of equal size). This doesn’t have an impact on the validation set where samples are never dropped. Default=True.\nnum_workers: num_workers (int): how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. Default=None.\ndo_setup: ndicates if the Pipeline.setup method should be called during initialization. Default=True.\ndevice: Defaults to default_device() which is CUDA by default. You can specify device as `torch.device(‘cpu’).\nseed: Set to an int to ensure reprodubibility. Default=None.\nverbose: controls the verbosity when fitting and predicting.\nexclude_head: indicates whether the head of the pretrained model needs to be removed or not. Default=True.\ncut: indicates the position where the pretrained model head needs to be cut. Defaults=-1.\ninit: allows you to set to None (no initialization applied), set to True (in which case nn.init.kaiming_normal_ will be applied) or pass an initialization. Default=None.\nsplitter: To do transfer learning, you need to pass a splitter to Learner. This should be a function taking the model and returning a collection of parameter groups, e.g. a list of list of parameters. Default=trainable_params. If the model has a backbone and a head, it will then be split in those 2 groups.\npath and model_dir: are used to save and/or load models. Often path will be inferred from dls, but you can override it or pass a Path object to model_dir.\nwd_bn_bias: controls if weight decay is applied to BatchNorm layers and bias. Default=False. train_bn=True\nmoms: the default momentums used in Learner.fit_one_cycle. Default=(0.95, 0.85, 0.95).\n\n\nsource\n\nTSForecaster\n\n TSForecaster (X, y=None, splits=None, tfms=None, inplace=True,\n               sel_vars=None, sel_steps=None, s_cat_idxs=None,\n               s_cat_embeddings=None, s_cat_embedding_dims=None,\n               s_cont_idxs=None, o_cat_idxs=None, o_cat_embeddings=None,\n               o_cat_embedding_dims=None, o_cont_idxs=None,\n               patch_len=None, patch_stride=None, fusion_layers=128,\n               fusion_act='relu', fusion_dropout=0.0, fusion_use_bn=True,\n               weights=None, partial_n=None, train_metrics=False,\n               valid_metrics=True, bs=[64, 128], batch_size=None,\n               batch_tfms=None, pipelines=None, shuffle_train=True,\n               drop_last=True, num_workers=0, do_setup=True, device=None,\n               seed=None, arch=None, arch_config={}, pretrained=False,\n               weights_path=None, exclude_head=True, cut=-1, init=None,\n               loss_func=None, opt_func=&lt;function Adam&gt;, lr=0.001,\n               metrics=None, cbs=None, wd=None, wd_bn_bias=False,\n               train_bn=True, moms=(0.95, 0.85, 0.95), path='.',\n               model_dir='models', splitter=&lt;function trainable_params&gt;,\n               verbose=False)\n\nGroup together a model, some dls and a loss_func to handle training\n\nfrom tsai.data.preparation import *\n\n\nts = get_forecasting_time_series('Sunspots')\nif ts is not None: # This is to prevent a test fail when the data server is not available\n    X, y = SlidingWindowSplitter(60, horizon=1)(ts)\n    X, y = X.astype('float32'), y.astype('float32')\n    splits = TSSplitter(235)(y)\n    batch_tfms = [TSStandardize(by_var=True)]\n    learn = TSForecaster(X, y, splits=splits, batch_tfms=batch_tfms, arch=None, arch_config=dict(fc_dropout=.5), metrics=mae, bs=512,\n                         partial_n=.1, train_metrics=True, device=default_device())\n    learn.fit_one_cycle(1)\n\nDataset: Sunspots\ndownloading data...\n...done. Path = data/forecasting/Sunspots.csv\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\ntrain_mae\nvalid_loss\nvalid_mae\ntime\n\n\n\n\n0\n4688.818359\n52.336243\n7955.546387\n74.580894\n00:00\n\n\n\n\n\n\nX=torch.rand(8,2,50)\ny=torch.rand(8,1)\nsplits = TimeSplitter(show_plot=False)(y)\n\nfail_test = []\nfor arch in all_arch_names:\n    if not \"plus\" in arch.lower(): continue\n    try:\n        fcst = TSForecaster(X, y, splits=splits, arch=arch, metrics=mse, device=default_device())\n        with ContextManagers([fcst.no_bar(), fcst.no_logging()]):\n            fcst.fit_one_cycle(1, 1e-3)\n    except Exception as e:\n        fail_test.append(arch)\n        print(arch, e)\n\ntest_eq(fail_test, [])",
    "crumbs": [
      "Training",
      "TSLearner"
    ]
  },
  {
    "objectID": "analysis.html",
    "href": "analysis.html",
    "title": "Analysis",
    "section": "",
    "text": "fastai Learner extensions useful to perform prediction analysis.\nsource",
    "crumbs": [
      "Analysis"
    ]
  },
  {
    "objectID": "analysis.html#permutation-importance",
    "href": "analysis.html#permutation-importance",
    "title": "Analysis",
    "section": "Permutation importance",
    "text": "Permutation importance\nWe’ve also introduced 2 methods to help you better understand how important certain features or certain steps are for your model. Both methods use permutation importance.\n⚠️The permutation feature or step importance is defined as the decrease in a model score when a single feature or step value is randomly shuffled.\nSo if you using accuracy (higher is better), the most important features or steps will be those with a lower value on the chart (as randomly shuffling them reduces performance).\nThe opposite occurs for metrics like mean squared error (lower is better). In this case, the most important features or steps will be those with a higher value on the chart.\nThere are 2 issues with step importance:\n\nthere may be many steps and the analysis could take very long\nsteps will likely have a high autocorrelation\n\nFor those reasons, we’ve introduced an argument (n_steps) to group steps. In this way you’ll be able to know which part of the time series is the most important.\nFeature importance has been adapted from https://www.kaggle.com/cdeotte/lstm-feature-importance by Chris Deotte (Kaggle GrandMaster).\n\nsource\n\nLearner.feature_importance\n\n Learner.feature_importance (X=None, y=None, bs:int=None,\n                             partial_n:(&lt;class'int'&gt;,&lt;class'float'&gt;)=None,\n                             method:str='permutation',\n                             feature_names:list=None, sel_classes:(&lt;class'\n                             str'&gt;,&lt;class'list'&gt;)=None,\n                             key_metric_idx:int=0, show_chart:bool=True,\n                             figsize:tuple=None, title:str=None,\n                             return_df:bool=True,\n                             save_df_path:pathlib.Path=None,\n                             random_state:int=23, verbose:bool=True)\n\nCalculates feature importance as the drop in the model’s validation loss or metric when a feature value is randomly shuffled\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nX\nNoneType\nNone\narray-like object containing the time series. If None, all data in the validation set will be used.\n\n\ny\nNoneType\nNone\narray-like object containing the targets. If None, all targets in the validation set will be used.\n\n\nbs\nint\nNone\nbatch size. If None, the default batch size of the dataloader will be used.\n\n\npartial_n\n(&lt;class ‘int’&gt;, &lt;class ‘float’&gt;)\nNone\n# (int) or % (float) of used to measure feature importance. If None, all data will be used.\n\n\nmethod\nstr\npermutation\nMethod used to invalidate feature. Use ‘permutation’ for shuffling or ‘ablation’ for setting values to np.nan.\n\n\nfeature_names\nlist\nNone\nOptional list of feature names that will be displayed if available. Otherwise var_0, var_1, etc.\n\n\nsel_classes\n(&lt;class ‘str’&gt;, &lt;class ‘list’&gt;)\nNone\nclasses for which the analysis will be made\n\n\nkey_metric_idx\nint\n0\nOptional position of the metric used. If None or no metric is available, the loss will be used.\n\n\nshow_chart\nbool\nTrue\nFlag to indicate if a chart showing permutation feature importance will be plotted.\n\n\nfigsize\ntuple\nNone\nSize of the chart.\n\n\ntitle\nstr\nNone\nOptional string that will be used as the chart title. If None ‘Permutation Feature Importance’.\n\n\nreturn_df\nbool\nTrue\nFlag to indicate if the dataframe with feature importance will be returned.\n\n\nsave_df_path\nPath\nNone\nPath where dataframe containing the permutation feature importance results will be saved.\n\n\nrandom_state\nint\n23\nOptional int that controls the shuffling applied to the data.\n\n\nverbose\nbool\nTrue\nFlag that controls verbosity.\n\n\n\n\nsource\n\n\nLearner.step_importance\n\n Learner.step_importance (X=None, y=None, bs:int=None,\n                          partial_n:(&lt;class'int'&gt;,&lt;class'float'&gt;)=None,\n                          method:str='permutation', step_names:list=None,\n                          sel_classes:(&lt;class'str'&gt;,&lt;class'list'&gt;)=None,\n                          n_steps:int=1, key_metric_idx:int=0,\n                          show_chart:bool=True, figsize:tuple=(10, 5),\n                          title:str=None, xlabel=None,\n                          return_df:bool=True,\n                          save_df_path:pathlib.Path=None,\n                          random_state:int=23, verbose:bool=True)\n\nCalculates step importance as the drop in the model’s validation loss or metric when a step/s value/s is/are randomly shuffled\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nX\nNoneType\nNone\narray-like object containing the time series. If None, all data in the validation set will be used.\n\n\ny\nNoneType\nNone\narray-like object containing the targets. If None, all targets in the validation set will be used.\n\n\nbs\nint\nNone\nbatch size used to compute predictions. If None, the batch size used in the validation set will be used.\n\n\npartial_n\n(&lt;class ‘int’&gt;, &lt;class ‘float’&gt;)\nNone\n# (int) or % (float) of used to measure feature importance. If None, all data will be used.\n\n\nmethod\nstr\npermutation\nMethod used to invalidate feature. Use ‘permutation’ for shuffling or ‘ablation’ for setting values to np.nan.\n\n\nstep_names\nlist\nNone\nOptional list of step names that will be displayed if available. Otherwise 0, 1, 2, etc.\n\n\nsel_classes\n(&lt;class ‘str’&gt;, &lt;class ‘list’&gt;)\nNone\nclasses for which the analysis will be made\n\n\nn_steps\nint\n1\n# of steps that will be analyzed at a time. Default is 1.\n\n\nkey_metric_idx\nint\n0\nOptional position of the metric used. If None or no metric is available, the loss will be used.\n\n\nshow_chart\nbool\nTrue\nFlag to indicate if a chart showing permutation feature importance will be plotted.\n\n\nfigsize\ntuple\n(10, 5)\nSize of the chart.\n\n\ntitle\nstr\nNone\nOptional string that will be used as the chart title. If None ‘Permutation Feature Importance’.\n\n\nxlabel\nNoneType\nNone\nOptional string that will be used as the chart xlabel. If None ‘steps’.\n\n\nreturn_df\nbool\nTrue\nFlag to indicate if the dataframe with feature importance will be returned.\n\n\nsave_df_path\nPath\nNone\nPath where dataframe containing the permutation feature importance results will be saved.\n\n\nrandom_state\nint\n23\nOptional int that controls the shuffling applied to the data.\n\n\nverbose\nbool\nTrue\nFlag that controls verbosity.\n\n\n\n\nfrom tsai.data.external import get_UCR_data\nfrom tsai.data.preprocessing import TSRobustScale, TSStandardize\nfrom tsai.learner import ts_learner\nfrom tsai.models.FCNPlus import FCNPlus\nfrom tsai.metrics import accuracy\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ntfms  = [None, [TSClassification()]]\nbatch_tfms = TSRobustScale()\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, splits=splits, sel_vars=[0, 3, 5, 8, 10], sel_steps=slice(-30, None), tfms=tfms, batch_tfms=batch_tfms)\nlearn = ts_learner(dls, FCNPlus, metrics=accuracy, train_metrics=True)\nlearn.fit_one_cycle(2)\nlearn.plot_metrics()\nlearn.show_probas()\nlearn.plot_confusion_matrix()\nlearn.plot_top_losses(X[splits[1]], y[splits[1]], largest=True)\nlearn.top_losses(X[splits[1]], y[splits[1]], largest=True)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\ntrain_accuracy\nvalid_loss\nvalid_accuracy\ntime\n\n\n\n\n0\n1.792511\n0.187500\n1.619460\n0.216667\n00:02\n\n\n1\n1.592681\n0.632812\n1.475991\n0.250000\n00:01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(TensorBase([2.3713, 2.3146, 2.2843, 2.2581, 2.2408, 2.2264, 2.2254, 2.2237,\n             2.2230]),\n [9, 56, 128, 25, 104, 116, 57, 72, 108])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlearn.feature_importance()\n\nX.shape: (180, 24, 51)\ny.shape: (180,)\nSelected metric: accuracy\nComputing feature importance (permutation method)...\n\n\n\n\n\n\n\n    \n      \n      100.00% [6/6 00:04&lt;00:00]\n    \n    \n\n\n\n\n\n\n\n\n\n  0 feature: BASELINE             accuracy: 0.277778\n\n\n\n\n\n\n\n\n\n  0 feature: var_0                accuracy: 0.238889\n\n\n\n\n\n\n\n\n\n  3 feature: var_3                accuracy: 0.172222\n\n\n\n\n\n\n\n\n\n  5 feature: var_5                accuracy: 0.261111\n\n\n\n\n\n\n\n\n\n  8 feature: var_8                accuracy: 0.250000\n\n\n\n\n\n\n\n\n\n 10 feature: var_10               accuracy: 0.266667\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeature\naccuracy\naccuracy_change\n\n\n\n\n0\nvar_3\n0.172222\n0.105556\n\n\n1\nvar_0\n0.238889\n0.038889\n\n\n2\nvar_8\n0.250000\n0.027778\n\n\n3\nvar_5\n0.261111\n0.016667\n\n\n4\nvar_10\n0.266667\n0.011111\n\n\n5\nBASELINE\n0.277778\n-0.000000\n\n\n\n\n\n\n\n\nlearn.step_importance(n_steps=5);\n\nX.shape: (180, 24, 51)\ny.shape: (180,)\nSelected metric: accuracy\nComputing step importance...\n\n\n\n\n\n\n\n    \n      \n      100.00% [7/7 00:04&lt;00:00]\n    \n    \n\n\n\n\n\n\n\n\n\n  0 step: BASELINE             accuracy: 0.277778\n\n\n\n\n\n\n\n\n\n  1 step: 21 to 25             accuracy: 0.288889\n\n\n\n\n\n\n\n\n\n  2 step: 26 to 30             accuracy: 0.255556\n\n\n\n\n\n\n\n\n\n  3 step: 31 to 35             accuracy: 0.194444\n\n\n\n\n\n\n\n\n\n  4 step: 36 to 40             accuracy: 0.216667\n\n\n\n\n\n\n\n\n\n  5 step: 41 to 45             accuracy: 0.272222\n\n\n\n\n\n\n\n\n\n  6 step: 46 to 50             accuracy: 0.283333\n\n\n\n\n\n\n\n\n\n\nYou may pass an X and y if you want to analyze a particular group of samples:\nlearn.feature_importance(X=X[splits[1]], y=y[splits[1]])\nIf you have a large validation dataset, you may also use the partial_n argument to select a fixed amount of samples (integer) or a percentage of the validation dataset (float):\nlearn.feature_importance(partial_n=.1)\nlearn.feature_importance(partial_n=100)",
    "crumbs": [
      "Analysis"
    ]
  },
  {
    "objectID": "models.xcmplus.html",
    "href": "models.xcmplus.html",
    "title": "XCMPlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation of XCM created by Ignacio Oguiza (oguiza@timeseriesAI.co).\n\nsource\n\nXCMPlus\n\n XCMPlus (c_in:int, c_out:int, seq_len:Optional[int]=None, nf:int=128,\n          window_perc:float=1.0, flatten:bool=False, custom_head:&lt;built-\n          infunctioncallable&gt;=None, concat_pool:bool=False,\n          fc_dropout:float=0.0, bn:bool=False, y_range:tuple=None,\n          **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom tsai.data.basics import *\nfrom tsai.learner import *\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ntfms = [None, TSCategorize()]\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms)\nmodel =  XCMPlus(dls.vars, dls.c, dls.len)\nlearn = ts_learner(dls, model, metrics=accuracy)\nxb, yb = dls.one_batch()\n\nbs, c_in, seq_len = xb.shape\nc_out = len(np.unique(yb.cpu().numpy()))\n\nmodel = XCMPlus(c_in, c_out, seq_len, fc_dropout=.5)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = XCMPlus(c_in, c_out, seq_len, concat_pool=True)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel = XCMPlus(c_in, c_out, seq_len)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))\nmodel\n\nXCMPlus(\n  (backbone): _XCMPlus_Backbone(\n    (conv2dblock): Sequential(\n      (0): Unsqueeze(dim=1)\n      (1): Conv2dSame(\n        (conv2d_same): Conv2d(1, 128, kernel_size=(1, 51), stride=(1, 1))\n      )\n      (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): ReLU()\n    )\n    (conv2d1x1block): Sequential(\n      (0): Conv2d(128, 1, kernel_size=(1, 1), stride=(1, 1))\n      (1): ReLU()\n      (2): Squeeze(dim=1)\n    )\n    (conv1dblock): Sequential(\n      (0): Conv1d(24, 128, kernel_size=(51,), stride=(1,), padding=(25,))\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (conv1d1x1block): Sequential(\n      (0): Conv1d(128, 1, kernel_size=(1,), stride=(1,))\n      (1): ReLU()\n    )\n    (concat): Concat(dim=1)\n    (conv1d): Sequential(\n      (0): Conv1d(25, 128, kernel_size=(51,), stride=(1,), padding=(25,))\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n  )\n  (head): Sequential(\n    (0): GAP1d(\n      (gap): AdaptiveAvgPool1d(output_size=1)\n      (flatten): Reshape(bs)\n    )\n    (1): LinBnDrop(\n      (0): Linear(in_features=128, out_features=6, bias=True)\n    )\n  )\n)\n\n\n\nmodel.show_gradcam(xb, yb)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel.show_gradcam(xb[0], yb[0])\n\n[W NNPACK.cpp:53] Could not initialize NNPACK! Reason: Unsupported hardware.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 1\nxb = torch.rand(bs, n_vars, seq_len)\nnew_head = partial(conv_lin_nd_head, d=(5, 2))\nnet = XCMPlus(n_vars, c_out, seq_len, custom_head=new_head)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([16, 5, 2])\n\n\ncreate_conv_lin_nd_head(\n  (0): Conv1d(128, 1, kernel_size=(1,), stride=(1,))\n  (1): Linear(in_features=12, out_features=10, bias=True)\n  (2): Transpose(-1, -2)\n  (3): Reshape(bs, 5, 2)\n)\n\n\n\nbs = 16\nn_vars = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, n_vars, seq_len)\nnet = XCMPlus(n_vars, c_out, seq_len)\nchange_model_head(net, create_pool_plus_head, concat_pool=False)\nprint(net.to(xb.device)(xb).shape)\nnet.head\n\ntorch.Size([16, 2])\n\n\nSequential(\n  (0): AdaptiveAvgPool1d(output_size=1)\n  (1): Reshape(bs)\n  (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (3): Linear(in_features=128, out_features=512, bias=False)\n  (4): ReLU(inplace=True)\n  (5): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (6): Linear(in_features=512, out_features=2, bias=False)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "XCMPlus"
    ]
  },
  {
    "objectID": "models.rnnattention.html",
    "href": "models.rnnattention.html",
    "title": "RNNAttention",
    "section": "",
    "text": "This is an custom PyTorch implementation by @yangtzech, based on TST implementation of Ignacio Oguiza.",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNAttention"
    ]
  },
  {
    "objectID": "models.rnnattention.html#arguments",
    "href": "models.rnnattention.html#arguments",
    "title": "RNNAttention",
    "section": "Arguments",
    "text": "Arguments\nUsual values are the ones that appear in the “Attention is all you need” and “A Transformer-based Framework for Multivariate Time Series Representation Learning” papers. And some parameters are necessary for the RNN part.\nThe default values are the ones selected as a default configuration in the latter.\n\nc_in: the number of features (aka variables, dimensions, channels) in the time series dataset. dls.var\nc_out: the number of target classes. dls.c\nseq_len: number of time steps in the time series. dls.len\nhidden_size: the number of features in the hidden state in the RNN model. Default: 128.\nrnn_layers: the number of recurrent layers of the RNN model. Default: 1.\nbias: If False, then the layer does not use bias weights b_ih and b_hh. Default: True\nrnn_dropout: If non-zero, introduces a Dropout layer on the outputs of each RNN layer except the last layer, with dropout probability equal to :attr:rnn_dropout. Default: 0\nbidirectional: If True, becomes a bidirectional RNN. Default: False\nn_heads: parallel attention heads. Usual values: 8-16. Default: 16.\nd_k: size of the learned linear projection of queries and keys in the MHA. Usual values: 16-512. Default: None -&gt; (d_model/n_heads) = 32.\nd_v: size of the learned linear projection of values in the MHA. Usual values: 16-512. Default: None -&gt; (d_model/n_heads) = 32.\nd_ff: the dimension of the feedforward network model. Usual values: 256-4096. Default: 256.\nencoder_dropout: amount of residual dropout applied in the encoder. Usual values: 0.-0.3. Default: 0.1.\nact: the activation function of intermediate layer, relu or gelu. Default: ‘gelu’.\nencoder_layers: the number of sub-encoder-layers in the encoder. Usual values: 2-8. Default: 3.\nfc_dropout: dropout applied to the final fully connected layer. Usual values: 0.-0.8. Default: 0.\ny_range: range of possible y values (used in regression tasks). Default: None\nkwargs: nn.Conv1d kwargs. If not {}, a nn.Conv1d with those kwargs will be applied to original time series.",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNAttention"
    ]
  },
  {
    "objectID": "models.rnnattention.html#imports",
    "href": "models.rnnattention.html#imports",
    "title": "RNNAttention",
    "section": "Imports",
    "text": "Imports",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNAttention"
    ]
  },
  {
    "objectID": "models.rnnattention.html#rnnattention",
    "href": "models.rnnattention.html#rnnattention",
    "title": "RNNAttention",
    "section": "RNNAttention",
    "text": "RNNAttention\n\nt = torch.rand(16, 50, 128)\noutput, attn = _MultiHeadAttention(d_model=128, n_heads=3, d_k=8, d_v=6)(t, t, t)\noutput.shape, attn.shape\n\n(torch.Size([16, 50, 128]), torch.Size([16, 3, 50, 50]))\n\n\n\nt = torch.rand(16, 50, 128)\noutput = _TSTEncoderLayer(q_len=50, d_model=128, n_heads=3, d_k=None, d_v=None, d_ff=512, dropout=0.1, activation='gelu')(t)\noutput.shape\n\ntorch.Size([16, 50, 128])\n\n\n\nsource\n\nGRUAttention\n\n GRUAttention (c_in:int, c_out:int, seq_len:int, hidden_size=128,\n               rnn_layers=1, bias=True, rnn_dropout=0,\n               bidirectional=False, encoder_layers:int=3, n_heads:int=16,\n               d_k:Optional[int]=None, d_v:Optional[int]=None,\n               d_ff:int=256, encoder_dropout:float=0.1, act:str='gelu',\n               fc_dropout:float=0.0, y_range:Optional[tuple]=None,\n               verbose:bool=False, custom_head=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nLSTMAttention\n\n LSTMAttention (c_in:int, c_out:int, seq_len:int, hidden_size=128,\n                rnn_layers=1, bias=True, rnn_dropout=0,\n                bidirectional=False, encoder_layers:int=3, n_heads:int=16,\n                d_k:Optional[int]=None, d_v:Optional[int]=None,\n                d_ff:int=256, encoder_dropout:float=0.1, act:str='gelu',\n                fc_dropout:float=0.0, y_range:Optional[tuple]=None,\n                verbose:bool=False, custom_head=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nRNNAttention\n\n RNNAttention (c_in:int, c_out:int, seq_len:int, hidden_size=128,\n               rnn_layers=1, bias=True, rnn_dropout=0,\n               bidirectional=False, encoder_layers:int=3, n_heads:int=16,\n               d_k:Optional[int]=None, d_v:Optional[int]=None,\n               d_ff:int=256, encoder_dropout:float=0.1, act:str='gelu',\n               fc_dropout:float=0.0, y_range:Optional[tuple]=None,\n               verbose:bool=False, custom_head=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 500\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nhidden_size = 128\nrnn_layers=1\nbias=True\nrnn_dropout=0\nbidirectional=False\nencoder_layers=3\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\nencoder_dropout = 0.1\nact = \"gelu\"\nfc_dropout = 0.1\nkwargs = {}\n\nmodel = RNNAttention(c_in, c_out, seq_len, hidden_size=hidden_size, rnn_layers=rnn_layers, bias=bias, rnn_dropout=rnn_dropout, bidirectional=bidirectional,\n            encoder_layers=encoder_layers, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, encoder_dropout=encoder_dropout, act=act, \n            fc_dropout=fc_dropout, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 541698\n\n\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 60\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nhidden_size = 128\nrnn_layers=1\nbias=True\nrnn_dropout=0\nbidirectional=False\nencoder_layers=3\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\nencoder_dropout = 0.1\nact = \"gelu\"\nfc_dropout = 0.1\nkwargs = {}\n# kwargs = dict(kernel_size=5, padding=2)\n\nmodel = RNNAttention(c_in, c_out, seq_len, hidden_size=hidden_size, rnn_layers=rnn_layers, bias=bias, rnn_dropout=rnn_dropout, bidirectional=bidirectional,\n            encoder_layers=encoder_layers, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, encoder_dropout=encoder_dropout, act=act, \n            fc_dropout=fc_dropout, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 429058",
    "crumbs": [
      "Models",
      "RNNs",
      "RNNAttention"
    ]
  },
  {
    "objectID": "learner.html",
    "href": "learner.html",
    "title": "Learner",
    "section": "",
    "text": "fastai Learner extensions.\n\n\nsource\n\nLearner.show_batch\n\n Learner.show_batch (**kwargs)\n\n\nsource\n\n\nLearner.remove_all_cbs\n\n Learner.remove_all_cbs (max_iters=10)\n\n\nsource\n\n\nLearner.one_batch\n\n Learner.one_batch (i, b)\n\n\nsource\n\n\nLearner.inverse_transform\n\n Learner.inverse_transform (df:pandas.core.frame.DataFrame)\n\nApplies sklearn-type pipeline inverse transforms\n\nsource\n\n\nLearner.transform\n\n Learner.transform (df:pandas.core.frame.DataFrame)\n\nApplies sklearn-type pipeline transforms\n⚠️ Important: save_all and load_all methods are designed for small datasets only. If you are using a larger dataset, you should use the standard save and load_learner methods.\n\nsource\n\n\nload_all\n\n load_all (path='export', dls_fname='dls', model_fname='model',\n           learner_fname='learner', device=None, pickle_module=&lt;module\n           'pickle' from '/opt/hostedtoolcache/Python/3.10.18/x64/lib/pyth\n           on3.10/pickle.py'&gt;, verbose=False)\n\n\nsource\n\n\nLearner.save_all\n\n Learner.save_all (path='export', dls_fname='dls', model_fname='model',\n                   learner_fname='learner', verbose=False)\n\n\nfrom tsai.data.core import get_ts_dls\nfrom tsai.utils import remove_dir\n\n\nX = np.random.rand(100, 2, 10)\ndls = get_ts_dls(X)\nlearn = Learner(dls, InceptionTimePlus(2, 1), loss_func=MSELossFlat())\nlearn.save_all(Path.home()/'tmp', verbose=True)\nlearn2 = load_all(Path.home()/'tmp', verbose=True)\nremove_dir(Path.home()/'tmp')\n\nLearner saved:\npath          = '/Users/nacho/tmp'\ndls_fname     = '['dls_0.pth', 'dls_1.pth']'\nmodel_fname   = 'model.pth'\nlearner_fname = 'learner.pkl'\nLearner loaded:\npath          = '/Users/nacho/tmp'\ndls_fname     = '['dls_0.pth', 'dls_1.pth']'\nmodel_fname   = 'model.pth'\nlearner_fname = 'learner.pkl'\n/Users/nacho/tmp directory removed.\n\n\n\nsource\n\n\nLearner.plot_metrics\n\n Learner.plot_metrics (nrows:int=1, ncols:int=1, figsize:tuple=None,\n                       imsize:int=3, suptitle:str=None, sharex:\"bool|Liter\n                       al['none','all','row','col']\"=False, sharey:\"bool|L\n                       iteral['none','all','row','col']\"=False,\n                       squeeze:bool=True,\n                       width_ratios:Sequence[float]|None=None,\n                       height_ratios:Sequence[float]|None=None,\n                       subplot_kw:dict[str,Any]|None=None,\n                       gridspec_kw:dict[str,Any]|None=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnrows\nint\n1\nNumber of rows in returned axes grid\n\n\nncols\nint\n1\nNumber of columns in returned axes grid\n\n\nfigsize\ntuple\nNone\nWidth, height in inches of the returned figure\n\n\nimsize\nint\n3\nSize (in inches) of images that will be displayed in the returned figure\n\n\nsuptitle\nstr\nNone\nTitle to be set to returned figure\n\n\nsharex\nbool | Literal[‘none’, ‘all’, ‘row’, ‘col’]\nFalse\n\n\n\nsharey\nbool | Literal[‘none’, ‘all’, ‘row’, ‘col’]\nFalse\n\n\n\nsqueeze\nbool\nTrue\n\n\n\nwidth_ratios\nSequence[float] | None\nNone\n\n\n\nheight_ratios\nSequence[float] | None\nNone\n\n\n\nsubplot_kw\ndict[str, Any] | None\nNone\n\n\n\ngridspec_kw\ndict[str, Any] | None\nNone\n\n\n\nReturns\n(plt.Figure, plt.Axes)\n\nReturns both fig and ax as a tuple\n\n\n\n\nsource\n\n\nRecorder.plot_metrics\n\n Recorder.plot_metrics (nrows=None, ncols=None, figsize=None,\n                        final_losses=True, perc=0.5, imsize:int=3,\n                        suptitle:str=None, sharex:\"bool|Literal['none','al\n                        l','row','col']\"=False, sharey:\"bool|Literal['none\n                        ','all','row','col']\"=False, squeeze:bool=True,\n                        width_ratios:Sequence[float]|None=None,\n                        height_ratios:Sequence[float]|None=None,\n                        subplot_kw:dict[str,Any]|None=None,\n                        gridspec_kw:dict[str,Any]|None=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnrows\nint\n1\nNumber of rows in returned axes grid\n\n\nncols\nint\n1\nNumber of columns in returned axes grid\n\n\nfigsize\ntuple\nNone\nWidth, height in inches of the returned figure\n\n\nfinal_losses\nbool\nTrue\n\n\n\nperc\nfloat\n0.5\n\n\n\nimsize\nint\n3\nSize (in inches) of images that will be displayed in the returned figure\n\n\nsuptitle\nstr\nNone\nTitle to be set to returned figure\n\n\nsharex\nbool | Literal[‘none’, ‘all’, ‘row’, ‘col’]\nFalse\n\n\n\nsharey\nbool | Literal[‘none’, ‘all’, ‘row’, ‘col’]\nFalse\n\n\n\nsqueeze\nbool\nTrue\n\n\n\nwidth_ratios\nSequence[float] | None\nNone\n\n\n\nheight_ratios\nSequence[float] | None\nNone\n\n\n\nsubplot_kw\ndict[str, Any] | None\nNone\n\n\n\ngridspec_kw\ndict[str, Any] | None\nNone\n\n\n\nReturns\n(plt.Figure, plt.Axes)\n\nReturns both fig and ax as a tuple\n\n\n\n\nsource\n\n\nget_arch\n\n get_arch (arch_name)\n\n\nfor arch_name in all_arch_names:\n    get_arch(arch_name)\n\n\nsource\n\n\nts_learner\n\n ts_learner (dls, arch=None, c_in=None, c_out=None, seq_len=None, d=None,\n             s_cat_idxs=None, s_cat_embeddings=None,\n             s_cat_embedding_dims=None, s_cont_idxs=None, o_cat_idxs=None,\n             o_cat_embeddings=None, o_cat_embedding_dims=None,\n             o_cont_idxs=None, splitter=&lt;function trainable_params&gt;,\n             loss_func=None, opt_func=&lt;function Adam&gt;, lr=0.001, cbs=None,\n             metrics=None, path=None, model_dir='models', wd=None,\n             wd_bn_bias=False, train_bn=True, moms=(0.95, 0.85, 0.95),\n             train_metrics=False, valid_metrics=True, seed=None,\n             device=None, verbose=False, patch_len=None,\n             patch_stride=None, fusion_layers=128, fusion_act='relu',\n             fusion_dropout=0.0, fusion_use_bn=True, pretrained=False,\n             weights_path=None, exclude_head=True, cut=-1, init=None,\n             arch_config={})\n\n\nsource\n\n\ntsimage_learner\n\n tsimage_learner (dls, arch=None, pretrained=False, loss_func=None,\n                  opt_func=&lt;function Adam&gt;, lr=0.001, cbs=None,\n                  metrics=None, path=None, model_dir='models', wd=None,\n                  wd_bn_bias=False, train_bn=True, moms=(0.95, 0.85,\n                  0.95), c_in=None, c_out=None, device=None,\n                  verbose=False, init=None, arch_config={})\n\n\nsource\n\n\nLearner.decoder\n\n Learner.decoder (o)\n\n\nfrom tsai.data.core import *\nfrom tsai.data.external import get_UCR_data\nfrom tsai.models.FCNPlus import FCNPlus\n\n\nX, y, splits = get_UCR_data('OliveOil', verbose=True, split_data=False)\ntfms  = [None, [TSCategorize()]]\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms)\nlearn = ts_learner(dls, FCNPlus)\nfor p in learn.model.parameters():\n    p.requires_grad=False\ntest_eq(count_parameters(learn.model), 0)\nlearn.freeze()\ntest_eq(count_parameters(learn.model), 1540)\nlearn.unfreeze()\ntest_eq(count_parameters(learn.model), 264580)\n\nlearn = ts_learner(dls, 'FCNPlus')\nfor p in learn.model.parameters():\n    p.requires_grad=False\ntest_eq(count_parameters(learn.model), 0)\nlearn.freeze()\ntest_eq(count_parameters(learn.model), 1540)\nlearn.unfreeze()\ntest_eq(count_parameters(learn.model), 264580)\n\nDataset: OliveOil\nX      : (60, 1, 570)\ny      : (60,)\nsplits : (#30) [0,1,2,3,4,5,6,7,8,9...] (#30) [30,31,32,33,34,35,36,37,38,39...] \n\n\n\n\nlearn.show_batch();\n\n\n\n\n\n\n\n\n\nfrom fastai.metrics import accuracy\nfrom tsai.data.preprocessing import TSRobustScale\n\n\nX, y, splits = get_UCR_data('OliveOil', split_data=False)\ntfms  = [None, TSClassification()]\nbatch_tfms = TSRobustScale()\ndls = get_ts_dls(X, y, tfms=tfms, splits=splits, batch_tfms=batch_tfms)\nlearn = ts_learner(dls, FCNPlus, metrics=accuracy, train_metrics=True)\nlearn.fit_one_cycle(2)\nlearn.plot_metrics()\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\ntrain_accuracy\nvalid_loss\nvalid_accuracy\ntime\n\n\n\n\n0\n1.480875\n0.266667\n1.390461\n0.300000\n00:02\n\n\n1\n1.476655\n0.266667\n1.387370\n0.300000\n00:01\n\n\n\n\n\n\n\n\n\n\n\n\n\nif not os.path.exists(\"./models\"): os.mkdir(\"./models\")\nif not os.path.exists(\"./data\"): os.mkdir(\"./data\")\nnp.save(\"data/X_test.npy\", X[splits[1]])\nnp.save(\"data/y_test.npy\", y[splits[1]])\nlearn.export(\"./models/test.pth\")",
    "crumbs": [
      "Training",
      "Learner"
    ]
  },
  {
    "objectID": "models.positional_encoders.html",
    "href": "models.positional_encoders.html",
    "title": "Positional encoders",
    "section": "",
    "text": "This includes some variations of positional encoders used with Transformers.",
    "crumbs": [
      "Models",
      "Transformers",
      "Positional encoders"
    ]
  },
  {
    "objectID": "models.positional_encoders.html#imports",
    "href": "models.positional_encoders.html#imports",
    "title": "Positional encoders",
    "section": "Imports",
    "text": "Imports",
    "crumbs": [
      "Models",
      "Transformers",
      "Positional encoders"
    ]
  },
  {
    "objectID": "models.positional_encoders.html#positional-encoders",
    "href": "models.positional_encoders.html#positional-encoders",
    "title": "Positional encoders",
    "section": "Positional encoders",
    "text": "Positional encoders\n\nsource\n\nPositionalEncoding\n\n PositionalEncoding (q_len, d_model, normalize=True)\n\n\npe = PositionalEncoding(1000, 512).detach().cpu().numpy()\nplt.pcolormesh(pe, cmap='viridis')\nplt.title('PositionalEncoding')\nplt.colorbar()\nplt.show()\npe.mean(), pe.std(), pe.min(), pe.max(), pe.shape\n\n\n\n\n\n\n\n\n\nsource\n\n\nCoord2dPosEncoding\n\n Coord2dPosEncoding (q_len, d_model, exponential=False, normalize=True,\n                     eps=0.001, verbose=False)\n\n\ncpe = Coord2dPosEncoding(1000, 512, exponential=True, normalize=True).cpu().numpy()\nplt.pcolormesh(cpe, cmap='viridis')\nplt.title('Coord2dPosEncoding')\nplt.colorbar()\nplt.show()\nplt.plot(cpe.mean(0))\nplt.show()\nplt.plot(cpe.mean(1))\nplt.show()\ncpe.mean(), cpe.std(), cpe.min(), cpe.max()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nCoord1dPosEncoding\n\n Coord1dPosEncoding (q_len, exponential=False, normalize=True)\n\n\ncpe = Coord1dPosEncoding(1000, exponential=True, normalize=True).detach().cpu().numpy()\nplt.pcolormesh(cpe, cmap='viridis')\nplt.title('Coord1dPosEncoding')\nplt.colorbar()\nplt.show()\nplt.plot(cpe.mean(1))\nplt.show()\ncpe.mean(), cpe.std(), cpe.min(), cpe.max(), cpe.shape\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncpe = Coord1dPosEncoding(1000, exponential=True, normalize=True).detach().cpu().numpy()\nplt.pcolormesh(cpe, cmap='viridis')\nplt.title('Coord1dPosEncoding')\nplt.colorbar()\nplt.show()\nplt.plot(cpe.mean(1))\nplt.show()\ncpe.mean(), cpe.std(), cpe.min(), cpe.max()",
    "crumbs": [
      "Models",
      "Transformers",
      "Positional encoders"
    ]
  },
  {
    "objectID": "models.rescnn.html",
    "href": "models.rescnn.html",
    "title": "ResCNN",
    "section": "",
    "text": "This is an unofficial PyTorch implementation by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nfrom tsai.models.utils import *\n\n\nsource\n\nResCNN\n\n ResCNN (c_in, c_out, coord=False, separable=False, zero_norm=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nxb = torch.rand(16, 3, 10)\ntest_eq(ResCNN(3,2,coord=True, separable=True)(xb).shape, [xb.shape[0], 2])\ntest_eq(count_parameters(ResCNN(3,2)), 257283)\n\n\nResCNN(3,2,coord=True, separable=True)\n\nResCNN(\n  (block1): _ResCNNBlock(\n    (convblock1): ConvBlock(\n      (0): AddCoords1d()\n      (1): SeparableConv1d(\n        (depthwise_conv): Conv1d(4, 4, kernel_size=(7,), stride=(1,), padding=(3,), groups=4, bias=False)\n        (pointwise_conv): Conv1d(4, 64, kernel_size=(1,), stride=(1,), bias=False)\n      )\n      (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): ReLU()\n    )\n    (convblock2): ConvBlock(\n      (0): AddCoords1d()\n      (1): SeparableConv1d(\n        (depthwise_conv): Conv1d(65, 65, kernel_size=(5,), stride=(1,), padding=(2,), groups=65, bias=False)\n        (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n      )\n      (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): ReLU()\n    )\n    (convblock3): ConvBlock(\n      (0): AddCoords1d()\n      (1): SeparableConv1d(\n        (depthwise_conv): Conv1d(65, 65, kernel_size=(3,), stride=(1,), padding=(1,), groups=65, bias=False)\n        (pointwise_conv): Conv1d(65, 64, kernel_size=(1,), stride=(1,), bias=False)\n      )\n      (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (shortcut): ConvBlock(\n      (0): AddCoords1d()\n      (1): Conv1d(4, 64, kernel_size=(1,), stride=(1,), bias=False)\n      (2): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (add): Add\n    (act): ReLU()\n  )\n  (block2): ConvBlock(\n    (0): AddCoords1d()\n    (1): SeparableConv1d(\n      (depthwise_conv): Conv1d(65, 65, kernel_size=(3,), stride=(1,), padding=(1,), groups=65, bias=False)\n      (pointwise_conv): Conv1d(65, 128, kernel_size=(1,), stride=(1,), bias=False)\n    )\n    (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (3): LeakyReLU(negative_slope=0.2)\n  )\n  (block3): ConvBlock(\n    (0): AddCoords1d()\n    (1): SeparableConv1d(\n      (depthwise_conv): Conv1d(129, 129, kernel_size=(3,), stride=(1,), padding=(1,), groups=129, bias=False)\n      (pointwise_conv): Conv1d(129, 256, kernel_size=(1,), stride=(1,), bias=False)\n    )\n    (2): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (3): PReLU(num_parameters=1)\n  )\n  (block4): ConvBlock(\n    (0): AddCoords1d()\n    (1): SeparableConv1d(\n      (depthwise_conv): Conv1d(257, 257, kernel_size=(3,), stride=(1,), padding=(1,), groups=257, bias=False)\n      (pointwise_conv): Conv1d(257, 128, kernel_size=(1,), stride=(1,), bias=False)\n    )\n    (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    (3): ELU(alpha=0.3)\n  )\n  (gap): AdaptiveAvgPool1d(output_size=1)\n  (squeeze): Squeeze(dim=-1)\n  (lin): Linear(in_features=128, out_features=2, bias=True)\n)\n\n\n\ncheck_weight(ResCNN(3,2, zero_norm=True), is_bn)\n\n(array([1., 1., 0., 1., 1., 1., 1.], dtype=float32),\n array([0., 0., 0., 0., 0., 0., 0.], dtype=float32))",
    "crumbs": [
      "Models",
      "CNNs",
      "ResCNN"
    ]
  },
  {
    "objectID": "models.tsitplus.html",
    "href": "models.tsitplus.html",
    "title": "TSiT",
    "section": "",
    "text": "This is a PyTorch implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on ViT (Vision Transformer):\nDosovitskiy, A., Beyer, L., Kolesnikov, A., Weissenborn, D., Zhai, X., Unterthiner, T., … & Houlsby, N. (2020).\nAn image is worth 16x16 words: Transformers for image recognition at scale. arXiv preprint arXiv:2010.11929.\nxb = torch.rand(16, 51, 128, requires_grad=True).to(default_device())\noutput = _TSiTEncoderLayer(128, 16).to(default_device())(xb)\n# Then try a simple backward pass\ntarget = torch.rand_like(output)\nloss = ((output - target)**2).mean()\nloss.backward()\nxb = torch.rand(16, 51, 128, requires_grad=True).to(default_device())\noutput = _TSiTEncoder(128, 16).to(default_device())(xb)\n# Then try a simple backward pass\ntarget = torch.rand_like(output)\nloss = ((output - target)**2).mean()\nloss.backward()\nsource",
    "crumbs": [
      "Models",
      "Transformers",
      "TSiT"
    ]
  },
  {
    "objectID": "models.tsitplus.html#feature-extractor",
    "href": "models.tsitplus.html#feature-extractor",
    "title": "TSiT",
    "section": "Feature extractor",
    "text": "Feature extractor\nIt’s a known fact that transformers cannot be directly applied to long sequences. To avoid this, we have included a way to subsample the sequence to generate a more manageable input.\n\nfrom tsai.data.validation import get_splits\nfrom tsai.data.core import get_ts_dls\n\n\nX = np.zeros((10, 3, 5000))\ny = np.random.randint(0,2,X.shape[0])\nsplits = get_splits(y)\ndls = get_ts_dls(X, y, splits=splits)\nxb, yb = dls.train.one_batch()\nxb\n\n\n\n\n\n\n\n\nTSTensor(samples:8, vars:3, len:5000, device=mps:0, dtype=torch.float32)\n\n\nIf you try to use TSiTPlus, it’s likely you’ll get an ‘out-of-memory’ error.\nTo avoid this you can subsample the sequence reducing the input’s length. This can be done in multiple ways. Here are a few examples:\n\n# Separable convolution (to avoid mixing channels)\nfeature_extractor = Conv1d(xb.shape[1], xb.shape[1], ks=100, stride=50, padding=0, groups=xb.shape[1]).to(default_device())\nfeature_extractor.to(xb.device)(xb).shape\n\ntorch.Size([8, 3, 99])\n\n\n\n# Convolution (if you want to mix channels or change number of channels)\nfeature_extractor=MultiConv1d(xb.shape[1], 64, kss=[1,3,5,7,9], keep_original=True).to(default_device())\ntest_eq(feature_extractor.to(xb.device)(xb).shape, (xb.shape[0], 64, xb.shape[-1]))\n\n\n# MaxPool\nfeature_extractor = nn.Sequential(Pad1d((0, 50), 0), nn.MaxPool1d(kernel_size=100, stride=50)).to(default_device())\nfeature_extractor.to(xb.device)(xb).shape\n\ntorch.Size([8, 3, 100])\n\n\n\n# AvgPool\nfeature_extractor = nn.Sequential(Pad1d((0, 50), 0), nn.AvgPool1d(kernel_size=100, stride=50)).to(default_device())\nfeature_extractor.to(xb.device)(xb).shape\n\ntorch.Size([8, 3, 100])\n\n\nOnce you decide what type of transform you want to apply, you just need to pass the layer as the feature_extractor attribute:\n\nbs = 16\nnvars = 4\nseq_len = 1000\nc_out = 2\nd_model = 128\n\nxb = torch.rand(bs, nvars, seq_len)\nfeature_extractor = partial(Conv1d, ks=5, stride=3, padding=0, groups=xb.shape[1])\nmodel = TSiTPlus(nvars, c_out, seq_len, d_model=d_model, feature_extractor=feature_extractor)\ntest_eq(model.to(xb.device)(xb).shape, (bs, c_out))",
    "crumbs": [
      "Models",
      "Transformers",
      "TSiT"
    ]
  },
  {
    "objectID": "models.tsitplus.html#categorical-variables",
    "href": "models.tsitplus.html#categorical-variables",
    "title": "TSiT",
    "section": "Categorical variables",
    "text": "Categorical variables\n\nfrom tsai.utils import alphabet, ALPHABET\n\n\na = alphabet[np.random.randint(0,3,40)]\nb = ALPHABET[np.random.randint(6,10,40)]\nc = np.random.rand(40).reshape(4,1,10)\nmap_a = {k:v for v,k in enumerate(np.unique(a))}\nmap_b = {k:v for v,k in enumerate(np.unique(b))}\nn_cat_embeds = [len(m.keys()) for m in [map_a, map_b]]\nszs = [emb_sz_rule(n) for n in n_cat_embeds]\na = np.asarray(a.map(map_a)).reshape(4,1,10)\nb = np.asarray(b.map(map_b)).reshape(4,1,10)\ninp = torch.from_numpy(np.concatenate((c,a,b), 1)).float()\nfeature_extractor = partial(Conv1d, ks=3, padding='same')\nmodel = TSiTPlus(3, 2, 10, d_model=64, cat_pos=[1,2], feature_extractor=feature_extractor)\ntest_eq(model(inp).shape, (4,2))",
    "crumbs": [
      "Models",
      "Transformers",
      "TSiT"
    ]
  },
  {
    "objectID": "models.tsitplus.html#sequence-embedding",
    "href": "models.tsitplus.html#sequence-embedding",
    "title": "TSiT",
    "section": "Sequence Embedding",
    "text": "Sequence Embedding\nSometimes you have a samples with a very long sequence length. In those cases you may want to reduce it’s length before passing it to the transformer. To do that you may just pass a token_size like in this example:\n\nt = torch.rand(8, 2, 10080)\nSeqTokenizer(2, 128, 60)(t).shape\n\ntorch.Size([8, 128, 168])\n\n\n\nt = torch.rand(8, 2, 10080)\nmodel = TSiTPlus(2, 5, 10080, d_model=64, token_size=60)\nmodel(t).shape\n\ntorch.Size([8, 5])",
    "crumbs": [
      "Models",
      "Transformers",
      "TSiT"
    ]
  },
  {
    "objectID": "data.unwindowed.html",
    "href": "data.unwindowed.html",
    "title": "Unwindowed datasets",
    "section": "",
    "text": "Functionality that will allow you to create a dataset that applies sliding windows to the input data on the fly. This heavily reduces the size of the input data files, as only the original unwindowed data needs to be stored.\n\nI’d like to thank both Thomas Capelle (https://github.com/tcapelle) and Xander Dunn (https://github.com/xanderdunn) for their contributions to make this code possible.\n\nsource\n\nTSUnwindowedDatasets\n\n TSUnwindowedDatasets (dataset, splits)\n\nBase class for lists with subsets\n\nsource\n\n\nTSUnwindowedDataset\n\n TSUnwindowedDataset (X=None, y=None, y_func=None, window_size=1,\n                      stride=1, drop_start=0, drop_end=0, seq_first=True,\n                      **kwargs)\n\nInitialize self. See help(type(self)) for accurate signature.\n\ndef y_func(y): return y.astype('float').mean(1)\n\nThis approach works with both univariate and multivariate data.\n\nUnivariate: we’ll use a simple array with 20 values, one with the seq_len first (X0), the other with seq_len second (X1).\nMultivariate: we’ll use 2 time series arrays, one with the seq_len first (X2), the other with seq_len second (X3). No sliding window has been applied to them yet.\n\n\n# Univariate\nX0 = np.arange(20).astype(float)\nX1 = np.arange(20).reshape(1, -1).astype(float)\nX0.shape, X0, X1.shape, X1\n\n((20,),\n array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,\n        13., 14., 15., 16., 17., 18., 19.]),\n (1, 20),\n array([[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,\n         13., 14., 15., 16., 17., 18., 19.]]))\n\n\n\n# Multivariate\nX2 = np.arange(20).reshape(-1,1)*np.array([1, 10, 100]).reshape(1,-1).astype(float)\nX3 = np.arange(20).reshape(1,-1)*np.array([1, 10, 100]).reshape(-1,1).astype(float)\nX2.shape, X3.shape, X2, X3\n\n((20, 3),\n (3, 20),\n array([[0.0e+00, 0.0e+00, 0.0e+00],\n        [1.0e+00, 1.0e+01, 1.0e+02],\n        [2.0e+00, 2.0e+01, 2.0e+02],\n        [3.0e+00, 3.0e+01, 3.0e+02],\n        [4.0e+00, 4.0e+01, 4.0e+02],\n        [5.0e+00, 5.0e+01, 5.0e+02],\n        [6.0e+00, 6.0e+01, 6.0e+02],\n        [7.0e+00, 7.0e+01, 7.0e+02],\n        [8.0e+00, 8.0e+01, 8.0e+02],\n        [9.0e+00, 9.0e+01, 9.0e+02],\n        [1.0e+01, 1.0e+02, 1.0e+03],\n        [1.1e+01, 1.1e+02, 1.1e+03],\n        [1.2e+01, 1.2e+02, 1.2e+03],\n        [1.3e+01, 1.3e+02, 1.3e+03],\n        [1.4e+01, 1.4e+02, 1.4e+03],\n        [1.5e+01, 1.5e+02, 1.5e+03],\n        [1.6e+01, 1.6e+02, 1.6e+03],\n        [1.7e+01, 1.7e+02, 1.7e+03],\n        [1.8e+01, 1.8e+02, 1.8e+03],\n        [1.9e+01, 1.9e+02, 1.9e+03]]),\n array([[0.0e+00, 1.0e+00, 2.0e+00, 3.0e+00, 4.0e+00, 5.0e+00, 6.0e+00,\n         7.0e+00, 8.0e+00, 9.0e+00, 1.0e+01, 1.1e+01, 1.2e+01, 1.3e+01,\n         1.4e+01, 1.5e+01, 1.6e+01, 1.7e+01, 1.8e+01, 1.9e+01],\n        [0.0e+00, 1.0e+01, 2.0e+01, 3.0e+01, 4.0e+01, 5.0e+01, 6.0e+01,\n         7.0e+01, 8.0e+01, 9.0e+01, 1.0e+02, 1.1e+02, 1.2e+02, 1.3e+02,\n         1.4e+02, 1.5e+02, 1.6e+02, 1.7e+02, 1.8e+02, 1.9e+02],\n        [0.0e+00, 1.0e+02, 2.0e+02, 3.0e+02, 4.0e+02, 5.0e+02, 6.0e+02,\n         7.0e+02, 8.0e+02, 9.0e+02, 1.0e+03, 1.1e+03, 1.2e+03, 1.3e+03,\n         1.4e+03, 1.5e+03, 1.6e+03, 1.7e+03, 1.8e+03, 1.9e+03]]))\n\n\nNow, instead of applying SlidingWindow to create and save the time series that can be consumed by a time series model, we can use a dataset that creates the data on the fly. In this way we avoid the need to create and save large files. This approach is also useful when you want to test different sliding window sizes, as otherwise you would need to create files for every size you want to test.The dataset will create the samples correctly formatted and ready to be passed on to a time series architecture.\n\nwds0 = TSUnwindowedDataset(X0, window_size=5, stride=2, seq_first=True)[:][0]\nwds1 = TSUnwindowedDataset(X1, window_size=5, stride=2, seq_first=False)[:][0]\ntest_eq(wds0, wds1)\nwds0, wds0.data, wds1, wds1.data\n\n(TSTensor(samples:8, vars:1, len:5, device=cpu),\n tensor([[[ 0.,  1.,  2.,  3.,  4.]],\n \n         [[ 2.,  3.,  4.,  5.,  6.]],\n \n         [[ 4.,  5.,  6.,  7.,  8.]],\n \n         [[ 6.,  7.,  8.,  9., 10.]],\n \n         [[ 8.,  9., 10., 11., 12.]],\n \n         [[10., 11., 12., 13., 14.]],\n \n         [[12., 13., 14., 15., 16.]],\n \n         [[14., 15., 16., 17., 18.]]]),\n TSTensor(samples:8, vars:1, len:5, device=cpu),\n tensor([[[ 0.,  1.,  2.,  3.,  4.]],\n \n         [[ 2.,  3.,  4.,  5.,  6.]],\n \n         [[ 4.,  5.,  6.,  7.,  8.]],\n \n         [[ 6.,  7.,  8.,  9., 10.]],\n \n         [[ 8.,  9., 10., 11., 12.]],\n \n         [[10., 11., 12., 13., 14.]],\n \n         [[12., 13., 14., 15., 16.]],\n \n         [[14., 15., 16., 17., 18.]]]))\n\n\n\nwds2 = TSUnwindowedDataset(X2, window_size=5, stride=2, seq_first=True)[:][0]\nwds3 = TSUnwindowedDataset(X3, window_size=5, stride=2, seq_first=False)[:][0]\ntest_eq(wds2, wds3)\nwds2, wds3, wds2.data, wds3.data\n\n(TSTensor(samples:8, vars:3, len:5, device=cpu),\n TSTensor(samples:8, vars:3, len:5, device=cpu),\n tensor([[[0.0000e+00, 1.0000e+00, 2.0000e+00, 3.0000e+00, 4.0000e+00],\n          [0.0000e+00, 1.0000e+01, 2.0000e+01, 3.0000e+01, 4.0000e+01],\n          [0.0000e+00, 1.0000e+02, 2.0000e+02, 3.0000e+02, 4.0000e+02]],\n \n         [[2.0000e+00, 3.0000e+00, 4.0000e+00, 5.0000e+00, 6.0000e+00],\n          [2.0000e+01, 3.0000e+01, 4.0000e+01, 5.0000e+01, 6.0000e+01],\n          [2.0000e+02, 3.0000e+02, 4.0000e+02, 5.0000e+02, 6.0000e+02]],\n \n         [[4.0000e+00, 5.0000e+00, 6.0000e+00, 7.0000e+00, 8.0000e+00],\n          [4.0000e+01, 5.0000e+01, 6.0000e+01, 7.0000e+01, 8.0000e+01],\n          [4.0000e+02, 5.0000e+02, 6.0000e+02, 7.0000e+02, 8.0000e+02]],\n \n         [[6.0000e+00, 7.0000e+00, 8.0000e+00, 9.0000e+00, 1.0000e+01],\n          [6.0000e+01, 7.0000e+01, 8.0000e+01, 9.0000e+01, 1.0000e+02],\n          [6.0000e+02, 7.0000e+02, 8.0000e+02, 9.0000e+02, 1.0000e+03]],\n \n         [[8.0000e+00, 9.0000e+00, 1.0000e+01, 1.1000e+01, 1.2000e+01],\n          [8.0000e+01, 9.0000e+01, 1.0000e+02, 1.1000e+02, 1.2000e+02],\n          [8.0000e+02, 9.0000e+02, 1.0000e+03, 1.1000e+03, 1.2000e+03]],\n \n         [[1.0000e+01, 1.1000e+01, 1.2000e+01, 1.3000e+01, 1.4000e+01],\n          [1.0000e+02, 1.1000e+02, 1.2000e+02, 1.3000e+02, 1.4000e+02],\n          [1.0000e+03, 1.1000e+03, 1.2000e+03, 1.3000e+03, 1.4000e+03]],\n \n         [[1.2000e+01, 1.3000e+01, 1.4000e+01, 1.5000e+01, 1.6000e+01],\n          [1.2000e+02, 1.3000e+02, 1.4000e+02, 1.5000e+02, 1.6000e+02],\n          [1.2000e+03, 1.3000e+03, 1.4000e+03, 1.5000e+03, 1.6000e+03]],\n \n         [[1.4000e+01, 1.5000e+01, 1.6000e+01, 1.7000e+01, 1.8000e+01],\n          [1.4000e+02, 1.5000e+02, 1.6000e+02, 1.7000e+02, 1.8000e+02],\n          [1.4000e+03, 1.5000e+03, 1.6000e+03, 1.7000e+03, 1.8000e+03]]]),\n tensor([[[0.0000e+00, 1.0000e+00, 2.0000e+00, 3.0000e+00, 4.0000e+00],\n          [0.0000e+00, 1.0000e+01, 2.0000e+01, 3.0000e+01, 4.0000e+01],\n          [0.0000e+00, 1.0000e+02, 2.0000e+02, 3.0000e+02, 4.0000e+02]],\n \n         [[2.0000e+00, 3.0000e+00, 4.0000e+00, 5.0000e+00, 6.0000e+00],\n          [2.0000e+01, 3.0000e+01, 4.0000e+01, 5.0000e+01, 6.0000e+01],\n          [2.0000e+02, 3.0000e+02, 4.0000e+02, 5.0000e+02, 6.0000e+02]],\n \n         [[4.0000e+00, 5.0000e+00, 6.0000e+00, 7.0000e+00, 8.0000e+00],\n          [4.0000e+01, 5.0000e+01, 6.0000e+01, 7.0000e+01, 8.0000e+01],\n          [4.0000e+02, 5.0000e+02, 6.0000e+02, 7.0000e+02, 8.0000e+02]],\n \n         [[6.0000e+00, 7.0000e+00, 8.0000e+00, 9.0000e+00, 1.0000e+01],\n          [6.0000e+01, 7.0000e+01, 8.0000e+01, 9.0000e+01, 1.0000e+02],\n          [6.0000e+02, 7.0000e+02, 8.0000e+02, 9.0000e+02, 1.0000e+03]],\n \n         [[8.0000e+00, 9.0000e+00, 1.0000e+01, 1.1000e+01, 1.2000e+01],\n          [8.0000e+01, 9.0000e+01, 1.0000e+02, 1.1000e+02, 1.2000e+02],\n          [8.0000e+02, 9.0000e+02, 1.0000e+03, 1.1000e+03, 1.2000e+03]],\n \n         [[1.0000e+01, 1.1000e+01, 1.2000e+01, 1.3000e+01, 1.4000e+01],\n          [1.0000e+02, 1.1000e+02, 1.2000e+02, 1.3000e+02, 1.4000e+02],\n          [1.0000e+03, 1.1000e+03, 1.2000e+03, 1.3000e+03, 1.4000e+03]],\n \n         [[1.2000e+01, 1.3000e+01, 1.4000e+01, 1.5000e+01, 1.6000e+01],\n          [1.2000e+02, 1.3000e+02, 1.4000e+02, 1.5000e+02, 1.6000e+02],\n          [1.2000e+03, 1.3000e+03, 1.4000e+03, 1.5000e+03, 1.6000e+03]],\n \n         [[1.4000e+01, 1.5000e+01, 1.6000e+01, 1.7000e+01, 1.8000e+01],\n          [1.4000e+02, 1.5000e+02, 1.6000e+02, 1.7000e+02, 1.8000e+02],\n          [1.4000e+03, 1.5000e+03, 1.6000e+03, 1.7000e+03, 1.8000e+03]]]))",
    "crumbs": [
      "Data",
      "Unwindowed datasets"
    ]
  },
  {
    "objectID": "models.mlp.html",
    "href": "models.mlp.html",
    "title": "MLP",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on:\nFawaz, H. I., Forestier, G., Weber, J., Idoumghar, L., & Muller, P. A. (2019). Deep learning for time series classification: a review. Data Mining and Knowledge Discovery, 33(4), 917-963.\nOfficial MLP TensorFlow implementation: https://github.com/hfawaz/dl-4-tsc/blob/master/classifiers/mlp.py\n\nsource\n\nMLP\n\n MLP (c_in, c_out, seq_len, layers=[500, 500, 500], ps=[0.1, 0.2, 0.2],\n      act=ReLU(inplace=True), use_bn=False, bn_final=False,\n      lin_first=False, fc_dropout=0.0, y_range=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nnvars = 3\nseq_len = 128\nc_out = 2\nxb = torch.rand(bs, nvars, seq_len)\nmodel = MLP(nvars, c_out, seq_len)\ntest_eq(model(xb).shape, (bs, c_out))\nmodel\n\nMLP(\n  (flatten): Reshape(bs)\n  (mlp): ModuleList(\n    (0): LinBnDrop(\n      (0): Dropout(p=0.1, inplace=False)\n      (1): Linear(in_features=384, out_features=500, bias=True)\n      (2): ReLU(inplace=True)\n    )\n    (1): LinBnDrop(\n      (0): Dropout(p=0.2, inplace=False)\n      (1): Linear(in_features=500, out_features=500, bias=True)\n      (2): ReLU(inplace=True)\n    )\n    (2): LinBnDrop(\n      (0): Dropout(p=0.2, inplace=False)\n      (1): Linear(in_features=500, out_features=500, bias=True)\n      (2): ReLU(inplace=True)\n    )\n  )\n  (head): Sequential(\n    (0): LinBnDrop(\n      (0): Linear(in_features=500, out_features=2, bias=True)\n    )\n  )\n)",
    "crumbs": [
      "Models",
      "MLPs",
      "MLP"
    ]
  },
  {
    "objectID": "models.multiinputnet.html",
    "href": "models.multiinputnet.html",
    "title": "MultiInputNet",
    "section": "",
    "text": "This is an implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co).\nIt can be used to combine different types of deep learning models into a single one that will accept multiple inputs from a MixedDataLoaders.\n\nsource\n\nMultiInputNet\n\n MultiInputNet (*models, c_out=None, reshape_fn=None, multi_output=False,\n                custom_head=None, device=None, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.basics import *\nfrom tsai.data.all import *\nfrom tsai.models.utils import *\nfrom tsai.models.InceptionTimePlus import *\nfrom tsai.models.TabModel import *\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, split_data=False)\nts_features_df = get_ts_features(X, y)\n\nFeature Extraction: 100%|███████████████████████████████████████████| 40/40 [00:07&lt;00:00,  5.23it/s]\n\n\n\n# raw ts\ntfms  = [None, [TSCategorize()]]\nbatch_tfms = TSStandardize()\nts_dls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nts_model = build_ts_model(InceptionTimePlus, dls=ts_dls)\n\n# ts features\ncat_names = None\ncont_names = ts_features_df.columns[:-2]\ny_names = 'target'\ntab_dls = get_tabular_dls(ts_features_df, cat_names=cat_names, cont_names=cont_names, y_names=y_names, splits=splits)\ntab_model = build_tabular_model(TabModel, dls=tab_dls)\n\n# mixed\nmixed_dls = get_mixed_dls(ts_dls, tab_dls)\nMultiModalNet = MultiInputNet(ts_model, tab_model)\nlearn = Learner(mixed_dls, MultiModalNet, metrics=[accuracy, RocAuc()])\nlearn.fit_one_cycle(1, 1e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\nroc_auc_score\ntime\n\n\n\n\n0\n1.780674\n1.571718\n0.477778\n0.857444\n00:05\n\n\n\n\n\n\n(ts, (cat, cont)),yb = mixed_dls.one_batch()\nlearn.model((ts, (cat, cont))).shape\n\ntorch.Size([64, 6])\n\n\n\ntab_dls.c, ts_dls.c, ts_dls.cat\n\n(6, 6, True)\n\n\n\nlearn.loss_func\n\nFlattenedLoss of CrossEntropyLoss()",
    "crumbs": [
      "Models",
      "Miscellaneous",
      "MultiInputNet"
    ]
  },
  {
    "objectID": "models.omniscalecnn.html",
    "href": "models.omniscalecnn.html",
    "title": "OmniScaleCNN",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\ngenerate_layer_parameter_list\n\n generate_layer_parameter_list (start, end, layers, in_channel=1)\n\n\nsource\n\n\nget_out_channel_number\n\n get_out_channel_number (paramenter_layer, in_channel, prime_list)\n\n\nsource\n\n\nget_Prime_number_in_a_range\n\n get_Prime_number_in_a_range (start, end)\n\n\nsource\n\n\nOmniScaleCNN\n\n OmniScaleCNN (c_in, c_out, seq_len, layers=[1024, 229376],\n               few_shot=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nbuild_layer_with_layer_parameter\n\n build_layer_with_layer_parameter (layer_parameters)\n\nformerly build_layer_with_layer_parameter\n\nsource\n\n\nSampaddingConv1D_BN\n\n SampaddingConv1D_BN (in_channels, out_channels, kernel_size)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nbs = 16\nc_in = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, c_in, seq_len)\nm = create_model(OmniScaleCNN, c_in, c_out, seq_len)\ntest_eq(OmniScaleCNN(c_in, c_out, seq_len)(xb).shape, [bs, c_out])\nm\n\nOmniScaleCNN(\n  (net): Sequential(\n    (0): build_layer_with_layer_parameter(\n      (conv_list): ModuleList(\n        (0): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(0, 0), value=0)\n          (conv1d): Conv1d(3, 56, kernel_size=(1,), stride=(1,))\n          (bn): BatchNorm1d(56, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (1): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(0, 1), value=0)\n          (conv1d): Conv1d(3, 56, kernel_size=(2,), stride=(1,))\n          (bn): BatchNorm1d(56, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (2): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(1, 1), value=0)\n          (conv1d): Conv1d(3, 56, kernel_size=(3,), stride=(1,))\n          (bn): BatchNorm1d(56, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n    )\n    (1): build_layer_with_layer_parameter(\n      (conv_list): ModuleList(\n        (0): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(0, 0), value=0)\n          (conv1d): Conv1d(168, 227, kernel_size=(1,), stride=(1,))\n          (bn): BatchNorm1d(227, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (1): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(0, 1), value=0)\n          (conv1d): Conv1d(168, 227, kernel_size=(2,), stride=(1,))\n          (bn): BatchNorm1d(227, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (2): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(1, 1), value=0)\n          (conv1d): Conv1d(168, 227, kernel_size=(3,), stride=(1,))\n          (bn): BatchNorm1d(227, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n    )\n    (2): build_layer_with_layer_parameter(\n      (conv_list): ModuleList(\n        (0): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(0, 0), value=0)\n          (conv1d): Conv1d(681, 510, kernel_size=(1,), stride=(1,))\n          (bn): BatchNorm1d(510, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n        (1): SampaddingConv1D_BN(\n          (padding): ConstantPad1d(padding=(0, 1), value=0)\n          (conv1d): Conv1d(681, 510, kernel_size=(2,), stride=(1,))\n          (bn): BatchNorm1d(510, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        )\n      )\n    )\n  )\n  (gap): GAP1d(\n    (gap): AdaptiveAvgPool1d(output_size=1)\n    (flatten): Flatten(full=False)\n  )\n  (hidden): Linear(in_features=1020, out_features=2, bias=True)\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "OmniScaleCNN"
    ]
  },
  {
    "objectID": "models.multirocketplus.html",
    "href": "models.multirocketplus.html",
    "title": "MultiRocketPlus",
    "section": "",
    "text": "MultiRocket: Multiple pooling operators and transformations for fast and effective time series classification.\n\nThis is a Pytorch implementation of MultiRocket developed by Malcolm McLean and Ignacio Oguiza based on:\nTan, C. W., Dempster, A., Bergmeir, C., & Webb, G. I. (2022). MultiRocket: multiple pooling operators and transformations for fast and effective time series classification. Data Mining and Knowledge Discovery, 36(5), 1623-1646.\nOriginal paper: https://link.springer.com/article/10.1007/s10618-022-00844-1\nOriginal repository: https://github.com/ChangWeiTan/MultiRocket\n\nsource\n\nFlatten\n\n Flatten (*args, **kwargs)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nfrom tsai.imports import default_device\n\n\no = torch.rand(2, 3, 5, 4).to(default_device()) - .3\nprint(o)\n\noutput = _LPVV(o, dim=2)\nprint(output)  # Should print: torch.Size([2, 3, 4])\n\ntensor([[[[ 0.5644, -0.0509, -0.0390,  0.4091],\n          [ 0.0517, -0.1471,  0.6458,  0.5593],\n          [ 0.4516, -0.0821,  0.1271,  0.0592],\n          [ 0.4151,  0.4376,  0.0763,  0.3780],\n          [ 0.2653, -0.1817,  0.0156,  0.4993]],\n\n         [[-0.0779,  0.0858,  0.1982,  0.3224],\n          [ 0.1130,  0.0714, -0.1779,  0.5360],\n          [-0.1848, -0.2270, -0.0925, -0.1217],\n          [ 0.2820, -0.0205, -0.2777,  0.3755],\n          [-0.2490,  0.2613,  0.4237,  0.4534]],\n\n         [[-0.0162,  0.6368,  0.0016,  0.1467],\n          [ 0.6035, -0.1365,  0.6930,  0.6943],\n          [ 0.2790,  0.3818, -0.0731,  0.0167],\n          [ 0.6442,  0.3443,  0.4829, -0.0944],\n          [ 0.2932,  0.6952,  0.5541,  0.5946]]],\n\n\n        [[[ 0.6757,  0.5740,  0.3071,  0.4400],\n          [-0.2344, -0.1056,  0.4773,  0.2432],\n          [ 0.2595, -0.1528, -0.0866,  0.6201],\n          [ 0.0657,  0.1220,  0.4849,  0.4254],\n          [ 0.3399, -0.1609,  0.3465,  0.2389]],\n\n         [[-0.0765,  0.0516,  0.0028,  0.4381],\n          [ 0.5212, -0.2781, -0.0896, -0.0301],\n          [ 0.6857,  0.3583,  0.5869,  0.3418],\n          [ 0.3002,  0.5135,  0.6011,  0.6499],\n          [-0.2807, -0.2888,  0.3965,  0.6585]],\n\n         [[-0.1368,  0.6677,  0.1439,  0.1434],\n          [-0.1820,  0.1041, -0.1211,  0.6103],\n          [ 0.5808,  0.4588,  0.4572,  0.3713],\n          [ 0.2389, -0.1392,  0.1371, -0.1570],\n          [ 0.2840,  0.1214, -0.0059,  0.5064]]]], device='mps:0')\ntensor([[[ 1.0000, -0.6000,  0.6000,  1.0000],\n         [-0.6000, -0.2000, -0.6000, -0.2000],\n         [ 0.6000,  0.2000, -0.2000,  0.2000]],\n\n        [[ 0.2000, -0.6000, -0.2000,  1.0000],\n         [ 0.2000, -0.2000,  0.2000,  0.2000],\n         [ 0.2000,  0.2000, -0.2000,  0.2000]]], device='mps:0')\n\n\n\noutput = _MPV(o, dim=2)\nprint(output)  # Should print: torch.Size([2, 3, 4])\n\ntensor([[[0.3496, 0.4376, 0.2162, 0.3810],\n         [0.1975, 0.1395, 0.3109, 0.4218],\n         [0.4550, 0.5145, 0.4329, 0.3631]],\n\n        [[0.3352, 0.3480, 0.4040, 0.3935],\n         [0.5023, 0.3078, 0.3968, 0.5221],\n         [0.3679, 0.3380, 0.2460, 0.4079]]], device='mps:0')\n\n\n\noutput = _RSPV(o, dim=2)\nprint(output)  # Should print: torch.Size([2, 3, 4])\n\ntensor([[[ 1.0000, -0.0270,  0.9138,  1.0000],\n         [-0.1286,  0.2568,  0.0630,  0.8654],\n         [ 0.9823,  0.8756,  0.9190,  0.8779]],\n\n        [[ 0.7024,  0.2482,  0.8983,  1.0000],\n         [ 0.6168,  0.2392,  0.8931,  0.9715],\n         [ 0.5517,  0.8133,  0.7065,  0.8244]]], device='mps:0')\n\n\n\noutput = _PPV(o, dim=2)\nprint(output)  # Should print: torch.Size([2, 3, 4])\n\ntensor([[[-0.3007, -1.0097, -0.6697, -0.2381],\n         [-1.0466, -0.9316, -0.9705, -0.3738],\n         [-0.2786, -0.2314, -0.3366, -0.4569]],\n\n        [[-0.5574, -0.8893, -0.3883, -0.2130],\n         [-0.5401, -0.8574, -0.4009, -0.1767],\n         [-0.6861, -0.5149, -0.7555, -0.4102]]], device='mps:0')\n\n\n\nsource\n\n\nMultiRocketFeaturesPlus\n\n MultiRocketFeaturesPlus (c_in, seq_len, num_features=10000,\n                          max_dilations_per_kernel=32, kernel_size=9,\n                          max_num_channels=9, max_num_kernels=84,\n                          diff=False)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nMultiRocketBackbonePlus\n\n MultiRocketBackbonePlus (c_in, seq_len, num_features=50000,\n                          max_dilations_per_kernel=32, kernel_size=9,\n                          max_num_channels=None, max_num_kernels=84,\n                          use_diff=True)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nMultiRocketPlus\n\n MultiRocketPlus (c_in, c_out, seq_len, d=None, num_features=50000,\n                  max_dilations_per_kernel=32, kernel_size=9,\n                  max_num_channels=None, max_num_kernels=84, use_bn=True,\n                  fc_dropout=0, custom_head=None, zero_init=True,\n                  use_diff=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nfrom tsai.imports import default_device\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 20)).to(default_device())\n\nmodel = MultiRocketPlus(5, 3, 20, d=None, use_diff=True).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 3)\noutput.shape\n\ntorch.Size([16, 3])\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 20)).to(default_device())\n\nmodel = MultiRocketPlus(5, 3, 20, d=None, use_diff=False).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 3)\noutput.shape\n\ntorch.Size([16, 3])\n\n\n\nxb = torch.randn(16, 5, 20).to(default_device())\nyb = torch.randint(0, 3, (16, 5, 20)).to(default_device())\n\nmodel = MultiRocketPlus(5, 3, 20, d=20, use_diff=True).to(default_device())\noutput = model(xb)\nassert output.shape == (16, 20, 3)\noutput.shape\n\ntorch.Size([16, 20, 3])",
    "crumbs": [
      "Models",
      "ROCKETs",
      "MultiRocketPlus"
    ]
  },
  {
    "objectID": "callback.predictiondynamics.html",
    "href": "callback.predictiondynamics.html",
    "title": "PredictionDynamics",
    "section": "",
    "text": "Callback used to visualize model predictions during training.\n\nThis is an implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co) based on a blog post by Andrej Karpathy I read some time ago that I really liked. One of the things he mentioned was this:\n\n“visualize prediction dynamics. I like to visualize model predictions on a fixed test batch during the course of training. The “dynamics” of how these predictions move will give you incredibly good intuition for how the training progresses. Many times it is possible to feel the network “struggle” to fit your data if it wiggles too much in some way, revealing instabilities. Very low or very high learning rates are also easily noticeable in the amount of jitter.” A. Karpathy\n\n\nsource\n\nPredictionDynamics\n\n PredictionDynamics (show_perc=1.0, figsize=(10, 6), alpha=0.3, size=30,\n                     color='lime', cmap='gist_rainbow', normalize=False,\n                     sensitivity=None, specificity=None)\n\nBasic class handling tweaks of the training loop by changing a Learner in various events\n\nfrom tsai.basics import *\nfrom tsai.models.InceptionTime import *\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, split_data=False)\ncheck_data(X, y, splits, False)\n\nX      - shape: [360 samples x 24 features x 51 timesteps]  type: memmap  dtype:float32  isnan: 0\ny      - shape: (360,)  type: memmap  dtype:&lt;U3  n_classes: 6 (60 samples per class) ['1.0', '2.0', '3.0', '4.0', '5.0', '6.0']  isnan: False\nsplits - n_splits: 2 shape: [180, 180]  overlap: False\n\n\n\ntfms  = [None, [Categorize()]]\nbatch_tfms = [TSStandardize(by_var=True)]\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nlearn = ts_learner(dls, InceptionTime, metrics=accuracy, cbs=PredictionDynamics()) \nlearn.fit_one_cycle(2, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.885462\n1.773872\n0.238889\n00:05\n\n\n1\n1.425667\n1.640418\n0.377778\n00:05\n\n\n\n\n\n\n\n\n\n\n\n\ntrain_loss\nvalid_loss\naccuracy\n\n\n\n\n1\n1.425667\n1.640418\n0.377778",
    "crumbs": [
      "Training",
      "Callbacks",
      "PredictionDynamics"
    ]
  },
  {
    "objectID": "models.tabtransformer.html",
    "href": "models.tabtransformer.html",
    "title": "TabTransformer",
    "section": "",
    "text": "This is an unofficial TabTransformer Pytorch implementation created by Ignacio Oguiza (oguiza@timeseriesAI.co)\nHuang, X., Khetan, A., Cvitkovic, M., & Karnin, Z. (2020). TabTransformer: Tabular Data Modeling Using Contextual Embeddings. arXiv preprint https://arxiv.org/pdf/2012.06678\nOfficial repo: https://github.com/awslabs/autogluon/tree/master/tabular/src/autogluon/tabular/models/tab_transformer\n\nsource\n\nTabTransformer\n\n TabTransformer (classes, cont_names, c_out, column_embed=True,\n                 add_shared_embed=False, shared_embed_div=8,\n                 embed_dropout=0.1, drop_whole_embed=False, d_model=32,\n                 n_layers=6, n_heads=8, d_k=None, d_v=None, d_ff=None,\n                 res_attention=True, attention_act='gelu',\n                 res_dropout=0.1, norm_cont=True, mlp_mults=(4, 2),\n                 mlp_dropout=0.0, mlp_act=None, mlp_skip=False,\n                 mlp_bn=False, bn_final=False)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nFullEmbeddingDropout\n\n FullEmbeddingDropout (dropout:float)\n\nFrom https://github.com/jrzaurin/pytorch-widedeep/blob/be96b57f115e4a10fde9bb82c35380a3ac523f52/pytorch_widedeep/models/tab_transformer.py#L153\n\nsource\n\n\nSharedEmbedding\n\n SharedEmbedding (num_embeddings, embedding_dim, shared_embed=True,\n                  add_shared_embed=False, shared_embed_div=8)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\nsource\n\n\nifnone\n\n ifnone (a, b)\n\nb if a is None else a\n\nfrom fastai.tabular.all import *\n\n\npath = untar_data(URLs.ADULT_SAMPLE)\ndf = pd.read_csv(path/'adult.csv')\ndls = TabularDataLoaders.from_csv(path/'adult.csv', path=path, y_names=\"salary\",\n    cat_names = ['workclass', 'education', 'marital-status', 'occupation', 'relationship', 'race'],\n    cont_names = ['age', 'fnlwgt', 'education-num'],\n    procs = [Categorify, FillMissing, Normalize])\nx_cat, x_cont, yb = first(dls.train)\nmodel = TabTransformer(dls.classes, dls.cont_names, dls.c)\ntest_eq(model(x_cat, x_cont).shape, (dls.train.bs, dls.c))",
    "crumbs": [
      "Models",
      "Tabular models",
      "TabTransformer"
    ]
  },
  {
    "objectID": "models.convtranplus.html",
    "href": "models.convtranplus.html",
    "title": "ConvTranPlus",
    "section": "",
    "text": "ConvTran: Improving Position Encoding of Transformers for Multivariate Time Series Classification\n\nThis is a Pytorch implementation of ConvTran adapted by Ignacio Oguiza and based on:\nFoumani, N. M., Tan, C. W., Webb, G. I., & Salehi, M. (2023). Improving Position Encoding of Transformers for Multivariate Time Series Classification. arXiv preprint arXiv:2305.16642.\nPre-print: https://arxiv.org/abs/2305.16642v1\nOriginal repository: https://github.com/Navidfoumani/ConvTran\n\nsource\n\ntAPE\n\n tAPE (d_model:int, seq_len=1024, dropout:float=0.1, scale_factor=1.0)\n\ntime Absolute Position Encoding\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd_model\nint\n\nthe embedding dimension\n\n\nseq_len\nint\n1024\nthe max. length of the incoming sequence\n\n\ndropout\nfloat\n0.1\ndropout value\n\n\nscale_factor\nfloat\n1.0\n\n\n\n\n\nt = torch.randn(8, 50, 128)\nassert tAPE(128, 50)(t).shape == t.shape\n\n\nsource\n\n\nAbsolutePositionalEncoding\n\n AbsolutePositionalEncoding (d_model:int, seq_len=1024, dropout:float=0.1,\n                             scale_factor=1.0)\n\nAbsolute positional encoding\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd_model\nint\n\nthe embedding dimension\n\n\nseq_len\nint\n1024\nthe max. length of the incoming sequence\n\n\ndropout\nfloat\n0.1\ndropout value\n\n\nscale_factor\nfloat\n1.0\n\n\n\n\n\nt = torch.randn(8, 50, 128)\nassert AbsolutePositionalEncoding(128, 50)(t).shape == t.shape\n\n\nsource\n\n\nLearnablePositionalEncoding\n\n LearnablePositionalEncoding (d_model:int, seq_len=1024,\n                              dropout:float=0.1)\n\nLearnable positional encoding\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd_model\nint\n\nthe embedding dimension\n\n\nseq_len\nint\n1024\nthe max. length of the incoming sequence\n\n\ndropout\nfloat\n0.1\ndropout value\n\n\n\n\nt = torch.randn(8, 50, 128)\nassert LearnablePositionalEncoding(128, 50)(t).shape == t.shape\n\n\nsource\n\n\nAttention\n\n Attention (d_model:int, n_heads:int=8, dropout:float=0.01)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd_model\nint\n\nEmbedding dimension\n\n\nn_heads\nint\n8\nnumber of attention heads\n\n\ndropout\nfloat\n0.01\ndropout\n\n\n\n\nt = torch.randn(8, 50, 128)\nassert Attention(128)(t).shape == t.shape\n\n\nsource\n\n\nAttention_Rel_Scl\n\n Attention_Rel_Scl (d_model:int, seq_len:int, n_heads:int=8,\n                    dropout:float=0.01)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd_model\nint\n\nEmbedding dimension\n\n\nseq_len\nint\n\nsequence length\n\n\nn_heads\nint\n8\nnumber of attention heads\n\n\ndropout\nfloat\n0.01\ndropout\n\n\n\n\nt = torch.randn(8, 50, 128)\nassert Attention_Rel_Scl(128, 50)(t).shape == t.shape\n\n\nsource\n\n\nAttention_Rel_Vec\n\n Attention_Rel_Vec (d_model:int, seq_len:int, n_heads:int=8,\n                    dropout:float=0.01)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\nType\nDefault\nDetails\n\n\n\n\nd_model\nint\n\nEmbedding dimension\n\n\nseq_len\nint\n\nsequence length\n\n\nn_heads\nint\n8\nnumber of attention heads\n\n\ndropout\nfloat\n0.01\ndropout\n\n\n\n\nt = torch.randn(8, 50, 128)\nassert Attention_Rel_Vec(128, 50)(t).shape == t.shape\n\n\nsource\n\n\nConvTranBackbone\n\n ConvTranBackbone (c_in:int, seq_len:int, d_model=16, n_heads:int=8,\n                   dim_ff:int=256, abs_pos_encode:str='tAPE',\n                   rel_pos_encode:str='eRPE', dropout:float=0.01)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing them to be nested in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will also have their parameters converted when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\n\n\n\nseq_len\nint\n\n\n\n\nd_model\nint\n16\nInternal dimension of transformer embeddings\n\n\nn_heads\nint\n8\nNumber of multi-headed attention heads\n\n\ndim_ff\nint\n256\nDimension of dense feedforward part of transformer layer\n\n\nabs_pos_encode\nstr\ntAPE\nAbsolute Position Embedding. choices={‘tAPE’, ‘sin’, ‘learned’, None}\n\n\nrel_pos_encode\nstr\neRPE\nRelative Position Embedding. choices={‘eRPE’, ‘vector’, None}\n\n\ndropout\nfloat\n0.01\nDroupout regularization ratio\n\n\n\n\nt = torch.randn(8, 5, 20)\nassert ConvTranBackbone(5, 20)(t).shape, (8, 16, 20)\n\n\nsource\n\n\nConvTranPlus\n\n ConvTranPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n               d_model:int=16, n_heads:int=8, dim_ff:int=256,\n               abs_pos_encode:str='tAPE', rel_pos_encode:str='eRPE',\n               encoder_dropout:float=0.01, fc_dropout:float=0.1,\n               use_bn:bool=True, flatten:bool=True, custom_head:Any=None)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nNumber of channels in input\n\n\nc_out\nint\n\nNumber of channels in output\n\n\nseq_len\nint\n\nNumber of input sequence length\n\n\nd\ntuple\nNone\noutput shape (excluding batch dimension).\n\n\nd_model\nint\n16\nInternal dimension of transformer embeddings\n\n\nn_heads\nint\n8\nNumber of multi-headed attention heads\n\n\ndim_ff\nint\n256\nDimension of dense feedforward part of transformer layer\n\n\nabs_pos_encode\nstr\ntAPE\nAbsolute Position Embedding. choices={‘tAPE’, ‘sin’, ‘learned’, None}\n\n\nrel_pos_encode\nstr\neRPE\nRelative Position Embedding. choices={‘eRPE’, ‘vector’, None}\n\n\nencoder_dropout\nfloat\n0.01\nDroupout regularization ratio for the encoder\n\n\nfc_dropout\nfloat\n0.1\nDroupout regularization ratio for the head\n\n\nuse_bn\nbool\nTrue\nindicates if batchnorm will be applied to the model head.\n\n\nflatten\nbool\nTrue\nthis will flatten the output of the encoder before applying the head if True.\n\n\ncustom_head\nAny\nNone\ncustom head that will be applied to the model head (optional).\n\n\n\n\nxb = torch.randn(16, 5, 20)\n\nmodel = ConvTranPlus(5, 3, 20, d=None)\noutput = model(xb)\nassert output.shape == (16, 3)\n\n\nxb = torch.randn(16, 5, 20)\n\nmodel = ConvTranPlus(5, 3, 20, d=5)\noutput = model(xb)\nassert output.shape == (16, 5, 3)\n\n\nxb = torch.randn(16, 5, 20)\n\nmodel = ConvTranPlus(5, 3, 20, d=(2, 10))\noutput = model(xb)\nassert output.shape == (16, 2, 10, 3)",
    "crumbs": [
      "Models",
      "Hybrid models",
      "ConvTranPlus"
    ]
  },
  {
    "objectID": "data.features.html",
    "href": "data.features.html",
    "title": "Featurizing Time Series",
    "section": "",
    "text": "Functions used to transform time series into a dataframe that can be used to create tabular dataloaders.\n\nIn this case we are using tsfresh that is one of the most widely known libraries used to create features from time series. You can get more details about this library here: https://tsfresh.readthedocs.io/en/latest/\n\nsource\n\nget_ts_features\n\n get_ts_features (X:Union[numpy.ndarray,torch.Tensor],\n                  y:Union[NoneType,numpy.ndarray,torch.Tensor]=None,\n                  features:Union[str,dict]='min',\n                  n_jobs:Optional[int]=None, **kwargs)\n\nArgs: X: np.array or torch.Tesnor of shape [samples, dimensions, timesteps]. y: Not required for unlabeled data. Otherwise, you need to pass it. features: ‘min’, ‘efficient’, ‘all’, or a dictionary. Be aware that ‘efficient’ and ‘all’ may required substantial memory and time.\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\nX.shape\n\n(360, 24, 51)\n\n\nThere are 3 levels of fatures you can extract: ‘min’, ‘efficient’ and ‘all’. I’d encourage you to start with min as feature creation may take a long time.\nIn addition to this, you can pass a dictionary to build the desired features (see tsfresh documentation in the link above).\n\nts_features_df = get_ts_features(X, y)\nts_features_df.shape\n\nFeature Extraction: 100%|██████████| 40/40 [00:09&lt;00:00,  4.00it/s]\n\n\n(360, 241)\n\n\nThe ‘min’ set creates a dataframe with 8 features per channel + 1 per target (total 193) for each time series sample (360).\n\ncont_names = ts_features_df.columns[:-1]\ny_names = 'target'\ndls = get_tabular_dls(ts_features_df, splits=splits, cont_names=cont_names, y_names=y_names)\ndls.show_batch()\n\n\n\n\n\n0__sum_values\n0__median\n0__mean\n0__length\n0__standard_deviation\n0__variance\n0__root_mean_square\n0__maximum\n0__absolute_maximum\n0__minimum\n1__sum_values\n1__median\n1__mean\n1__length\n1__standard_deviation\n1__variance\n1__root_mean_square\n1__maximum\n1__absolute_maximum\n1__minimum\n2__sum_values\n2__median\n2__mean\n2__length\n2__standard_deviation\n2__variance\n2__root_mean_square\n2__maximum\n2__absolute_maximum\n2__minimum\n3__sum_values\n3__median\n3__mean\n3__length\n3__standard_deviation\n3__variance\n3__root_mean_square\n3__maximum\n3__absolute_maximum\n3__minimum\n4__sum_values\n4__median\n4__mean\n4__length\n4__standard_deviation\n4__variance\n4__root_mean_square\n4__maximum\n4__absolute_maximum\n4__minimum\n5__sum_values\n5__median\n5__mean\n5__length\n5__standard_deviation\n5__variance\n5__root_mean_square\n5__maximum\n5__absolute_maximum\n5__minimum\n6__sum_values\n6__median\n6__mean\n6__length\n6__standard_deviation\n6__variance\n6__root_mean_square\n6__maximum\n6__absolute_maximum\n6__minimum\n7__sum_values\n7__median\n7__mean\n7__length\n7__standard_deviation\n7__variance\n7__root_mean_square\n7__maximum\n7__absolute_maximum\n7__minimum\n8__sum_values\n8__median\n8__mean\n8__length\n8__standard_deviation\n8__variance\n8__root_mean_square\n8__maximum\n8__absolute_maximum\n8__minimum\n9__sum_values\n9__median\n9__mean\n9__length\n9__standard_deviation\n9__variance\n9__root_mean_square\n9__maximum\n9__absolute_maximum\n9__minimum\n10__sum_values\n10__median\n10__mean\n10__length\n10__standard_deviation\n10__variance\n10__root_mean_square\n10__maximum\n10__absolute_maximum\n10__minimum\n11__sum_values\n11__median\n11__mean\n11__length\n11__standard_deviation\n11__variance\n11__root_mean_square\n11__maximum\n11__absolute_maximum\n11__minimum\n12__sum_values\n12__median\n12__mean\n12__length\n12__standard_deviation\n12__variance\n12__root_mean_square\n12__maximum\n12__absolute_maximum\n12__minimum\n13__sum_values\n13__median\n13__mean\n13__length\n13__standard_deviation\n13__variance\n13__root_mean_square\n13__maximum\n13__absolute_maximum\n13__minimum\n14__sum_values\n14__median\n14__mean\n14__length\n14__standard_deviation\n14__variance\n14__root_mean_square\n14__maximum\n14__absolute_maximum\n14__minimum\n15__sum_values\n15__median\n15__mean\n15__length\n15__standard_deviation\n15__variance\n15__root_mean_square\n15__maximum\n15__absolute_maximum\n15__minimum\n16__sum_values\n16__median\n16__mean\n16__length\n16__standard_deviation\n16__variance\n16__root_mean_square\n16__maximum\n16__absolute_maximum\n16__minimum\n17__sum_values\n17__median\n17__mean\n17__length\n17__standard_deviation\n17__variance\n17__root_mean_square\n17__maximum\n17__absolute_maximum\n17__minimum\n18__sum_values\n18__median\n18__mean\n18__length\n18__standard_deviation\n18__variance\n18__root_mean_square\n18__maximum\n18__absolute_maximum\n18__minimum\n19__sum_values\n19__median\n19__mean\n19__length\n19__standard_deviation\n19__variance\n19__root_mean_square\n19__maximum\n19__absolute_maximum\n19__minimum\n20__sum_values\n20__median\n20__mean\n20__length\n20__standard_deviation\n20__variance\n20__root_mean_square\n20__maximum\n20__absolute_maximum\n20__minimum\n21__sum_values\n21__median\n21__mean\n21__length\n21__standard_deviation\n21__variance\n21__root_mean_square\n21__maximum\n21__absolute_maximum\n21__minimum\n22__sum_values\n22__median\n22__mean\n22__length\n22__standard_deviation\n22__variance\n22__root_mean_square\n22__maximum\n22__absolute_maximum\n22__minimum\n23__sum_values\n23__median\n23__mean\n23__length\n23__standard_deviation\n23__variance\n23__root_mean_square\n23__maximum\n23__absolute_maximum\n23__minimum\ntarget\n\n\n\n\n0\n-29.398621\n-0.578626\n-0.576444\n51.0\n0.019595\n0.000384\n0.576777\n-0.536114\n0.606751\n-0.606751\n-88.761322\n-1.745473\n-1.740418\n51.0\n0.033961\n0.001153\n1.740749\n-1.659181\n1.779713\n-1.779713\n-35.539612\n-0.696636\n-0.696855\n51.0\n0.005860\n0.000034\n0.696880\n-0.685844\n0.710908\n-0.710908\n63.889797\n0.837208\n1.252741\n51.0\n0.676822\n0.458088\n1.423885\n2.169677\n2.169677\n0.536361\n-54.103661\n-1.758527\n-1.060856\n51.0\n0.952467\n0.907193\n1.425696\n0.619366\n1.832052\n-1.832052\n-25.470938\n-0.562629\n-0.499430\n51.0\n0.176602\n0.031188\n0.529735\n-0.166668\n0.659942\n-0.659942\n-33.909939\n-0.666688\n-0.664901\n51.0\n0.013168\n0.000173\n0.665031\n-0.643999\n0.682598\n-0.682598\n-39.194389\n-0.766594\n-0.768517\n51.0\n0.007046\n0.000050\n0.768550\n-0.750228\n0.782717\n-0.782717\n-9.894929\n-0.191213\n-0.194018\n51.0\n0.008862\n0.000079\n0.194220\n-0.182825\n0.210663\n-0.210663\n41.573109\n0.658693\n0.815159\n51.0\n0.227995\n0.051982\n0.846443\n1.144142\n1.144142\n0.601647\n-26.870213\n-0.801317\n-0.526867\n51.0\n0.410643\n0.168628\n0.667994\n0.183081\n0.862615\n-0.862615\n-4.248524\n-0.096245\n-0.083304\n51.0\n0.033176\n0.001101\n0.089668\n-0.021126\n0.121141\n-0.121141\n-33.603584\n-0.660318\n-0.658894\n51.0\n0.016815\n0.000283\n0.659108\n-0.626267\n0.684841\n-0.684841\n-70.926521\n-1.409798\n-1.390716\n51.0\n0.031278\n0.000978\n1.391068\n-1.337275\n1.423652\n-1.423652\n-26.984289\n-0.529285\n-0.529104\n51.0\n0.005923\n0.000035\n0.529137\n-0.517306\n0.548614\n-0.548614\n56.133301\n0.789974\n1.100653\n51.0\n0.483293\n0.233572\n1.202085\n1.757948\n1.757948\n0.587645\n-45.478088\n-1.421026\n-0.891727\n51.0\n0.739772\n0.547262\n1.158637\n0.386504\n1.509923\n-1.509923\n-17.145500\n-0.387209\n-0.336186\n51.0\n0.127724\n0.016313\n0.359631\n-0.108017\n0.469502\n-0.469502\n-25.565697\n-0.502589\n-0.501288\n51.0\n0.016613\n0.000276\n0.501563\n-0.465890\n0.535957\n-0.535957\n-77.823814\n-1.519193\n-1.525957\n51.0\n0.028265\n0.000799\n1.526219\n-1.468685\n1.564035\n-1.564035\n-36.996349\n-0.727857\n-0.725419\n51.0\n0.007882\n0.000062\n0.725461\n-0.705429\n0.735931\n-0.735931\n58.453831\n0.779782\n1.146154\n51.0\n0.682839\n0.466269\n1.334143\n2.093526\n2.093526\n0.433132\n-52.249134\n-1.582441\n-1.024493\n51.0\n0.815997\n0.665852\n1.309747\n0.419112\n1.718448\n-1.718448\n-22.941730\n-0.449813\n-0.449838\n51.0\n0.179541\n0.032235\n0.484344\n-0.149044\n0.718254\n-0.718254\n2.0\n\n\n1\n-22.630985\n-0.572027\n-0.443745\n51.0\n0.548965\n0.301363\n0.705884\n0.844384\n1.284441\n-1.284441\n-43.583847\n-1.497262\n-0.854585\n51.0\n1.019406\n1.039188\n1.330227\n1.096710\n1.692231\n-1.692231\n-31.147585\n-0.398927\n-0.610737\n51.0\n0.360847\n0.130210\n0.709373\n-0.256470\n1.562690\n-1.562690\n35.902119\n0.479088\n0.703963\n51.0\n0.365270\n0.133422\n0.793087\n1.559241\n1.559241\n0.320613\n-26.475592\n-1.411000\n-0.519129\n51.0\n1.250764\n1.564410\n1.354218\n1.246734\n1.762012\n-1.762012\n-34.175106\n-0.647045\n-0.670100\n51.0\n0.273988\n0.075069\n0.723950\n-0.189910\n1.339854\n-1.339854\n-25.383873\n-0.599582\n-0.497723\n51.0\n0.304314\n0.092607\n0.583383\n0.198417\n0.860741\n-0.860741\n-23.190578\n-0.632231\n-0.454717\n51.0\n0.267774\n0.071703\n0.527703\n0.086810\n0.735903\n-0.735903\n-9.272245\n0.044390\n-0.181809\n51.0\n0.310334\n0.096307\n0.359668\n0.103880\n0.687320\n-0.687320\n33.800453\n0.639043\n0.662754\n51.0\n0.155807\n0.024276\n0.680822\n0.971393\n0.971393\n0.338048\n-20.350363\n-0.685427\n-0.399027\n51.0\n0.401511\n0.161211\n0.566068\n0.388883\n0.798647\n-0.798647\n-22.385489\n-0.310659\n-0.438931\n51.0\n0.202867\n0.041155\n0.483545\n-0.223507\n0.780465\n-0.780465\n-23.431786\n-0.607775\n-0.459447\n51.0\n0.502495\n0.252501\n0.680876\n0.557547\n1.097538\n-1.097538\n-35.239632\n-1.173477\n-0.690973\n51.0\n0.790543\n0.624958\n1.049953\n0.850109\n1.334061\n-1.334061\n-23.722792\n-0.263811\n-0.465153\n51.0\n0.304623\n0.092795\n0.556024\n-0.096469\n1.355410\n-1.355410\n36.532707\n0.576822\n0.716328\n51.0\n0.285204\n0.081341\n0.771016\n1.347809\n1.347809\n0.321302\n-23.286812\n-1.098079\n-0.456604\n51.0\n0.934937\n0.874106\n1.040478\n0.973006\n1.405902\n-1.405902\n-31.214712\n-0.552194\n-0.612053\n51.0\n0.146669\n0.021512\n0.629381\n-0.445301\n1.042179\n-1.042179\n-23.984716\n-0.675121\n-0.470289\n51.0\n0.554180\n0.307116\n0.726834\n0.807535\n1.182987\n-1.182987\n-39.006611\n-1.346193\n-0.764835\n51.0\n0.884366\n0.782103\n1.169220\n1.003716\n1.507433\n-1.507433\n-28.776979\n-0.436710\n-0.564255\n51.0\n0.328655\n0.108014\n0.652991\n-0.268483\n1.373182\n-1.373182\n33.181316\n0.482228\n0.650614\n51.0\n0.366002\n0.133957\n0.746496\n1.554717\n1.554717\n0.254808\n-25.558233\n-1.347874\n-0.501142\n51.0\n1.110295\n1.232755\n1.218153\n1.149943\n1.741076\n-1.741076\n-33.443592\n-0.659850\n-0.655757\n51.0\n0.246830\n0.060925\n0.700673\n-0.250632\n1.340311\n-1.340311\n6.0\n\n\n2\n-35.085182\n-0.687561\n-0.687945\n51.0\n0.030869\n0.000953\n0.688637\n-0.624283\n0.739868\n-0.739868\n-106.435272\n-2.126637\n-2.086966\n51.0\n0.089233\n0.007963\n2.088873\n-1.959578\n2.215342\n-2.215342\n-43.562584\n-0.854689\n-0.854168\n51.0\n0.032274\n0.001042\n0.854778\n-0.801072\n0.912399\n-0.912399\n73.886467\n1.213113\n1.448754\n51.0\n0.694268\n0.482008\n1.606517\n2.342902\n2.342902\n0.642018\n-67.402786\n-2.043274\n-1.321623\n51.0\n1.021520\n1.043502\n1.670386\n0.217647\n2.288412\n-2.288412\n-40.294270\n-0.799205\n-0.790084\n51.0\n0.048503\n0.002353\n0.791571\n-0.688059\n0.888159\n-0.888159\n-34.629044\n-0.681434\n-0.679001\n51.0\n0.017385\n0.000302\n0.679223\n-0.649223\n0.703762\n-0.703762\n-40.258858\n-0.804071\n-0.789389\n51.0\n0.033163\n0.001100\n0.790086\n-0.741303\n0.842110\n-0.842110\n-12.998519\n-0.267240\n-0.254873\n51.0\n0.017719\n0.000314\n0.255488\n-0.224532\n0.273925\n-0.273925\n47.912884\n0.805694\n0.939468\n51.0\n0.229189\n0.052528\n0.967020\n1.233679\n1.233679\n0.697387\n-28.587210\n-0.880814\n-0.560534\n51.0\n0.403328\n0.162674\n0.690559\n0.038331\n0.921428\n-0.921428\n-10.081242\n-0.202227\n-0.197671\n51.0\n0.030237\n0.000914\n0.199971\n-0.156339\n0.284775\n-0.284775\n-33.949532\n-0.670309\n-0.665677\n51.0\n0.022919\n0.000525\n0.666072\n-0.629390\n0.697200\n-0.697200\n-85.588051\n-1.724138\n-1.678197\n51.0\n0.080795\n0.006528\n1.680141\n-1.563966\n1.791635\n-1.791635\n-36.548447\n-0.725060\n-0.716636\n51.0\n0.030728\n0.000944\n0.717295\n-0.671330\n0.760870\n-0.760870\n65.181526\n1.113361\n1.278069\n51.0\n0.494449\n0.244479\n1.370380\n1.934985\n1.934985\n0.748902\n-54.790508\n-1.635758\n-1.074324\n51.0\n0.817957\n0.669053\n1.350268\n0.139169\n1.839433\n-1.839433\n-28.428947\n-0.573270\n-0.557430\n51.0\n0.053855\n0.002900\n0.560026\n-0.439413\n0.630352\n-0.630352\n-26.714603\n-0.519391\n-0.523816\n51.0\n0.032224\n0.001038\n0.524806\n-0.489540\n0.659033\n-0.659033\n-93.493767\n-1.865099\n-1.833211\n51.0\n0.092432\n0.008544\n1.835540\n-1.700841\n2.010093\n-2.010093\n-43.577209\n-0.860299\n-0.854455\n51.0\n0.049561\n0.002456\n0.855891\n-0.796042\n1.014816\n-1.014816\n65.893486\n1.051441\n1.292029\n51.0\n0.685999\n0.470595\n1.462851\n2.178514\n2.178514\n0.574974\n-64.151787\n-1.856631\n-1.257878\n51.0\n0.804017\n0.646444\n1.492884\n-0.037161\n2.008020\n-2.008020\n-39.252415\n-0.786807\n-0.769655\n51.0\n0.054600\n0.002981\n0.771589\n-0.582144\n0.898071\n-0.898071\n3.0\n\n\n3\n9.418392\n0.124306\n0.184674\n51.0\n0.683525\n0.467206\n0.708033\n1.098620\n1.098620\n-0.619085\n-65.183624\n-1.598239\n-1.278110\n51.0\n0.931468\n0.867632\n1.581518\n0.194134\n2.234432\n-2.234432\n-41.886803\n-0.976904\n-0.821310\n51.0\n0.252251\n0.063631\n0.859174\n-0.396303\n1.147354\n-1.147354\n45.166958\n0.801148\n0.885627\n51.0\n0.278827\n0.077744\n0.928482\n1.635586\n1.635586\n0.577137\n-35.295097\n-1.093421\n-0.692061\n51.0\n1.567398\n2.456736\n1.713384\n1.325327\n2.416220\n-2.416220\n-19.785007\n-0.294643\n-0.387941\n51.0\n0.282500\n0.079806\n0.479901\n-0.008022\n0.944945\n-0.944945\n-28.304108\n-0.693464\n-0.554982\n51.0\n0.202652\n0.041068\n0.590824\n-0.242434\n0.741845\n-0.741845\n-36.350716\n-0.670180\n-0.712759\n51.0\n0.144370\n0.020843\n0.727233\n-0.523174\n0.890112\n-0.890112\n-28.392370\n-0.522761\n-0.556713\n51.0\n0.107739\n0.011608\n0.567042\n-0.435334\n0.710886\n-0.710886\n38.783321\n0.658475\n0.760457\n51.0\n0.165045\n0.027240\n0.778161\n1.025254\n1.025254\n0.573761\n-29.159790\n-0.807073\n-0.571761\n51.0\n0.451058\n0.203453\n0.728260\n0.058212\n1.089511\n-1.089511\n-0.357431\n0.210966\n-0.007008\n51.0\n0.359132\n0.128976\n0.359200\n0.358109\n0.519043\n-0.519043\n-6.840534\n-0.255334\n-0.134128\n51.0\n0.504682\n0.254704\n0.522201\n0.582558\n0.693457\n-0.693457\n-55.873280\n-1.168818\n-1.095554\n51.0\n0.563111\n0.317094\n1.231801\n-0.219940\n1.721503\n-1.721503\n-37.602516\n-0.815972\n-0.737304\n51.0\n0.176043\n0.030991\n0.758029\n-0.360776\n0.927193\n-0.927193\n43.445599\n0.848623\n0.851875\n51.0\n0.218035\n0.047539\n0.879335\n1.345085\n1.345085\n0.596721\n-33.225483\n-1.050173\n-0.651480\n51.0\n1.146453\n1.314353\n1.318628\n0.890806\n1.963266\n-1.963266\n-12.263644\n-0.319137\n-0.240464\n51.0\n0.276771\n0.076602\n0.366640\n0.244209\n0.701782\n-0.701782\n-1.089832\n-0.055650\n-0.021369\n51.0\n0.549241\n0.301665\n0.549656\n0.656405\n0.802634\n-0.802634\n-58.871620\n-1.318070\n-1.154346\n51.0\n0.793757\n0.630050\n1.400915\n0.036103\n2.034981\n-2.034981\n-38.605354\n-0.873019\n-0.756968\n51.0\n0.309986\n0.096091\n0.817980\n-0.183816\n1.145963\n-1.145963\n44.849518\n0.865092\n0.879402\n51.0\n0.278859\n0.077762\n0.922557\n1.511787\n1.511787\n0.490558\n-35.374996\n-1.168080\n-0.693627\n51.0\n1.392385\n1.938735\n1.555588\n1.122289\n2.264597\n-2.264597\n-23.718605\n-0.533045\n-0.465071\n51.0\n0.283010\n0.080095\n0.544413\n0.070285\n0.913923\n-0.913923\n6.0\n\n\n4\n0.670717\n-0.551674\n0.013151\n51.0\n0.796336\n0.634151\n0.796444\n1.303428\n1.303428\n-0.740258\n-82.721443\n-2.117861\n-1.621989\n51.0\n0.745800\n0.556218\n1.785236\n-0.325693\n2.317141\n-2.317141\n-42.753490\n-0.679642\n-0.838304\n51.0\n0.347571\n0.120805\n0.907501\n-0.450540\n1.606419\n-1.606419\n43.941456\n0.675603\n0.861597\n51.0\n0.571390\n0.326487\n1.033845\n2.105319\n2.105319\n0.364709\n-54.047619\n-2.158519\n-1.059757\n51.0\n1.451326\n2.106348\n1.797063\n1.128832\n2.503777\n-2.503777\n-8.701278\n-0.097304\n-0.170613\n51.0\n0.254706\n0.064875\n0.306568\n0.143676\n0.995945\n-0.995945\n-25.513714\n-0.696055\n-0.500269\n51.0\n0.274384\n0.075287\n0.570575\n0.089958\n0.745964\n-0.745964\n-37.482643\n-0.790602\n-0.734954\n51.0\n0.116809\n0.013644\n0.744178\n-0.541465\n0.878685\n-0.878685\n-33.195599\n-0.672431\n-0.650894\n51.0\n0.199584\n0.039834\n0.680806\n-0.429070\n0.989809\n-0.989809\n34.543270\n0.566918\n0.677319\n51.0\n0.293252\n0.085997\n0.738077\n1.267009\n1.267009\n0.387009\n-30.752882\n-0.775993\n-0.602998\n51.0\n0.315380\n0.099464\n0.680493\n0.063736\n1.075059\n-1.075059\n5.405560\n0.286917\n0.105991\n51.0\n0.283277\n0.080246\n0.302456\n0.384380\n0.392310\n-0.392310\n-10.194630\n-0.575963\n-0.199895\n51.0\n0.608274\n0.369997\n0.640277\n0.946359\n0.946359\n-0.750195\n-67.181175\n-1.644588\n-1.317278\n51.0\n0.480866\n0.231232\n1.402303\n-0.524218\n1.829902\n-1.829902\n-42.235485\n-0.693468\n-0.828147\n51.0\n0.266756\n0.071159\n0.870049\n-0.607596\n1.443514\n-1.443514\n42.286137\n0.849937\n0.829140\n51.0\n0.445894\n0.198822\n0.941432\n1.798162\n1.798162\n0.406039\n-45.729931\n-1.668248\n-0.896665\n51.0\n1.043643\n1.089190\n1.375936\n0.752602\n2.014132\n-2.014132\n-2.545863\n0.035224\n-0.049919\n51.0\n0.176097\n0.031010\n0.183036\n0.169495\n0.488377\n-0.488377\n-7.721382\n-0.629895\n-0.151400\n51.0\n0.731868\n0.535631\n0.747364\n1.081553\n1.081553\n-0.841546\n-73.237610\n-1.826482\n-1.436032\n51.0\n0.668636\n0.447074\n1.584065\n-0.235637\n2.140610\n-2.140610\n-44.032135\n-0.673831\n-0.863375\n51.0\n0.386634\n0.149486\n0.945993\n-0.419474\n1.715174\n-1.715174\n41.510166\n0.733873\n0.813925\n51.0\n0.506757\n0.256803\n0.958789\n1.993738\n1.993738\n0.362309\n-50.167858\n-1.763661\n-0.983684\n51.0\n1.247509\n1.556279\n1.588683\n0.955917\n2.361580\n-2.361580\n-8.757638\n-0.146574\n-0.171718\n51.0\n0.236743\n0.056047\n0.292463\n0.202188\n0.984318\n-0.984318\n6.0\n\n\n5\n-50.560036\n-0.925159\n-0.991373\n51.0\n0.970520\n0.941910\n1.387347\n0.800761\n2.398621\n-2.398621\n-30.233727\n-0.178814\n-0.592818\n51.0\n1.103251\n1.217162\n1.252436\n0.972976\n2.095890\n-2.095890\n-42.399975\n-0.641855\n-0.831372\n51.0\n0.369349\n0.136419\n0.909724\n-0.293571\n1.665465\n-1.665465\n39.197685\n0.735326\n0.768582\n51.0\n0.972865\n0.946467\n1.239833\n2.223790\n2.223790\n-0.900167\n-25.861439\n0.006240\n-0.507087\n51.0\n1.103717\n1.218190\n1.214631\n1.036380\n2.057254\n-2.057254\n-54.733055\n-0.955823\n-1.073197\n51.0\n0.341752\n0.116795\n1.126298\n-0.407128\n1.797132\n-1.797132\n-43.710899\n-0.780402\n-0.857076\n51.0\n0.244302\n0.059683\n0.891215\n-0.568018\n1.237588\n-1.237588\n-16.875654\n-0.136531\n-0.330895\n51.0\n0.380901\n0.145086\n0.504557\n0.301934\n0.825958\n-0.825958\n-12.057025\n-0.090500\n-0.236412\n51.0\n0.246839\n0.060929\n0.341790\n0.002809\n0.739954\n-0.739954\n43.413063\n0.779447\n0.851237\n51.0\n0.224609\n0.050449\n0.880371\n1.244718\n1.244718\n0.445537\n-16.459957\n-0.233873\n-0.322744\n51.0\n0.378000\n0.142884\n0.497039\n0.267569\n0.802695\n-0.802695\n-29.580076\n-0.443360\n-0.580002\n51.0\n0.283071\n0.080129\n0.645392\n-0.340970\n1.223840\n-1.223840\n-46.450630\n-0.899175\n-0.910797\n51.0\n0.711464\n0.506181\n1.155739\n0.568156\n1.918004\n-1.918004\n-25.124174\n-0.161948\n-0.492631\n51.0\n0.804141\n0.646643\n0.943042\n0.727019\n1.617498\n-1.617498\n-31.201376\n-0.434257\n-0.611792\n51.0\n0.313101\n0.098032\n0.687256\n-0.172693\n1.229459\n-1.229459\n41.937992\n0.793140\n0.822314\n51.0\n0.641221\n0.411164\n1.042767\n1.812513\n1.812513\n-0.339336\n-21.495180\n-0.052168\n-0.421474\n51.0\n0.799914\n0.639862\n0.904158\n0.620937\n1.550453\n-1.550453\n-42.943439\n-0.776023\n-0.842028\n51.0\n0.225123\n0.050680\n0.871603\n-0.285606\n1.344810\n-1.344810\n-52.034657\n-0.921795\n-1.020287\n51.0\n0.898630\n0.807537\n1.359604\n0.655126\n2.344413\n-2.344413\n-27.837105\n-0.061648\n-0.545826\n51.0\n0.969040\n0.939039\n1.112189\n0.931854\n1.992733\n-1.992733\n-36.875374\n-0.585629\n-0.723047\n51.0\n0.349626\n0.122238\n0.803141\n-0.215493\n1.429438\n-1.429438\n40.247742\n0.798090\n0.789171\n51.0\n0.786085\n0.617930\n1.113877\n1.984581\n1.984581\n-0.677269\n-23.811928\n-0.119661\n-0.466901\n51.0\n0.912458\n0.832579\n1.024976\n0.800261\n1.841989\n-1.841989\n-52.909077\n-1.040256\n-1.037433\n51.0\n0.335496\n0.112557\n1.090332\n-0.334281\n1.676773\n-1.676773\n4.0\n\n\n6\n-39.833595\n-0.581072\n-0.781051\n51.0\n0.909044\n0.826360\n1.198499\n0.568540\n2.283604\n-2.283604\n-38.821877\n-0.786507\n-0.761213\n51.0\n0.961909\n0.925269\n1.226668\n0.511668\n1.878216\n-1.878216\n-38.064991\n-0.843750\n-0.746372\n51.0\n0.289446\n0.083779\n0.800532\n-0.137036\n1.416119\n-1.416119\n41.832554\n0.615405\n0.820246\n51.0\n0.852135\n0.726135\n1.182767\n2.278694\n2.278694\n-0.571341\n-46.324547\n-0.797607\n-0.908324\n51.0\n0.966797\n0.934696\n1.326556\n0.542440\n2.116034\n-2.116034\n-20.751741\n-0.570023\n-0.406897\n51.0\n0.581464\n0.338100\n0.709694\n0.768066\n1.202626\n-1.202626\n-37.311344\n-0.603243\n-0.731595\n51.0\n0.236690\n0.056022\n0.768930\n-0.428848\n1.151210\n-1.151210\n-24.191328\n-0.593942\n-0.474340\n51.0\n0.321964\n0.103661\n0.573288\n0.118205\n0.778171\n-0.778171\n-10.869180\n-0.166239\n-0.213121\n51.0\n0.118523\n0.014048\n0.243861\n-0.055137\n0.518928\n-0.518928\n37.055542\n0.630720\n0.726579\n51.0\n0.187477\n0.035147\n0.750377\n1.041933\n1.041933\n0.511867\n-27.166332\n-0.715093\n-0.532673\n51.0\n0.297583\n0.088556\n0.610161\n0.032286\n0.820952\n-0.820952\n-5.845339\n-0.214925\n-0.114614\n51.0\n0.219578\n0.048215\n0.247691\n0.302756\n0.333025\n-0.333025\n-38.241142\n-0.594127\n-0.749826\n51.0\n0.627857\n0.394204\n0.977979\n0.256995\n1.747855\n-1.747855\n-32.509758\n-0.579769\n-0.637446\n51.0\n0.690723\n0.477098\n0.939913\n0.338581\n1.427238\n-1.427238\n-26.793001\n-0.502856\n-0.525353\n51.0\n0.140510\n0.019743\n0.543819\n-0.301202\n0.999421\n-0.999421\n38.700047\n0.607511\n0.758824\n51.0\n0.584079\n0.341148\n0.957582\n1.645291\n1.645291\n-0.209163\n-37.871262\n-0.758263\n-0.742574\n51.0\n0.648642\n0.420737\n0.985978\n0.297268\n1.478050\n-1.478050\n-15.965348\n-0.512104\n-0.313046\n51.0\n0.436921\n0.190900\n0.537492\n0.543558\n1.049285\n-1.049285\n-39.408485\n-0.581423\n-0.772715\n51.0\n0.801424\n0.642281\n1.113270\n0.497681\n2.193919\n-2.193919\n-36.982643\n-0.627740\n-0.725150\n51.0\n0.856815\n0.734132\n1.122486\n0.517904\n1.754343\n-1.754343\n-31.530857\n-0.578748\n-0.618252\n51.0\n0.279074\n0.077882\n0.678320\n-0.208244\n1.305216\n-1.305216\n37.909523\n0.533470\n0.743324\n51.0\n0.796210\n0.633951\n1.089257\n2.103847\n2.103847\n-0.552248\n-39.577774\n-0.742289\n-0.776035\n51.0\n0.849310\n0.721327\n1.150460\n0.575411\n1.851035\n-1.851035\n-22.426970\n-0.587765\n-0.439745\n51.0\n0.553202\n0.306033\n0.706688\n0.689770\n1.236947\n-1.236947\n5.0\n\n\n7\n-36.896690\n-0.912707\n-0.723464\n51.0\n1.064085\n1.132277\n1.286732\n0.912205\n2.307096\n-2.307096\n-19.239029\n-0.282667\n-0.377236\n51.0\n1.052407\n1.107561\n1.117975\n0.881856\n2.153838\n-2.153838\n-62.821152\n-1.281961\n-1.231787\n51.0\n0.530944\n0.281901\n1.341343\n0.098188\n2.117577\n-2.117577\n55.359245\n1.107040\n1.085475\n51.0\n0.981749\n0.963832\n1.463588\n2.348134\n2.348134\n-0.507044\n-23.611309\n0.024880\n-0.462967\n51.0\n1.022359\n1.045218\n1.122299\n0.884884\n2.283836\n-2.283836\n-34.417664\n-0.666021\n-0.674856\n51.0\n0.336352\n0.113133\n0.754031\n-0.017647\n1.378753\n-1.378753\n-38.069172\n-0.877256\n-0.746454\n51.0\n0.354419\n0.125613\n0.826321\n-0.077006\n1.163693\n-1.163693\n-10.263086\n-0.051315\n-0.201237\n51.0\n0.370457\n0.137238\n0.421586\n0.256480\n0.847701\n-0.847701\n-30.174412\n-0.570585\n-0.591655\n51.0\n0.173184\n0.029993\n0.616481\n-0.356980\n1.046295\n-1.046295\n46.865932\n0.877540\n0.918940\n51.0\n0.188330\n0.035468\n0.938040\n1.202289\n1.202289\n0.597824\n-24.255749\n-0.452062\n-0.475603\n51.0\n0.309431\n0.095748\n0.567403\n0.061571\n0.980127\n-0.980127\n-10.561463\n-0.084279\n-0.207088\n51.0\n0.266664\n0.071109\n0.337631\n0.100390\n0.787678\n-0.787678\n-35.248955\n-0.933832\n-0.691156\n51.0\n0.792044\n0.627334\n1.051204\n0.613102\n1.636708\n-1.636708\n-16.299442\n-0.262266\n-0.319597\n51.0\n0.805276\n0.648469\n0.866378\n0.682406\n1.797832\n-1.797832\n-50.258915\n-0.981771\n-0.985469\n51.0\n0.327322\n0.107139\n1.038407\n-0.382916\n1.556926\n-1.556926\n50.633633\n1.068598\n0.992816\n51.0\n0.669171\n0.447789\n1.197278\n1.868672\n1.868672\n-0.068966\n-22.703091\n-0.056605\n-0.445159\n51.0\n0.739652\n0.547084\n0.863279\n0.671985\n1.762866\n-1.762866\n-24.762434\n-0.469707\n-0.485538\n51.0\n0.268093\n0.071874\n0.554636\n-0.000126\n0.909962\n-0.909962\n-38.911346\n-0.915691\n-0.762968\n51.0\n0.941245\n0.885943\n1.211636\n0.747633\n2.031039\n-2.031039\n-19.286667\n-0.411864\n-0.378170\n51.0\n0.938402\n0.880599\n1.011737\n0.850090\n1.990998\n-1.990998\n-54.983307\n-1.106866\n-1.078104\n51.0\n0.498255\n0.248258\n1.187673\n-0.044980\n1.856607\n-1.856607\n55.272842\n1.142773\n1.083781\n51.0\n0.912429\n0.832527\n1.416725\n2.338898\n2.338898\n-0.387132\n-24.889832\n-0.118238\n-0.488036\n51.0\n0.872788\n0.761758\n0.999969\n0.686074\n2.103849\n-2.103849\n-32.013580\n-0.695968\n-0.627717\n51.0\n0.353181\n0.124737\n0.720254\n0.051580\n1.284638\n-1.284638\n4.0\n\n\n8\n-26.011322\n-0.536596\n-0.510026\n51.0\n0.055607\n0.003092\n0.513048\n-0.419569\n0.570454\n-0.570454\n-92.222801\n-1.791812\n-1.808290\n51.0\n0.098298\n0.009663\n1.810960\n-1.699334\n1.995639\n-1.995639\n-37.869225\n-0.712115\n-0.742534\n51.0\n0.048071\n0.002311\n0.744088\n-0.677641\n0.836827\n-0.836827\n64.245613\n1.286482\n1.259718\n51.0\n0.586856\n0.344400\n1.389708\n2.007180\n2.007180\n0.607638\n-38.855114\n-1.503779\n-0.761865\n51.0\n1.135116\n1.288489\n1.367087\n1.195478\n1.817826\n-1.817826\n-28.189720\n-0.513122\n-0.552740\n51.0\n0.103227\n0.010656\n0.562296\n-0.369479\n0.759343\n-0.759343\n-27.265202\n-0.548034\n-0.534612\n51.0\n0.022753\n0.000518\n0.535096\n-0.490623\n0.572237\n-0.572237\n-39.857010\n-0.771910\n-0.781510\n51.0\n0.061902\n0.003832\n0.783958\n-0.717654\n0.923757\n-0.923757\n-6.367034\n-0.115645\n-0.124844\n51.0\n0.060107\n0.003613\n0.138560\n-0.062456\n0.225210\n-0.225210\n42.372810\n0.886792\n0.830839\n51.0\n0.201009\n0.040405\n0.854809\n1.109116\n1.109116\n0.605396\n-13.769955\n-0.545444\n-0.269999\n51.0\n0.548812\n0.301195\n0.611632\n0.657959\n0.810047\n-0.810047\n-11.842787\n-0.255244\n-0.232212\n51.0\n0.044901\n0.002016\n0.236513\n-0.145291\n0.307812\n-0.307812\n-28.094807\n-0.559510\n-0.550879\n51.0\n0.043867\n0.001924\n0.552622\n-0.491768\n0.597890\n-0.597890\n-73.582306\n-1.460591\n-1.442790\n51.0\n0.122198\n0.014932\n1.447956\n-1.304898\n1.658409\n-1.658409\n-22.921581\n-0.463139\n-0.449443\n51.0\n0.052460\n0.002752\n0.452494\n-0.385089\n0.526610\n-0.526610\n56.109291\n1.201811\n1.100182\n51.0\n0.445087\n0.198103\n1.186804\n1.676672\n1.676672\n0.602798\n-29.902466\n-1.201119\n-0.586323\n51.0\n0.950869\n0.904151\n1.117106\n1.049786\n1.495527\n-1.495527\n-23.161522\n-0.453892\n-0.454147\n51.0\n0.071312\n0.005085\n0.459712\n-0.308134\n0.624632\n-0.624632\n-30.269337\n-0.606525\n-0.593516\n51.0\n0.053951\n0.002911\n0.595963\n-0.501898\n0.661645\n-0.661645\n-85.624870\n-1.647284\n-1.678919\n51.0\n0.107465\n0.011549\n1.682355\n-1.548876\n1.879864\n-1.879864\n-26.338734\n-0.505198\n-0.516446\n51.0\n0.055644\n0.003096\n0.519435\n-0.443595\n0.624974\n-0.624974\n63.065834\n1.133581\n1.236585\n51.0\n0.536658\n0.288002\n1.348015\n1.935572\n1.935572\n0.574532\n-40.009689\n-1.531141\n-0.784504\n51.0\n1.003145\n1.006301\n1.273478\n0.979440\n1.697684\n-1.697684\n-26.970509\n-0.520441\n-0.528834\n51.0\n0.084388\n0.007121\n0.535524\n-0.347588\n0.714076\n-0.714076\n3.0\n\n\n9\n-24.176491\n-0.488977\n-0.474049\n51.0\n0.043168\n0.001863\n0.476010\n-0.366197\n0.527277\n-0.527277\n-87.327805\n-1.710973\n-1.712310\n51.0\n0.031561\n0.000996\n1.712601\n-1.631805\n1.772976\n-1.772976\n-21.451313\n-0.408822\n-0.420614\n51.0\n0.032761\n0.001073\n0.421888\n-0.376194\n0.493162\n-0.493162\n58.397629\n0.748125\n1.145051\n51.0\n0.692690\n0.479820\n1.338269\n2.103378\n2.103378\n0.480623\n-48.922287\n-1.675132\n-0.959261\n51.0\n0.974441\n0.949535\n1.367375\n0.852968\n1.817363\n-1.817363\n-29.856304\n-0.640901\n-0.585418\n51.0\n0.124195\n0.015424\n0.598447\n-0.312080\n0.750260\n-0.750260\n-27.958775\n-0.565279\n-0.548211\n51.0\n0.035193\n0.001239\n0.549340\n-0.492060\n0.583746\n-0.583746\n-37.864830\n-0.732618\n-0.742448\n51.0\n0.041091\n0.001688\n0.743584\n-0.692059\n0.802448\n-0.802448\n-0.649227\n-0.005362\n-0.012730\n51.0\n0.039293\n0.001544\n0.041304\n0.035067\n0.069732\n-0.069732\n43.424145\n0.733217\n0.851454\n51.0\n0.218725\n0.047841\n0.879099\n1.171012\n1.171012\n0.632703\n-21.846182\n-0.721695\n-0.428356\n51.0\n0.389760\n0.151912\n0.579139\n0.287935\n0.756129\n-0.756129\n-13.696244\n-0.290477\n-0.268554\n51.0\n0.049435\n0.002444\n0.273066\n-0.169651\n0.314362\n-0.314362\n-28.335342\n-0.570419\n-0.555595\n51.0\n0.031328\n0.000981\n0.556478\n-0.508227\n0.598616\n-0.598616\n-67.415817\n-1.322900\n-1.321879\n51.0\n0.020617\n0.000425\n1.322040\n-1.252832\n1.356348\n-1.356348\n-14.509363\n-0.280158\n-0.284497\n51.0\n0.027159\n0.000738\n0.285791\n-0.237379\n0.326241\n-0.326241\n54.223145\n0.808409\n1.063199\n51.0\n0.487772\n0.237921\n1.169749\n1.747880\n1.747880\n0.582484\n-38.194836\n-1.286616\n-0.748918\n51.0\n0.720042\n0.518461\n1.038913\n0.589410\n1.341641\n-1.341641\n-24.306427\n-0.513999\n-0.476597\n51.0\n0.113742\n0.012937\n0.489981\n-0.236320\n0.606179\n-0.606179\n-20.204275\n-0.414832\n-0.396162\n51.0\n0.036496\n0.001332\n0.397840\n-0.328904\n0.434622\n-0.434622\n-71.983742\n-1.408678\n-1.411446\n51.0\n0.031827\n0.001013\n1.411805\n-1.346405\n1.477625\n-1.477625\n-23.991568\n-0.466880\n-0.470423\n51.0\n0.027061\n0.000732\n0.471201\n-0.430881\n0.532167\n-0.532167\n53.270744\n0.767735\n1.044524\n51.0\n0.671843\n0.451373\n1.241936\n2.002148\n2.002148\n0.376754\n-38.753330\n-1.399783\n-0.759869\n51.0\n0.882002\n0.777927\n1.164186\n0.885538\n1.513484\n-1.513484\n-31.401262\n-0.670306\n-0.615711\n51.0\n0.152118\n0.023140\n0.634224\n-0.286498\n0.862852\n-0.862852\n2.0\n\n\n\n\n\n\nx_cat, x_cont, yb = first(dls.train)\nx_cont[:10]\n\ntensor([[-0.8581, -0.1346, -0.8581,  ...,  0.3235,  0.5841, -0.6917],\n        [-0.0406,  0.0344, -0.0406,  ..., -0.0171, -1.7253,  1.2745],\n        [ 1.7966, -0.0497,  1.7966,  ..., -0.6516,  0.9802, -1.0290],\n        ...,\n        [ 0.2804,  0.4747,  0.2804,  ..., -0.4816, -0.3325,  0.0887],\n        [-0.1472, -0.1884, -0.1472,  ..., -0.1036, -1.2258,  0.8491],\n        [-0.9960, -0.6116, -0.9960,  ...,  0.4602,  3.3105, -3.0129]])",
    "crumbs": [
      "Data",
      "Featurizing Time Series"
    ]
  },
  {
    "objectID": "models.fcnplus.html",
    "href": "models.fcnplus.html",
    "title": "FCNPlus",
    "section": "",
    "text": "This is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\n\nsource\n\nFCNPlus\n\n FCNPlus (c_in, c_out, layers=[128, 256, 128], kss=[7, 5, 3], coord=False,\n          separable=False, use_bn=False, fc_dropout=0.0, zero_norm=False,\n          act=&lt;class 'torch.nn.modules.activation.ReLU'&gt;, act_kwargs={},\n          residual=False, custom_head=None)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nxb = torch.rand(16, 3, 10)\ntest_eq(FCNPlus(3, 2)(xb).shape, [xb.shape[0], 2])\ntest_eq(FCNPlus(3, 2, coord=True, separable=True, act=Swish, residual=True)(xb).shape, [xb.shape[0], 2])\ntest_eq(nn.Sequential(*FCNPlus(3, 2).children())(xb).shape, [xb.shape[0], 2])\ntest_eq(FCNPlus(3, 2, custom_head=partial(mlp_head, seq_len=10))(xb).shape, [xb.shape[0], 2])\n\n\nfrom tsai.models.utils import *\n\n\nmodel = build_ts_model(FCNPlus, 2, 3)\nmodel[-1]\n\nSequential(\n  (0): AdaptiveAvgPool1d(output_size=1)\n  (1): Squeeze(dim=-1)\n  (2): Linear(in_features=128, out_features=3, bias=True)\n)\n\n\n\nfrom tsai.models.FCN import *\n\n\ntest_eq(count_parameters(FCN(3,2)), count_parameters(FCNPlus(3,2)))\n\n\nFCNPlus(3,2)\n\nFCNPlus(\n  (backbone): _FCNBlockPlus(\n    (convblock1): ConvBlock(\n      (0): Conv1d(3, 128, kernel_size=(7,), stride=(1,), padding=(3,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock2): ConvBlock(\n      (0): Conv1d(128, 256, kernel_size=(5,), stride=(1,), padding=(2,), bias=False)\n      (1): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (convblock3): ConvBlock(\n      (0): Conv1d(256, 128, kernel_size=(3,), stride=(1,), padding=(1,), bias=False)\n      (1): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): ReLU()\n    )\n    (add): Sequential()\n  )\n  (head): Sequential(\n    (0): AdaptiveAvgPool1d(output_size=1)\n    (1): Squeeze(dim=-1)\n    (2): Linear(in_features=128, out_features=2, bias=True)\n  )\n)",
    "crumbs": [
      "Models",
      "CNNs",
      "FCNPlus"
    ]
  },
  {
    "objectID": "models.misc.html",
    "href": "models.misc.html",
    "title": "Miscellaneous",
    "section": "",
    "text": "This contains a set of experiments.\n\n\nsource\n\nInputWrapper\n\n InputWrapper (arch, c_in, c_out, seq_len, new_c_in=None,\n               new_seq_len=None, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.models.TST import *\n\n\nxb = torch.randn(16, 1, 1000)\nmodel = InputWrapper(TST, 1, 4, 1000, 10, 224)\ntest_eq(model.to(xb.device)(xb).shape, (16,4))\n\n\nsource\n\n\nResidualWrapper\n\n ResidualWrapper (model)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nRecursiveWrapper\n\n RecursiveWrapper (model, n_steps, anchored=False)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nxb = torch.randn(16, 1, 20)\nmodel = RecursiveWrapper(TST(1, 1, 20), 5)\ntest_eq(model.to(xb.device)(xb).shape, (16, 5))",
    "crumbs": [
      "Models",
      "Miscellaneous",
      "Miscellaneous"
    ]
  },
  {
    "objectID": "models.rnnattentionplus.html",
    "href": "models.rnnattentionplus.html",
    "title": "RNNAttentionPlus",
    "section": "",
    "text": "This is an custom PyTorch implementation by @yangtzech, based on TST implementation of Ignacio Oguiza."
  },
  {
    "objectID": "models.rnnattentionplus.html#arguments",
    "href": "models.rnnattentionplus.html#arguments",
    "title": "RNNAttentionPlus",
    "section": "Arguments",
    "text": "Arguments\nUsual values are the ones that appear in the “Attention is all you need” and “A Transformer-based Framework for Multivariate Time Series Representation Learning” papers. And some parameters are necessary for the RNN part.\nThe default values are the ones selected as a default configuration in the latter.\n\nc_in: the number of features (aka variables, dimensions, channels) in the time series dataset. dls.var\nc_out: the number of target classes. dls.c\nseq_len: number of time steps in the time series. dls.len\nhidden_size: the number of features in the hidden state in the RNN model. Default: 128.\nrnn_layers: the number of recurrent layers of the RNN model. Default: 1.\nbias: If False, then the layer does not use bias weights b_ih and b_hh. Default: True\nrnn_dropout: If non-zero, introduces a Dropout layer on the outputs of each RNN layer except the last layer, with dropout probability equal to :attr:rnn_dropout. Default: 0\nbidirectional: If True, becomes a bidirectional RNN. Default: False\nn_heads: parallel attention heads. Usual values: 8-16. Default: 16.\nd_k: size of the learned linear projection of queries and keys in the MHA. Usual values: 16-512. Default: None -&gt; (d_model/n_heads) = 32.\nd_v: size of the learned linear projection of values in the MHA. Usual values: 16-512. Default: None -&gt; (d_model/n_heads) = 32.\nd_ff: the dimension of the feedforward network model. Usual values: 256-4096. Default: 256.\nencoder_dropout: amount of residual dropout applied in the encoder. Usual values: 0.-0.3. Default: 0.1.\nact: the activation function of intermediate layer, relu or gelu. Default: ‘gelu’.\nencoder_layers: the number of sub-encoder-layers in the encoder. Usual values: 2-8. Default: 3.\nfc_dropout: dropout applied to the final fully connected layer. Usual values: 0.-0.8. Default: 0.\ny_range: range of possible y values (used in regression tasks). Default: None"
  },
  {
    "objectID": "models.rnnattentionplus.html#imports",
    "href": "models.rnnattentionplus.html#imports",
    "title": "RNNAttentionPlus",
    "section": "Imports",
    "text": "Imports"
  },
  {
    "objectID": "models.rnnattentionplus.html#rnnattentionplus",
    "href": "models.rnnattentionplus.html#rnnattentionplus",
    "title": "RNNAttentionPlus",
    "section": "RNNAttentionPlus",
    "text": "RNNAttentionPlus\n\nt = torch.rand(16, 50, 128)\noutput, attn = _MultiHeadAttention(d_model=128, n_heads=3, d_k=8, d_v=6)(t, t, t)\noutput.shape, attn.shape\n\n(torch.Size([16, 50, 128]), torch.Size([16, 3, 50, 50]))\n\n\n\nt = torch.rand(16, 50, 128)\noutput = _TSTEncoderLayer(q_len=50, d_model=128, n_heads=3, d_k=None, d_v=None, d_ff=512, dropout=0.1, activation='gelu')(t)\noutput.shape\n\ntorch.Size([16, 50, 128])\n\n\n\nsource\n\nGRUAttentionPlus\n\n GRUAttentionPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                   hidden_size:int=128, rnn_layers:int=1, bias:bool=True,\n                   rnn_dropout:float=0, bidirectional=False,\n                   encoder_layers:int=3, n_heads:int=16,\n                   d_k:Optional[int]=None, d_v:Optional[int]=None,\n                   d_ff:int=256, encoder_dropout:float=0.1,\n                   act:str='gelu', fc_dropout:float=0.0,\n                   y_range:Optional[tuple]=None, custom_head=None,\n                   use_bn:bool=True, flatten:bool=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nthe number of features (aka variables, dimensions, channels) in the time series dataset.\n\n\nc_out\nint\n\nthe number of target classes.\n\n\nseq_len\nint\n\nnumber of time steps in the time series.\n\n\nd\ntuple\nNone\noutput shape (excluding batch dimension).\n\n\nhidden_size\nint\n128\nthe number of features in the hidden state h\n\n\nrnn_layers\nint\n1\nthe number of recurrent layers of the RNN model.\n\n\nbias\nbool\nTrue\nIf False, then the layer does not use bias weights b_ih and b_hh.\n\n\nrnn_dropout\nfloat\n0\nrnn dropout applied to the output of each RNN layer except the last layer.\n\n\nbidirectional\nbool\nFalse\nIf True, becomes a bidirectional RNN. Default: False\n\n\nencoder_layers\nint\n3\nthe number of sub-encoder-layers in the encoder.\n\n\nn_heads\nint\n16\nparallel attention heads.\n\n\nd_k\nOptional\nNone\nsize of the learned linear projection of queries and keys in the MHA.\n\n\nd_v\nOptional\nNone\nsize of the learned linear projection of values in the MHA.\n\n\nd_ff\nint\n256\nthe dimension of the feedforward network model.\n\n\nencoder_dropout\nfloat\n0.1\namount of residual dropout applied in the encoder.\n\n\nact\nstr\ngelu\nthe activation function of intermediate layer, relu or gelu.\n\n\nfc_dropout\nfloat\n0.0\ndropout applied to the final fully connected layer.\n\n\ny_range\nOptional\nNone\nrange of possible y values (used in regression tasks).\n\n\ncustom_head\nNoneType\nNone\ncustom head that will be applied to the model head (optional).\n\n\nuse_bn\nbool\nTrue\nindicates if batchnorm will be applied to the model head.\n\n\nflatten\nbool\nTrue\nthis will flatten the output of the encoder before applying the head if True.\n\n\n\n\nsource\n\n\nLSTMAttentionPlus\n\n LSTMAttentionPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                    hidden_size:int=128, rnn_layers:int=1, bias:bool=True,\n                    rnn_dropout:float=0, bidirectional=False,\n                    encoder_layers:int=3, n_heads:int=16,\n                    d_k:Optional[int]=None, d_v:Optional[int]=None,\n                    d_ff:int=256, encoder_dropout:float=0.1,\n                    act:str='gelu', fc_dropout:float=0.0,\n                    y_range:Optional[tuple]=None, custom_head=None,\n                    use_bn:bool=True, flatten:bool=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nthe number of features (aka variables, dimensions, channels) in the time series dataset.\n\n\nc_out\nint\n\nthe number of target classes.\n\n\nseq_len\nint\n\nnumber of time steps in the time series.\n\n\nd\ntuple\nNone\noutput shape (excluding batch dimension).\n\n\nhidden_size\nint\n128\nthe number of features in the hidden state h\n\n\nrnn_layers\nint\n1\nthe number of recurrent layers of the RNN model.\n\n\nbias\nbool\nTrue\nIf False, then the layer does not use bias weights b_ih and b_hh.\n\n\nrnn_dropout\nfloat\n0\nrnn dropout applied to the output of each RNN layer except the last layer.\n\n\nbidirectional\nbool\nFalse\nIf True, becomes a bidirectional RNN. Default: False\n\n\nencoder_layers\nint\n3\nthe number of sub-encoder-layers in the encoder.\n\n\nn_heads\nint\n16\nparallel attention heads.\n\n\nd_k\nOptional\nNone\nsize of the learned linear projection of queries and keys in the MHA.\n\n\nd_v\nOptional\nNone\nsize of the learned linear projection of values in the MHA.\n\n\nd_ff\nint\n256\nthe dimension of the feedforward network model.\n\n\nencoder_dropout\nfloat\n0.1\namount of residual dropout applied in the encoder.\n\n\nact\nstr\ngelu\nthe activation function of intermediate layer, relu or gelu.\n\n\nfc_dropout\nfloat\n0.0\ndropout applied to the final fully connected layer.\n\n\ny_range\nOptional\nNone\nrange of possible y values (used in regression tasks).\n\n\ncustom_head\nNoneType\nNone\ncustom head that will be applied to the model head (optional).\n\n\nuse_bn\nbool\nTrue\nindicates if batchnorm will be applied to the model head.\n\n\nflatten\nbool\nTrue\nthis will flatten the output of the encoder before applying the head if True.\n\n\n\n\nsource\n\n\nRNNAttentionPlus\n\n RNNAttentionPlus (c_in:int, c_out:int, seq_len:int, d:tuple=None,\n                   hidden_size:int=128, rnn_layers:int=1, bias:bool=True,\n                   rnn_dropout:float=0, bidirectional=False,\n                   encoder_layers:int=3, n_heads:int=16,\n                   d_k:Optional[int]=None, d_v:Optional[int]=None,\n                   d_ff:int=256, encoder_dropout:float=0.1,\n                   act:str='gelu', fc_dropout:float=0.0,\n                   y_range:Optional[tuple]=None, custom_head=None,\n                   use_bn:bool=True, flatten:bool=True)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nc_in\nint\n\nthe number of features (aka variables, dimensions, channels) in the time series dataset.\n\n\nc_out\nint\n\nthe number of target classes.\n\n\nseq_len\nint\n\nnumber of time steps in the time series.\n\n\nd\ntuple\nNone\noutput shape (excluding batch dimension).\n\n\nhidden_size\nint\n128\nthe number of features in the hidden state h\n\n\nrnn_layers\nint\n1\nthe number of recurrent layers of the RNN model.\n\n\nbias\nbool\nTrue\nIf False, then the layer does not use bias weights b_ih and b_hh.\n\n\nrnn_dropout\nfloat\n0\nrnn dropout applied to the output of each RNN layer except the last layer.\n\n\nbidirectional\nbool\nFalse\nIf True, becomes a bidirectional RNN. Default: False\n\n\nencoder_layers\nint\n3\nthe number of sub-encoder-layers in the encoder.\n\n\nn_heads\nint\n16\nparallel attention heads.\n\n\nd_k\nOptional\nNone\nsize of the learned linear projection of queries and keys in the MHA.\n\n\nd_v\nOptional\nNone\nsize of the learned linear projection of values in the MHA.\n\n\nd_ff\nint\n256\nthe dimension of the feedforward network model.\n\n\nencoder_dropout\nfloat\n0.1\namount of residual dropout applied in the encoder.\n\n\nact\nstr\ngelu\nthe activation function of intermediate layer, relu or gelu.\n\n\nfc_dropout\nfloat\n0.0\ndropout applied to the final fully connected layer.\n\n\ny_range\nOptional\nNone\nrange of possible y values (used in regression tasks).\n\n\ncustom_head\nNoneType\nNone\ncustom head that will be applied to the model head (optional).\n\n\nuse_bn\nbool\nTrue\nindicates if batchnorm will be applied to the model head.\n\n\nflatten\nbool\nTrue\nthis will flatten the output of the encoder before applying the head if True.\n\n\n\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 500\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nhidden_size = 128\nrnn_layers=1\nbias=True\nrnn_dropout=0\nbidirectional=False\nencoder_layers=3\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\nencoder_dropout = 0.1\nact = \"gelu\"\nfc_dropout = 0.1\nkwargs = {}\n\nmodel = RNNAttentionPlus(c_in, c_out, seq_len, hidden_size=hidden_size, rnn_layers=rnn_layers, bias=bias, rnn_dropout=rnn_dropout, bidirectional=bidirectional,\n            encoder_layers=encoder_layers, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, encoder_dropout=encoder_dropout, act=act, \n            fc_dropout=fc_dropout, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 541698\n\n\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 60\n\nxb = torch.randn(bs, c_in, seq_len)\n\n# standardize by channel by_var based on the training set\nxb = (xb - xb.mean((0, 2), keepdim=True)) / xb.std((0, 2), keepdim=True)\n\n# Settings\nhidden_size = 128\nrnn_layers=1\nbias=True\nrnn_dropout=0\nbidirectional=False\nencoder_layers=3\nn_heads = 16\nd_k = d_v = None # if None --&gt; d_model // n_heads\nd_ff = 256\nencoder_dropout = 0.1\nact = \"gelu\"\nfc_dropout = 0.1\nkwargs = {}\n# kwargs = dict(kernel_size=5, padding=2)\n\nmodel = RNNAttentionPlus(c_in, c_out, seq_len, hidden_size=hidden_size, rnn_layers=rnn_layers, bias=bias, rnn_dropout=rnn_dropout, bidirectional=bidirectional,\n            encoder_layers=encoder_layers, n_heads=n_heads,\n            d_k=d_k, d_v=d_v, d_ff=d_ff, encoder_dropout=encoder_dropout, act=act, \n            fc_dropout=fc_dropout, **kwargs)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 429058\n\n\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 60\nd = 10\n\nxb = torch.randn(bs, c_in, seq_len)\nmodel = RNNAttentionPlus(c_in, c_out, seq_len, d=d)\ntest_eq(model.to(xb.device)(xb).shape, [bs, d, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 567572\n\n\n\nbs = 32\nc_in = 9  # aka channels, features, variables, dimensions\nc_out = 2\nseq_len = 60\nd = (3, 10)\n\nxb = torch.randn(bs, c_in, seq_len)\nmodel = RNNAttentionPlus(c_in, c_out, seq_len, d=d)\ntest_eq(model.to(xb.device)(xb).shape, [bs, *d, c_out])\nprint(f'model parameters: {count_parameters(model)}')\n\nmodel parameters: 874812"
  },
  {
    "objectID": "models.explainability.html",
    "href": "models.explainability.html",
    "title": "Explainability",
    "section": "",
    "text": "Functionality to help with both global and local explainability.\n\n\nsource\n\nget_attribution_map\n\n get_attribution_map (model, modules, x, y=None, detach=True, cpu=False,\n                      apply_relu=True)\n\n\nsource\n\n\nget_acts_and_grads\n\n get_acts_and_grads (model, modules, x, y=None, detach=True, cpu=False)\n\nReturns activations and gradients for given modules in a model and a single input or a batch. Gradients require y value(s). If they are not provided, it will use the predictions.",
    "crumbs": [
      "Explainability"
    ]
  },
  {
    "objectID": "models.mwdn.html",
    "href": "models.mwdn.html",
    "title": "mWDN",
    "section": "",
    "text": "multilevel Wavelet Decomposition Network (mWDN)\n\nThis is an unofficial PyTorch implementation created by Ignacio Oguiza - oguiza@timeseriesAI.co\n\nsource\n\nWaveBlock\n\n WaveBlock (c_in, c_out, seq_len, wavelet=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nmWDNPlus\n\n mWDNPlus (c_in, c_out, seq_len, d=None, levels=3, wavelet=None,\n           base_model=None, base_arch=&lt;class\n           'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, **kwargs)\n\n*A sequential container.\nModules will be added to it in the order they are passed in the constructor. Alternatively, an OrderedDict of modules can be passed in. The forward() method of [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) accepts any input and forwards it to the first module it contains. It then “chains” outputs to inputs sequentially for each subsequent module, finally returning the output of the last module.\nThe value a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) provides over manually calling a sequence of modules is that it allows treating the whole container as a single module, such that performing a transformation on the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) applies to each of the modules it stores (which are each a registered submodule of the [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential)).\nWhat’s the difference between a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) and a :class:torch.nn.ModuleList? A ModuleList is exactly what it sounds like–a list for storing Module s! On the other hand, the layers in a [Sequential](https://timeseriesAI.github.io/models.tabfusiontransformer.html#sequential) are connected in a cascading way.\nExample::\n# Using Sequential to create a small model. When `model` is run,\n# input will first be passed to `Conv2d(1,20,5)`. The output of\n# `Conv2d(1,20,5)` will be used as the input to the first\n# `ReLU`; the output of the first `ReLU` will become the input\n# for `Conv2d(20,64,5)`. Finally, the output of\n# `Conv2d(20,64,5)` will be used as input to the second `ReLU`\nmodel = nn.Sequential(\n          nn.Conv2d(1,20,5),\n          nn.ReLU(),\n          nn.Conv2d(20,64,5),\n          nn.ReLU()\n        )\n\n# Using Sequential with OrderedDict. This is functionally the\n# same as the above code\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))*\n\nsource\n\n\nmWDNBlocks\n\n mWDNBlocks (c_in, c_out, seq_len, levels=3, wavelet=None)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nsource\n\n\nmWDN\n\n mWDN (c_in, c_out, seq_len, levels=3, wavelet=None, base_arch=&lt;class\n       'tsai.models.InceptionTimePlus.InceptionTimePlus'&gt;, **kwargs)\n\nSame as nn.Module, but no need for subclasses to call super().__init__\n\nfrom tsai.models.TSTPlus import TSTPlus\n\n\nbs = 16\nc_in = 3\nseq_len = 12\nc_out = 2\nxb = torch.rand(bs, c_in, seq_len).to(default_device())\ntest_eq(mWDN(c_in, c_out, seq_len).to(xb.device)(xb).shape, [bs, c_out])\nmodel = mWDNPlus(c_in, c_out, seq_len, fc_dropout=.5)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\nmodel = mWDNPlus(c_in, c_out, seq_len, base_arch=TSTPlus, fc_dropout=.5)\ntest_eq(model.to(xb.device)(xb).shape, [bs, c_out])\n\n\nmodel.head, model.head_nf\n\n(Sequential(\n   (0): GELU(approximate='none')\n   (1): fastai.layers.Flatten(full=False)\n   (2): LinBnDrop(\n     (0): Dropout(p=0.5, inplace=False)\n     (1): Linear(in_features=1536, out_features=2, bias=True)\n   )\n ),\n 128)\n\n\n\nbs = 16\nc_in = 3\nseq_len = 12\nd = 10\nc_out = 2\nxb = torch.rand(bs, c_in, seq_len).to(default_device())\nmodel = mWDNPlus(c_in, c_out, seq_len, d=d)\ntest_eq(model.to(xb.device)(xb).shape, [bs, d, c_out])\n\n\nbs = 16\nc_in = 3\nseq_len = 12\nd = (5, 2)\nc_out = 2\nxb = torch.rand(bs, c_in, seq_len).to(default_device())\nmodel = mWDNPlus(c_in, c_out, seq_len, d=d)\ntest_eq(model.to(xb.device)(xb).shape, [bs, *d, c_out])",
    "crumbs": [
      "Models",
      "Wavelet-based NNs",
      "mWDN"
    ]
  },
  {
    "objectID": "data.image.html",
    "href": "data.image.html",
    "title": "Imaging Time Series",
    "section": "",
    "text": "Main functions used to transform time series into TSImage tensors.\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\n\n\nsource\n\nToTSImage\n\n ToTSImage (enc=None, dec=None, split_idx=None, order=None)\n\nDelegates (__call__,decode,setup) to (encodes,decodes,setups) if split_idx matches\n\nsource\n\n\nTSImage\n\n TSImage (x, **kwargs)\n\nA Tensor which support subclass pickling, and maintains metadata when casting or after methods\n\nsource\n\n\nTSToPlot\n\n TSToPlot (size:Optional[int]=224, dpi:int=100, lw=1, **kwargs)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by creating a matplotlib plot.\n\nout = TSToPlot()(TSTensor(X[:2]), split_idx=0)\nprint(out.shape)\nout[0].show()\n\ntorch.Size([2, 3, 224, 224])\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nTSToMat\n\n TSToMat (size=224, dpi=100, cmap=None, **kwargs)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by creating a matplotlib matrix. Input data must be normalized with a range(-1, 1)\n\nout = TSToMat()(TSTensor(X[:2]), split_idx=0)\nprint(out.shape)\nout[0].show()\n\ntorch.Size([2, 3, 224, 224])\n\n\n\n\n\n\n\n\n\n\nout = TSToMat(cmap='spring')(TSTensor(X[:2]), split_idx=0)\nprint(out.shape)\nout[0].show()\n\ntorch.Size([2, 3, 224, 224])\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nTSToJRP\n\n TSToJRP (size=224, cmap=None, dimension=1, time_delay=1, threshold=None,\n          percentage=10)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by applying Joint Recurrence Plot\n\nsource\n\n\nTSToRP\n\n TSToRP (size=224, cmap=None, dimension=1, time_delay=1, threshold=None,\n         percentage=10, flatten=False)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by applying Recurrence Plot. It requires input to be previously normalized between -1 and 1\n\nsource\n\n\nTSToMTF\n\n TSToMTF (size=224, cmap=None, n_bins=5, image_size=1.0,\n          strategy='quantile', overlapping=False, flatten=False)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by applying Markov Transition Field\n\nsource\n\n\nTSToGASF\n\n TSToGASF (size=224, cmap=None, range=None, image_size=1.0,\n           sample_range=(-1, 1), method='summation', overlapping=False,\n           flatten=False)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by applying Gramian Angular Summation Field. It requires either input to be previously normalized between -1 and 1 or set range to (-1, 1)\n\nsource\n\n\nTSToGADF\n\n TSToGADF (size=224, cmap=None, range=None, image_size=1.0,\n           sample_range=(-1, 1), method='summation', overlapping=False,\n           flatten=False)\n\nTransforms a time series batch to a 4d TSImage (bs, n_vars, size, size) by applying Gramian Angular Difference Field. It requires either input to be previously normalized between -1 and 1 or set range to (-1, 1)\n\nout = TSToRP()(TSTensor(X[:2]), split_idx=0)\nprint(out.shape)\nout[0].show()\n\ntorch.Size([2, 24, 224, 224])\n\n\n\n\n\n\n\n\n\n\no = TSTensor(X[0][1][None])\nencoder = RecurrencePlot()\na = encoder.fit_transform(o.cpu().numpy())[0]\no = TSTensor(X[0])\nencoder = RecurrencePlot()\nb = encoder.fit_transform(o.cpu().numpy())[1]\ntest_eq(a,b) # channels can all be processed in parallel\n\n\ntest_eq(TSToRP()(TSTensor(X[0]), split_idx=False)[0], TSToRP()(TSTensor(X[0][0][None]), split_idx=False)[0])\ntest_eq(TSToRP()(TSTensor(X[0]), split_idx=False)[1], TSToRP()(TSTensor(X[0][1][None]), split_idx=False)[0])\ntest_eq(TSToRP()(TSTensor(X[0]), split_idx=False)[2], TSToRP()(TSTensor(X[0][2][None]), split_idx=False)[0])\n\n\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\ntfms = [None, Categorize()]\nbts = [[TSNormalize(), TSToPlot(100)],\n       [TSNormalize(), TSToMat(100)],\n       [TSNormalize(), TSToGADF(100)],\n       [TSNormalize(), TSToGASF(100)],\n       [TSNormalize(), TSToMTF(100)],\n       [TSNormalize(), TSToRP(100)]]\nbtns = ['Plot', 'Mat', 'GADF', 'GASF', 'MTF', 'RP']\ndsets = TSDatasets(X, y, tfms=tfms, splits=splits)\nfor i, (bt, btn) in enumerate(zip(bts, btns)):\n    dls = TSDataLoaders.from_dsets(dsets.train, dsets.valid, bs=8, batch_tfms=bt)\n    test_eq(dls.vars, 3 if i &lt;2 else X.shape[1])\n    test_eq(dls.vars, 3 if i &lt;2 else X.shape[1])\n    test_eq(dls.len, (100,100))\n    xb, yb = dls.train.one_batch()\n    print(i, btn, xb, xb.dtype, xb.min(), xb.max())\n    xb[0].show()\n    plt.show()\n\n0 Plot TSImage(shape:torch.Size([8, 3, 100, 100])) torch.float32 0.054901961237192154 1.0\n\n\n\n\n\n\n\n\n\n1 Mat TSImage(shape:torch.Size([8, 3, 100, 100])) torch.float32 0.019607843831181526 1.0\n\n\n\n\n\n\n\n\n\n2 GADF TSImage(shape:torch.Size([8, 24, 100, 100])) torch.float32 2.980232238769531e-07 0.9999997019767761\n\n\n\n\n\n\n\n\n\n3 GASF TSImage(shape:torch.Size([8, 24, 100, 100])) torch.float32 0.0 0.938302218914032\n\n\n\n\n\n\n\n\n\n4 MTF TSImage(shape:torch.Size([8, 24, 100, 100])) torch.float32 0.0 1.0\n\n\n\n\n\n\n\n\n\n5 RP TSImage(shape:torch.Size([8, 24, 100, 100])) torch.float32 0.0 0.8106333613395691\n\n\n\n\n\n\n\n\n\nThe simplest way to train a model using time series to image transforms is this:\ndsid = 'NATOPS'\nX, y, splits = get_UCR_data(dsid, return_split=False)\ntfms = [None, Categorize()]\nbatch_tfms = [TSNormalize(), TSToGADF(224)]\ndls = get_ts_dls(X, y, splits=splits, tfms=tfms, batch_tfms=batch_tfms)\nlearn = tsimage_learner(dls, xresnet34)\nlearn.fit_one_cycle(10)",
    "crumbs": [
      "Data",
      "Imaging Time Series"
    ]
  },
  {
    "objectID": "models.utils.html",
    "href": "models.utils.html",
    "title": "Model utilities",
    "section": "",
    "text": "Utility functions used to build PyTorch timeseries models.\n\n\nsource\n\napply_idxs\n\n apply_idxs (o, idxs)\n\nFunction to apply indices to zarr, dask and numpy arrays\n\nsource\n\n\nSeqTokenizer\n\n SeqTokenizer (c_in, embed_dim, token_size=60, norm=False)\n\nGenerates non-overlapping tokens from sub-sequences within a sequence by applying a sliding window\n\nsource\n\n\nget_embed_size\n\n get_embed_size (n_cat, rule='log2')\n\n\ntest_eq(get_embed_size(35), 6)\n\n\nsource\n\n\nhas_weight_or_bias\n\n has_weight_or_bias (l)\n\n\nsource\n\n\nhas_weight\n\n has_weight (l)\n\n\nsource\n\n\nhas_bias\n\n has_bias (l)\n\n\nsource\n\n\nis_conv\n\n is_conv (l)\n\n\nsource\n\n\nis_affine_layer\n\n is_affine_layer (l)\n\n\nsource\n\n\nis_conv_linear\n\n is_conv_linear (l)\n\n\nsource\n\n\nis_bn\n\n is_bn (l)\n\n\nsource\n\n\nis_linear\n\n is_linear (l)\n\n\nsource\n\n\nis_layer\n\n is_layer (*args)\n\n\nsource\n\n\nget_layers\n\n get_layers (model, cond=&lt;function noop&gt;, full=True)\n\n\nsource\n\n\ncheck_weight\n\n check_weight (m, cond=&lt;function noop&gt;, verbose=False)\n\n\nsource\n\n\ncheck_bias\n\n check_bias (m, cond=&lt;function noop&gt;, verbose=False)\n\n\nsource\n\n\nget_nf\n\n get_nf (m)\n\nGet nf from model’s first linear layer in head\n\nsource\n\n\nts_splitter\n\n ts_splitter (m)\n\nSplit of a model between body and head\n\nsource\n\n\ntransfer_weights\n\n transfer_weights (model, weights_path:pathlib.Path,\n                   device:torch.device=None, exclude_head:bool=True)\n\nUtility function that allows to easily transfer weights between models. Taken from the great self-supervised repository created by Kerem Turgutlu. https://github.com/KeremTurgutlu/self_supervised/blob/d87ebd9b4961c7da0efd6073c42782bbc61aaa2e/self_supervised/utils.py\n\nsource\n\n\nbuild_ts_model\n\n build_ts_model (arch, c_in=None, c_out=None, seq_len=None, d=None,\n                 dls=None, device=None, verbose=False, s_cat_idxs=None,\n                 s_cat_embeddings=None, s_cat_embedding_dims=None,\n                 s_cont_idxs=None, o_cat_idxs=None, o_cat_embeddings=None,\n                 o_cat_embedding_dims=None, o_cont_idxs=None,\n                 patch_len=None, patch_stride=None, fusion_layers=128,\n                 fusion_act='relu', fusion_dropout=0.0,\n                 fusion_use_bn=True, pretrained=False, weights_path=None,\n                 exclude_head=True, cut=-1, init=None, arch_config={},\n                 **kwargs)\n\n\nfrom tsai.data.core import get_ts_dls, TSClassification\nfrom tsai.models.TSiTPlus import TSiTPlus\nfrom fastai.losses import CrossEntropyLossFlat\n\n\nX = np.random.rand(16, 3, 128)\ny = np.random.randint(0, 2, (16, 3))\ntfms = [None, [TSClassification()]]\ndls = get_ts_dls(X, y, splits=RandomSplitter()(range_of(X)), tfms=tfms)\nmodel = build_ts_model(TSiTPlus, dls=dls, pretrained=False, verbose=True)\nxb, yb = dls.one_batch()\noutput = model(xb)\nprint(output.shape)\nloss = CrossEntropyLossFlat()(output, yb)\nprint(loss)\nassert output.shape == (dls.bs, dls.d, dls.c)\n\narch: TSiTPlus(c_in=3 c_out=2 seq_len=128 arch_config={} kwargs={'custom_head': functools.partial(&lt;class 'tsai.models.layers.lin_nd_head'&gt;, d=3)})\ntorch.Size([13, 3, 2])\nTensorBase(0.8796, grad_fn=&lt;AliasBackward0&gt;)\n\n\n\nsource\n\n\ncount_parameters\n\n count_parameters (model, trainable=True)\n\n\nsource\n\n\nbuild_tsimage_model\n\n build_tsimage_model (arch, c_in=None, c_out=None, dls=None,\n                      pretrained=False, device=None, verbose=False,\n                      init=None, arch_config={}, **kwargs)\n\n\nsource\n\n\nbuild_tabular_model\n\n build_tabular_model (arch, dls, layers=None, emb_szs=None, n_out=None,\n                      y_range=None, device=None, arch_config={}, **kwargs)\n\n\nfrom tsai.data.external import get_UCR_data\nfrom tsai.data.core import TSCategorize, get_ts_dls\nfrom tsai.data.preprocessing import TSStandardize\nfrom tsai.models.InceptionTime import *\n\n\nX, y, splits = get_UCR_data('NATOPS', split_data=False)\ntfms = [None, TSCategorize()]\nbatch_tfms = TSStandardize()\ndls = get_ts_dls(X, y, splits, tfms=tfms, batch_tfms=batch_tfms)\nmodel = build_ts_model(InceptionTime, dls=dls)\ntest_eq(count_parameters(model), 460038)\n\n\nsource\n\n\nget_clones\n\n get_clones (module, N)\n\n\nm = nn.Conv1d(3,4,3)\nget_clones(m, 3)\n\nModuleList(\n  (0-2): 3 x Conv1d(3, 4, kernel_size=(3,), stride=(1,))\n)\n\n\n\nsource\n\n\nsplit_model\n\n split_model (m)\n\n\nsource\n\n\noutput_size_calculator\n\n output_size_calculator (mod, c_in, seq_len=None)\n\n\nc_in = 3\nseq_len = 30\nm = nn.Conv1d(3, 12, kernel_size=3, stride=2)\nnew_c_in, new_seq_len = output_size_calculator(m, c_in, seq_len)\ntest_eq((new_c_in, new_seq_len), (12, 14))\n\n\nsource\n\n\nchange_model_head\n\n change_model_head (model, custom_head, **kwargs)\n\nReplaces a model’s head by a custom head as long as the model has a head, head_nf, c_out and seq_len attributes\n\nsource\n\n\ntrue_forecaster\n\n true_forecaster (o, split, horizon=1)\n\n\nsource\n\n\nnaive_forecaster\n\n naive_forecaster (o, split, horizon=1)\n\n\na = np.random.rand(20).cumsum()\nsplit = np.arange(10, 20)\na, naive_forecaster(a, split, 1), true_forecaster(a, split, 1)\n\n(array([0.99029138, 1.68463991, 2.21744589, 2.65448222, 2.85159354,\n        3.26171729, 3.67986707, 4.04343956, 4.3077458 , 4.44585435,\n        4.76876866, 4.85844441, 4.93256093, 5.52415845, 6.10704489,\n        6.74848957, 7.31920741, 8.20198208, 8.78954283, 9.0402    ]),\n array([4.44585435, 4.76876866, 4.85844441, 4.93256093, 5.52415845,\n        6.10704489, 6.74848957, 7.31920741, 8.20198208, 8.78954283]),\n array([4.76876866, 4.85844441, 4.93256093, 5.52415845, 6.10704489,\n        6.74848957, 7.31920741, 8.20198208, 8.78954283, 9.0402    ]))",
    "crumbs": [
      "Models",
      "Model utilities"
    ]
  },
  {
    "objectID": "data.external.html",
    "href": "data.external.html",
    "title": "External data",
    "section": "",
    "text": "Helper functions used to download and extract common time series datasets.\n\n\nsource\n\ndecompress_from_url\n\n decompress_from_url (url, target_dir=None, verbose=False)\n\n\nsource\n\n\ndownload_data\n\n download_data (url, fname=None, c_key='archive', force_download=False,\n                timeout=4, verbose=False)\n\nDownload url to fname.\n\nsource\n\n\nget_UCR_univariate_list\n\n get_UCR_univariate_list ()\n\n\nsource\n\n\nget_UCR_multivariate_list\n\n get_UCR_multivariate_list ()\n\n\nsource\n\n\nget_UCR_data\n\n get_UCR_data (dsid, path='.', parent_dir='data/UCR', on_disk=True,\n               mode='c', Xdtype='float32', ydtype=None, return_split=True,\n               split_data=True, force_download=False, verbose=False)\n\n\nfrom fastai.data.transforms import get_files\n\n\nPATH = Path('.')\ndsids = ['ECGFiveDays', 'AtrialFibrillation'] # univariate and multivariate\nfor dsid in dsids:\n    print(dsid)\n    tgt_dir = PATH/f'data/UCR/{dsid}'\n    if os.path.isdir(tgt_dir): shutil.rmtree(tgt_dir)\n    test_eq(len(get_files(tgt_dir)), 0) # no file left\n    X_train, y_train, X_valid, y_valid = get_UCR_data(dsid)\n    test_eq(len(get_files(tgt_dir, '.npy')), 6)\n    test_eq(len(get_files(tgt_dir, '.npy')), len(get_files(tgt_dir))) # test no left file/ dir\n    del X_train, y_train, X_valid, y_valid\n    X_train, y_train, X_valid, y_valid = get_UCR_data(dsid)\n    test_eq(X_train.ndim, 3)\n    test_eq(y_train.ndim, 1)\n    test_eq(X_valid.ndim, 3)\n    test_eq(y_valid.ndim, 1)\n    test_eq(len(get_files(tgt_dir, '.npy')), 6)\n    test_eq(len(get_files(tgt_dir, '.npy')), len(get_files(tgt_dir))) # test no left file/ dir\n    test_eq(X_train.ndim, 3)\n    test_eq(y_train.ndim, 1)\n    test_eq(X_valid.ndim, 3)\n    test_eq(y_valid.ndim, 1)\n    test_eq(X_train.dtype, np.float32)\n    test_eq(X_train.__class__.__name__, 'memmap')\n    del X_train, y_train, X_valid, y_valid\n    X_train, y_train, X_valid, y_valid = get_UCR_data(dsid, on_disk=False)\n    test_eq(X_train.__class__.__name__, 'ndarray')\n    del X_train, y_train, X_valid, y_valid\n\nECGFiveDays\nAtrialFibrillation\n\n\n\nX_train, y_train, X_valid, y_valid = get_UCR_data('natops')\n\n\ndsid = 'natops' \nX_train, y_train, X_valid, y_valid = get_UCR_data(dsid, verbose=True)\nX, y, splits = get_UCR_data(dsid, split_data=False)\ntest_eq(X[splits[0]], X_train)\ntest_eq(y[splits[1]], y_valid)\ntest_eq(X[splits[0]], X_train)\ntest_eq(y[splits[1]], y_valid)\ntest_type(X, X_train)\ntest_type(y, y_train)\n\nDataset: NATOPS\nX_train: (180, 24, 51)\ny_train: (180,)\nX_valid: (180, 24, 51)\ny_valid: (180,) \n\n\n\n\nsource\n\n\ncheck_data\n\n check_data (X, y=None, splits=None, show_plot=True)\n\n\ndsid = 'ECGFiveDays'\nX, y, splits = get_UCR_data(dsid, split_data=False, on_disk=False, force_download=False)\ncheck_data(X, y, splits)\ncheck_data(X[:, 0], y, splits)\ny = y.astype(np.float32)\ncheck_data(X, y, splits)\ny[:10] = np.nan\ncheck_data(X[:, 0], y, splits)\nX, y, splits = get_UCR_data(dsid, split_data=False, on_disk=False, force_download=False)\nsplits = get_splits(y, 3)\ncheck_data(X, y, splits)\ncheck_data(X[:, 0], y, splits)\ny[:5]= np.nan\ncheck_data(X[:, 0], y, splits)\nX, y, splits = get_UCR_data(dsid, split_data=False, on_disk=False, force_download=False)\n\nX      - shape: [884 samples x 1 features x 136 timesteps]  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:&lt;U1  n_classes: 2 (442 samples per class) ['1', '2']  isnan: False\nsplits - n_splits: 2 shape: [23, 861]  overlap: False\n\n\n\n\n\n\n\n\n\nX      - shape: (884, 136)  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:&lt;U1  n_classes: 2 (442 samples per class) ['1', '2']  isnan: False\nsplits - n_splits: 2 shape: [23, 861]  overlap: False\n\n\n\n\n\n\n\n\n\nX      - shape: [884 samples x 1 features x 136 timesteps]  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:float32  isnan: 0\nsplits - n_splits: 2 shape: [23, 861]  overlap: False\n\n\n\n\n\n\n\n\n\nX      - shape: (884, 136)  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:float32  isnan: 10\nsplits - n_splits: 2 shape: [23, 861]  overlap: False\n\n\n/var/folders/42/4hhwknbd5kzcbq48tmy_gbp00000gn/T/ipykernel_70492/278801922.py:23: UserWarning: y contains nan values\n  warnings.warn('y contains nan values')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX      - shape: [884 samples x 1 features x 136 timesteps]  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:&lt;U1  n_classes: 2 (442 samples per class) ['1', '2']  isnan: False\nsplits - n_splits: 3 shape: [[589, 295], [589, 295], [590, 294]]  overlap: [False, False, False]\n\n\n\n\n\n\n\n\n\nX      - shape: (884, 136)  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:&lt;U1  n_classes: 2 (442 samples per class) ['1', '2']  isnan: False\nsplits - n_splits: 3 shape: [[589, 295], [589, 295], [590, 294]]  overlap: [False, False, False]\n\n\n\n\n\n\n\n\n\nX      - shape: (884, 136)  type: ndarray  dtype:float32  isnan: 0\ny      - shape: (884,)  type: ndarray  dtype:&lt;U1  n_classes: 3 (294 samples per class) ['1', '2', 'n']  isnan: False\nsplits - n_splits: 3 shape: [[589, 295], [589, 295], [590, 294]]  overlap: [False, False, False]\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nget_Monash_regression_list\n\n get_Monash_regression_list ()\n\n\nsource\n\n\nget_Monash_regression_data\n\n get_Monash_regression_data (dsid, path='./data/Monash', on_disk=True,\n                             mode='c', Xdtype='float32', ydtype=None,\n                             split_data=True, force_download=False,\n                             verbose=False, timeout=4)\n\n\ndsid = \"Covid3Month\"\nX_train, y_train, X_valid, y_valid = get_Monash_regression_data(dsid, on_disk=False, split_data=True, force_download=False)\nX, y, splits = get_Monash_regression_data(dsid, on_disk=True, split_data=False, force_download=False, verbose=True)\nif X_train is not None: \n    test_eq(X_train.shape, (140, 1, 84))\nif X is not None: \n    test_eq(X.shape, (201, 1, 84))\n\nDataset: Covid3Month\nX      : (201, 1, 84)\ny      : (201,)\nsplits : (#140) [0,1,2,3,4,5,6,7,8,9...] (#61) [140,141,142,143,144,145,146,147,148,149...] \n\n\n\n\nsource\n\n\nget_forecasting_list\n\n get_forecasting_list ()\n\n\nsource\n\n\nget_forecasting_time_series\n\n get_forecasting_time_series (dsid, path='./data/forecasting/',\n                              force_download=False, verbose=True,\n                              **kwargs)\n\n\nts = get_forecasting_time_series(\"sunspots\", force_download=False)\ntest_eq(len(ts), 2820)\nts\n\nDataset: Sunspots\ndownloading data...\n...done. Path = data/forecasting/Sunspots.csv\n\n\n\n\n\n\n\n\n\nSunspots\n\n\nMonth\n\n\n\n\n\n1749-01-31\n58.0\n\n\n1749-02-28\n62.6\n\n\n1749-03-31\n70.0\n\n\n1749-04-30\n55.7\n\n\n1749-05-31\n85.0\n\n\n...\n...\n\n\n1983-08-31\n71.8\n\n\n1983-09-30\n50.3\n\n\n1983-10-31\n55.8\n\n\n1983-11-30\n33.3\n\n\n1983-12-31\n33.4\n\n\n\n\n2820 rows × 1 columns\n\n\n\n\nts = get_forecasting_time_series(\"weather\", force_download=False)\nif ts is not None: \n    test_eq(len(ts), 70091)\n    display(ts)\n\nDataset: Weather\ndownloading data...\n...done. Path = data/forecasting/Weather.csv.zip\n\n\n\n\n\n\n\n\n\np (mbar)\nT (degC)\nTpot (K)\nTdew (degC)\nrh (%)\nVPmax (mbar)\nVPact (mbar)\nVPdef (mbar)\nsh (g/kg)\nH2OC (mmol/mol)\nrho (g/m**3)\nWx\nWy\nmax Wx\nmax Wy\nDay sin\nDay cos\nYear sin\nYear cos\n\n\n\n\n0\n996.50\n-8.05\n265.38\n-8.78\n94.40\n3.33\n3.14\n0.19\n1.96\n3.15\n1307.86\n-0.204862\n-0.046168\n-0.614587\n-0.138503\n-1.776611e-12\n1.000000\n0.009332\n0.999956\n\n\n1\n996.62\n-8.88\n264.54\n-9.77\n93.20\n3.12\n2.90\n0.21\n1.81\n2.91\n1312.25\n-0.245971\n-0.044701\n-0.619848\n-0.112645\n2.588190e-01\n0.965926\n0.010049\n0.999950\n\n\n2\n996.84\n-8.81\n264.59\n-9.66\n93.50\n3.13\n2.93\n0.20\n1.83\n2.94\n1312.18\n-0.175527\n0.039879\n-0.614344\n0.139576\n5.000000e-01\n0.866025\n0.010766\n0.999942\n\n\n3\n996.99\n-9.05\n264.34\n-10.02\n92.60\n3.07\n2.85\n0.23\n1.78\n2.85\n1313.61\n-0.050000\n-0.086603\n-0.190000\n-0.329090\n7.071068e-01\n0.707107\n0.011483\n0.999934\n\n\n4\n997.46\n-9.63\n263.72\n-10.65\n92.20\n2.94\n2.71\n0.23\n1.69\n2.71\n1317.19\n-0.368202\n0.156292\n-0.810044\n0.343843\n8.660254e-01\n0.500000\n0.012199\n0.999926\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n70086\n1002.18\n-0.98\n272.01\n-5.36\n72.00\n5.69\n4.09\n1.59\n2.54\n4.08\n1280.70\n-0.855154\n-0.160038\n-1.336792\n-0.250174\n-9.990482e-01\n0.043619\n0.006183\n0.999981\n\n\n70087\n1001.40\n-1.40\n271.66\n-6.84\n66.29\n5.51\n3.65\n1.86\n2.27\n3.65\n1281.87\n-0.716196\n-0.726267\n-1.348134\n-1.367090\n-9.537170e-01\n0.300706\n0.006900\n0.999976\n\n\n70088\n1001.19\n-2.75\n270.32\n-6.90\n72.90\n4.99\n3.64\n1.35\n2.26\n3.63\n1288.02\n-0.661501\n0.257908\n-1.453438\n0.566672\n-8.433914e-01\n0.537300\n0.007617\n0.999971\n\n\n70089\n1000.65\n-2.89\n270.22\n-7.15\n72.30\n4.93\n3.57\n1.37\n2.22\n3.57\n1288.03\n-0.280621\n-0.209169\n-0.545207\n-0.406385\n-6.755902e-01\n0.737277\n0.008334\n0.999965\n\n\n70090\n1000.11\n-3.93\n269.23\n-8.09\n72.60\n4.56\n3.31\n1.25\n2.06\n3.31\n1292.41\n-0.516998\n-0.215205\n-0.923210\n-0.384295\n-4.617486e-01\n0.887011\n0.009050\n0.999959\n\n\n\n\n70091 rows × 19 columns\n\n\n\n\nsource\n\n\nconvert_tsf_to_dataframe\n\n convert_tsf_to_dataframe (full_file_path_and_name,\n                           replace_missing_vals_with='NaN',\n                           value_column_name='series_value')\n\n\nsource\n\n\nget_Monash_forecasting_data\n\n get_Monash_forecasting_data (dsid, path='./data/forecasting/',\n                              force_download=False,\n                              remove_from_disk=False, add_timestamp=True,\n                              verbose=True)\n\n\nsource\n\n\nget_fcst_horizon\n\n get_fcst_horizon (frequency, dsid)\n\n\nsource\n\n\npreprocess_Monash_df\n\n preprocess_Monash_df (df, frequency)\n\n\ndsid = 'covid_deaths_dataset'\ndf = get_Monash_forecasting_data(dsid, force_download=False)\nif df is not None: \n    test_eq(df.shape, (56392, 3))\n\nDataset: covid_deaths_dataset\ndownloading data...\n...data downloaded\ndecompressing data...\n...data decompressed\nconverting data to dataframe...\n...done\n\nfreq                   : daily\nforecast_horizon       : 30\ncontain_missing_values : False\ncontain_equal_length   : True\n\nexploding dataframe...\n...done\n\n\ndata.shape: (56392, 3)\n\n\n\nsource\n\n\ndownload_all_long_term_forecasting_data\n\n download_all_long_term_forecasting_data\n                                          (target_dir='./data/long_forecas\n                                          ting/', force_download=False,\n                                          remove_zip=False,\n                                          c_key='archive', timeout=4,\n                                          verbose=True)\n\n\nsource\n\n\nunzip_file\n\n unzip_file (file, target_dir)\n\n\nsource\n\n\nget_long_term_forecasting_data\n\n get_long_term_forecasting_data (dsid,\n                                 target_dir='./data/long_forecasting/',\n                                 task='M', fcst_horizon=None,\n                                 fcst_history=None, preprocess=True,\n                                 force_download=False, remove_zip=False,\n                                 return_df=True, show_plot=True,\n                                 dtype=&lt;class 'numpy.float32'&gt;,\n                                 verbose=True, **kwargs)\n\nDownloads (and preprocess) a pandas dataframe with the requested long-term forecasting dataset\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndsid\n\n\nID of the dataset to be used for long-term forecasting.\n\n\ntarget_dir\nstr\n./data/long_forecasting/\nDirectory where the long-term forecasting data will be saved.\n\n\ntask\nstr\nM\n‘M’ for multivariate, ‘S’ for univariate and ‘MS’ for multivariate input with univariate output\n\n\nfcst_horizon\nNoneType\nNone\n# historical steps used as input. If None, the default is applied.\n\n\nfcst_history\nNoneType\nNone\n# steps forecasted into the future. If None, the minimum default is applied.\n\n\npreprocess\nbool\nTrue\nFlag that indicates whether if the data is preprocessed before saving.\n\n\nforce_download\nbool\nFalse\nFlag that indicates if the data should be downloaded again even if directory exists.\n\n\nremove_zip\nbool\nFalse\nFlag that indicates if the zip file should be removed after extracting the data.\n\n\nreturn_df\nbool\nTrue\nFlag that indicates whether a dataframe (True) or X and and y arrays (False) are returned.\n\n\nshow_plot\nbool\nTrue\nplot the splits\n\n\ndtype\ntype\nfloat32\n\n\n\nverbose\nbool\nTrue\nFlag tto indicate the verbosity.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\ndsid = \"ILI\"\ntry:\n    df = get_long_term_forecasting_data(dsid, target_dir='./data/forecasting/', force_download=False)\n    print(f\"{dsid:15}: {str(df.shape):15}\")\n    del df; gc.collect()\n    remove_dir('./data/forecasting/', False)\nexcept Exception as e:\n    print(f\"{dsid:15}: {str(e):15}\")\n\n\n\n\n\n\n    \n      \n      100.01% [54001664/53995526 00:09&lt;00:00]\n    \n    \n\n\n/Users/nacho/opt/anaconda3/envs/py39t20/lib/python3.9/site-packages/fastai/tabular/core.py:23: UserWarning: The argument 'infer_datetime_format' is deprecated and will be removed in a future version. A strict version of it is now the default, see https://pandas.pydata.org/pdeps/0004-consistent-to-datetime-parsing.html. You can safely remove this argument.\n  df[date_field] = pd.to_datetime(df[date_field], infer_datetime_format=True)\n\n\nILI            : (966, 8)       \n\n\n\ndsid = \"ILI\"\ntry:\n    X, y, splits, stats = get_long_term_forecasting_data(dsid, target_dir='./data/forecasting/', force_download=False, return_df=False, show_plot=False)\n    print(f\"{dsid:15} -  X.shape: {str(X.shape):20}  y.shape: {str(y.shape):20}  splits: {str([len(s) for s in splits]):25}  \\\nstats: {str([s.shape for s in stats]):30}\")\n    del X, y, splits, stats\n    gc.collect()\n    remove_dir('./data/forecasting/', False)\nexcept Exception as e:\n    print(f\"{dsid:15}: {str(e):15}\")\n\n\n\n\n\n\n    \n      \n      100.01% [54001664/53995526 00:09&lt;00:00]\n    \n    \n\n\n/Users/nacho/opt/anaconda3/envs/py39t20/lib/python3.9/site-packages/fastai/tabular/core.py:23: UserWarning: The argument 'infer_datetime_format' is deprecated and will be removed in a future version. A strict version of it is now the default, see https://pandas.pydata.org/pdeps/0004-consistent-to-datetime-parsing.html. You can safely remove this argument.\n  df[date_field] = pd.to_datetime(df[date_field], infer_datetime_format=True)\n\n\nILI             -  X.shape: (839, 7, 104)         y.shape: (839, 7, 24)          splits: [549, 74, 170]             stats: [(1, 7, 1), (1, 7, 1)]",
    "crumbs": [
      "Data",
      "External data"
    ]
  }
]