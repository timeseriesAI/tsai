# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/200_data.synthetic.ipynb (unless otherwise specified).

__all__ = ['get_synthetic_sin_data']

# Cell
from ..imports import *

# Internal Cell
def _get_sin_waveforms(length=1000, n_sig=10):
    if (isinstance(length, tuple) or isinstance(length, tuple)):
        assert len(length) == 2
        lengths = np.random.randint(*length, n_sig)
    else:
        lengths = [length]*n_sig

    all_sig = []
    for i, scale_x in enumerate(2.0*np.pi/100*np.linspace(0.8, 1.2, n_sig)):
        n = lengths[i]
        offset = 2.0*np.pi*random.random()
        sig = np.sin(offset + scale_x*np.arange(n))*np.linspace(1.5, 0.5, n)
        all_sig.append(sig)

    if (isinstance(length, tuple) or isinstance(length, tuple)):
        return L(*all_sig)
    else:
        return np.array(all_sig)

# Internal Cell
def _get_sin_peaks(data, use_neg=False):
    """Extracts location of waveform peaks"""
    results = []
    for sig in data:
        deriv = -np.diff(sig) if use_neg else np.diff(sig)
        peaks = np.logical_and(deriv[:-1]> 0, deriv[1:]<= 0)
        results.append(L(*np.where(peaks)[0]))
    return L(*results)

# Internal Cell
def _get_sample_folds(n_sig, n_fold):
    folds = L(*np.array([*range(n_fold)]*((n_sig+n_fold-1)//n_fold)))
    folds = folds.shuffle()
    folds = folds[:n_sig]
    assert len(folds) == n_sig
    return folds

# Internal Cell
def _get_sample_splits(n_sig, split_pct):
    assert isinstance(split_pct, float) or isinstance(split_pct, tuple) or isinstance(split_pct, list)
    all_indices = L(*range(n_sig))
    all_indices = all_indices.shuffle()
    if isinstance(split_pct, float):
        i_val = int(round(split_pct*n_sig))
        splits = L(all_indices[i_val:].sorted(), all_indices[:i_val].sorted())
    else:
        assert len(split_pct) == 2
        i_val = int(round(split_pct[0]*n_sig))
        i_test = i_val+int(round(split_pct[0]*n_sig))
        splits = L(all_indices[i_test:].sorted(), all_indices[:i_val].sorted(), all_indices[i_val:i_test].sorted())
    return splits

# Internal Cell
def _add_list_depth(o):
    if isinstance(o, (tuple, list, L)):
        return L(_add_list_depth(_z) for _z in o)
    else:
        return [o]

# Cell
def get_synthetic_sin_data(length=1000, n_sig=10, dims=2, per_ann_label=False,
                           label_is_array=False, n_classes=5, has_multi_label=False,
                           n_fold=None, split_pct=None):
    """ Generates sample data with associated annotation positions at local maxima"""
    assert dims in (2,3)
    X = _get_sin_waveforms(length=length, n_sig=n_sig)

    if per_ann_label or label_is_array:
        pos_loc, neg_loc = _get_sin_peaks(X), _get_sin_peaks(X, use_neg=True)
        y, ann_pos = [], []
        for i in range(n_sig):
            combined = sorted([(e, 'p') for e in pos_loc[i]] + [(e, 'n') for e in neg_loc[i]])
            ann_pos.append([z[0] for z in combined])
            y.append(L(z[1] for z in combined))
        y, ann_pos = L(*y), L(*ann_pos)
    else:
        y = L(f'ID{i%n_classes:06d}'for i in range(n_sig))
        ann_pos = _get_sin_peaks(X)

    if label_is_array:
        y_orig = y
        if isinstance(X, L):  # ragged:
            y = L(np.zeros((_x.shape[-1]), dtype=np.int) for _x in X)
        else:
            y = np.zeros((X.shape[0], X.shape[-1]), dtype=np.int)

        for i, y_row in enumerate(y_orig):
            for j, label in enumerate(y_row):
                pos = ann_pos[i][j]
                y[i][pos] = 1 if label == 'p' else -1

    if has_multi_label and (per_ann_label or not label_is_array):
        y = _add_list_depth(y)

    if dims==3:
        X = np.expand_dims(X, 1) if isinstance(X, np.ndarray) else L(np.expand_dims(_x, 0) for _x in X)

    if n_fold is not None:
        folds = _get_sample_folds(n_sig, n_fold)
        return X, y, ann_pos, folds
    elif split_pct is not None:
        splits = _get_sample_splits(n_sig, split_pct)
        return X, y, ann_pos, splits
    else:
        return X, y, ann_pos