# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/200_data.synthetic.ipynb (unless otherwise specified).

__all__ = ['get_sample_data']

# Cell
from ..imports import *
from ..utils import *
from .validation import *

# Internal Cell
def _get_sample_signals(length=1000, n_sig=10):
    if (isinstance(length, tuple) or isinstance(length, tuple)):
        assert len(length) == 2
        lengths = np.random.randint(*length, n_sig)
    else:
        lengths = [length]*n_sig

    all_sig = []
    for i, scale_x in enumerate(2.0*np.pi/100*np.linspace(0.8, 1.2, n_sig)):
        n = lengths[i]
        offset = 2.0*np.pi*random.random()
        sig = np.sin(offset + scale_x*np.arange(n))*np.linspace(1.5, 0.5, n)
        all_sig.append(sig)

    if (isinstance(length, tuple) or isinstance(length, tuple)):
        return np.array(all_sig, dtype=object)
    else:
        return np.array(all_sig)

# Internal Cell
def _get_sample_events(data):
    """Use signal peaks for sample events"""
    results = []
    for sig in data:
        deriv = np.diff(sig)
        peaks = np.logical_and(deriv[:-1]> 0, deriv[1:]<= 0)
        results.append(np.where(peaks)[0])
    return results

# Internal Cell
def _get_sample_folds(n_sig, n_fold):
    folds = np.array([*range(n_fold)]*((n_sig+n_fold-1)//n_fold))
    np.random.shuffle(folds)
    folds = folds[:n_sig]
    assert len(folds) == n_sig
    return folds

# Internal Cell
def _get_sample_splits(n_sig, split_pct):
    assert isinstance(split_pct, float) or isinstance(split_pct, tuple) or isinstance(split_pct, list)
    all_indices = [*range(n_sig)]
    random.shuffle(all_indices)
    if isinstance(split_pct, float):
        i_val = int(round(split_pct*n_sig))
        splits = L(sorted(all_indices[i_val:]), sorted(all_indices[:i_val]))
    else:
        assert len(split_pct) == 2
        i_val = int(round(split_pct[0]*n_sig))
        i_test = i_val+int(round(split_pct[0]*n_sig))
        splits = L(sorted(all_indices[i_test:]), sorted(all_indices[:i_val]), sorted(all_indices[i_val:i_test]))
    return splits

# Cell
def get_sample_data(length=1000, n_sig=10, dims=2, n_fold=None, split_pct=None):
    """ Generates sample data with associated events at local maxima
Inputs:
    length:    Length of individual signals, expressed as int or tuple (min_len, max_len)
    n_sig:     Number of signals to be generated.
    dims:      Number of dimensions in X array (2 or 3).  If 3, channel dimension will be added,
    n_fold:    Optional number of folds, signals randomly distributed among folds
    split_pct: Optional split fractions, expressed as int of train/valid or tuple
               (pct_valid, pct_tst) if train/valid/test
Refurns:
    X:         Synthetic signal data
    y:         Synthetic labels where label is index of row in X
    splits:    Optional splits data if split_pct specified
    folds:     Optional folds data if n_fold specified
    *note: splits and folds are metuallly exclusive

    """
    assert dims in (2,3)
    X = _get_sample_signals(length=length, n_sig=n_sig)
    y = np.array([f'ID{i:06d}'for i in range(n_sig)])
    events = _get_sample_events(X)

    if dims==3:
        X = np.expand_dims(X, 1)

    if n_fold is not None:
        folds = _get_sample_folds(n_sig, n_fold)
        return X, y, events, folds
    elif split_pct is not None:
        splits = _get_sample_splits(n_sig, split_pct)
        return X, y, events, splits
    else:
        return X, y, events